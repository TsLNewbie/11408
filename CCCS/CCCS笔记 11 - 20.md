---
title: CCCS笔记 11 - 20
category: /小书匠/日记/2023-11
grammar_cjkRuby: true
tags: CCCS,计算机
---

[toc!]
## 第十一课  编程语言发展史
### 0、概念梳理

 - 伪代码（Pseudo-Code)：用自然语言（中文、英语等）对程序的高层次描述，称为“伪代码”
     - 用"操作码表"(Opcode Tables)把伪代码转成 二进制机器码
 - 汇编器(Assembler)：是一个二进制(Binary)程序它可以读懂文字指令，自动转成二进制指令。用于将汇编语言装换成机器语言。一条汇编语句对应一条机器指令。
 - 助记符(Mnemonics)（汇编器）：每个操作码分配一个简单名字。1940~1950年代，程序员开发出的一种新语言，具有更可读和更高层次。此时与其使用1和0写代码，程序员可以写"LOAD_A 14"
 - 软件

### 1、早期二进制写代码
先前都是硬件层面的编程，硬件编程非常麻烦，所以程序员想要一种更通用的编程方法，就是软件。
早期，人们先在纸上写伪代码，用"操作码表"把伪代码转成二进制机器码，翻译完成后，程序可以喂入计算机并运行。

### 2、汇编器&助记符

 - 背景：1940~1950s，程序员开发出一种新语言， 更可读 更高层次。每个操作码分配一个简单名字，叫"助记符"。但计算机不能读懂“助记符”，因此人们写了二进制程序“汇编器来帮忙”
 - 作用：汇编器读取用"汇编语言"写的程序，然后转成"机器码"。

汇编器的一个效果例子:
功能：自动分析JUMP 地址(第八章提到的JUMP 指令)
![enter description here](./images/1699338468212.png)
注意： 此时 JUMP-NEG 指令跳到地址 5
IF 我们多加了几个程序，或者改变程序的位置，JUMP指令就会报BUG。
![enter description here](./images/1699338512283.png)
这就是汇编器给的效果，它会自动检测程序。
![enter description here](./images/1699338559353.png)


### 3、最早高级编程语言“A-0”
汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件的连接很紧密，汇编器仍然强迫程序员思考底层逻辑。

1950s，为释放超算潜力，葛丽丝·霍普博士，设计了一个高级编程语言，叫 "Arithmetic Language Version 0"，一行高级编程语言  可以转成几十条二进制指令。但由于当时人们认为，计算机只能做计算，而不能做程序，A-0未被广泛使用。

过程：高级编程语言→编译器→汇编码/机器码
现在，编程语言会比之前的汇编语言好很多，高级很多。需要做的事也相对简单很多，这都是多亏了语言背后的编译器(Compiler)。
至于背后有什么原理，编译器做了什么，物理层面上发生了什么。
Out of sight, Out of Mind!(眼不见,心不烦)
![enter description here](./images/1699338779088.png)

### 4、开始广泛应用的高级编程语言FORTRAN
FORTRAN (Formula Translation)
1957年由IBM1957年发布，平均来说，FORTRAN 写的程序，比等同的手写汇编代码短 20 倍， FORTRAN 编译器会把代码转成机器码。
Tips:FORTRAN 项目总监 John Backus 说过,我写这个语言，因为我懒。![enter description here](./images/1699339078997.png)（懒是人类的第一大动力）


### 5、通用编程语言——COBOL
普通面向商业语言- Common Business-Oriented Language  COBOL
1959年，研发可以在不同机器上通用编程语言。最后研发出一门高级语言："普通面向商业语言"，简称 COBOL每个计算架构需要一个 COBOL 编译器，不管是什么电脑都可以运行相同的代码，得到相同结果。

Write Once, Run Anywhere （一次编写，到处运行）

### 6、现代编程语言:1960s-2000

 - 1960s起，编程语言设计进入黄金时代。
 - 1960 ：ALGOL, LISP 和 BASIC 等语言
 - 70年代有：Pascal，**C** 和 Smalltalk
 - 80年代有：C++，Objective-C 和 Perl
 - 90年代有：Python，Ruby 和 Java
 - 新千年： Swift, C#, Go

### 7、安全漏洞&补丁由来：
在1940年代，是用打孔纸带进行的，但程序出现了问题（也就是漏洞），为了节约时间，只能贴上胶带也就是打补丁来填补空隙，漏洞和补丁因此得名。

## 第十二课 编程基础 - 语句和函数
编程语言 (Programming Languages)

### 1.语句(Statements)- 语法(syntax)
就像口语一样，编程语言有"语句"(Statements):表达一整句子的意思。
以下为语句：
```
a = 5
b = 10
c = a+b
```

### 2. Initialize 初始化

把打Bug当作一个游戏，你需要初始化一下数据:
```
Level = 1
Score = 0
Bugs = 5
Relays = 4
Playername = senpai
```

### 3.控制流语句 Control Flow Statements

为了做成交互式游戏，程序的执行顺序要更灵活，而不是只是从上到下运行。
因此我们需要：
- "Control Flow Statements" (控制流语句)
   - 其中最常见的是 **IF 语句** 
   - 这种类型的语句又叫："Conditional Statements"(条件语句)
 #### IF 语句
 C 语言：
```c
if (a > 0){
	printf("yes");
}else {
	printf("no");
}
```
C++:
```c++
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;
 
   // 使用 if 语句检查布尔条件
   if( a < 20 )
   {
       // 如果条件为真，则输出下面的语句
       cout << "a 小于 20" << endl;
   }
   cout << "a 的值是 " << a << endl;
 
   return 0;
}
```
Python:
```python
if a > 0 :
	print "yes"
else
	print "no"
```

Java:
```java
public class Test {
 
   public static void main(String args[]){
      int x = 10;
 
      if( x < 20 ){
         System.out.print("这是 if 语句");
      }
   }
}
```
#### While 语句
 C 语言：
```c
int main ()
{
   /* 局部变量定义 */
   int a = 10;

   /* while 循环执行 */
   while( a < 20 )
   {
      printf("a 的值： %d\n", a);
      a++;
   }
 
   return 0;
}
```

C++:
```c++
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // while 循环执行
   while( a < 20 )
   {
       cout << "a 的值：" << a << endl;
       a++;
   }
 
   return 0;
}

```
Python:
```python
i = 1
while i < 7:
  print(i)
  i += 1
```

Java:
```java
public class Test {
   public static void main(String[] args) {
      int x = 10;
      while( x < 20 ) {
         System.out.print("value of x : " + x );
         x++;
         System.out.print("\n");
      }
   }
}
```


#### For 语句
 C 语言：
```c
#include <stdio.h>
 
int main ()
{
   /* for 循环执行 */
   for( int a = 10; a < 20; a = a + 1 )
   {
      printf("a 的值： %d\n", a);
   }
 
   return 0;
}
```
C++:
```c++
#include <iostream>
using namespace std;
 
int main ()
{
   // for 循环执行
   for( int a = 10; a < 20; a = a + 1 )
   {
       cout << "a 的值：" << a << endl;
   }
 
   return 0;
}

```
Python:
```python
sites = ["Baidu", "Google","Runoob","Taobao"] #列表
for site in sites:
    print(site)
```

Java:
```java
public class Test {
   public static void main(String[] args) {
 
      for(int x = 10; x < 20; x = x+1) {
         System.out.print("value of x : " + x );
         System.out.print("\n");
      }
   }
}
```

### 4.函数 functions
为了隐藏复杂度，代码可以打包成函数。

![完整的functions](./images/1699343367108.png)
调用此程序后的效果：
![enter description here](./images/1699343412670.png)

多次的进行函数编写后，最后就只有这一行代码调用，就能获得以下的数据：
![](./images/1699343582313.png)

<center><h3>It's not Magic, it's the power of Adstraction!</h3> </center>

### 5.模块化编程 Modularizing Programs
不仅可以让单个程序员独立制作APP，也让团队协作可以写更大型的程序。

**Tips:多于100行的代码，就应该存在可以拆出来做成一个函数的代码。
所以就导致了多于100行的代码很少见。**

### 6.库 Libraries
现代编程语言 有很多预先写好的函数集合，用于给程序员直接调用使用，减少大量繁琐且重复的编写。

## 第十三课 算法入门 Algorithms（重点）
>**Algorithm 算法：解决问题的具体步骤**
>算法是很多东西的核心，程序，人工智能，以及现在最常用的各种软件都和算法抛不开关系
>算法也是**数据结构课**中重要知识点之一

### 排序算法 Sorting
这是一个记载最多的算法。eg.给名字，数据排序。

排序算法是非常非常多的。以下有几个知名的排序算法（有一些是数据结构里需要知道的）
- 冒泡排序 Bubble Sort
- 选择排序 Selection Sort
- 插入排序 Insertion Sort
- 希尔排序 Shell Sort
- 归并排序 Merge Sort
- 快速排序 Quick Sort
- 堆排序 Heap Sort
- 计数排序 Counting Sort
- 桶排序 Bucket Sort
- 基数排序 Radix Sort


- 意面排序 Spaghetti Sort （What?)

参考Blog: https://www.cnblogs.com/onepixel/articles/7674659.html#:~:text=%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89%201%200%E3%80%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%202%201%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89%203%202%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection,4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89%206%205%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge%20Sort%EF%BC%89%207%206%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89

![十大排序表](./images/1699344345581.png)
#### 1.选择排序 Selection Sort 
>Example:
我们想象一下我们飞去 印度 的航班 有以下 票价：
![enter description here](./images/1699344616293.png)

**Array 是 数组 ，代表以上一组的数据**
视频中使用的是选择排序。
动画过程就不展示了，但是可以看以下动图（选择排序）
![enter description here](./images/1699344903338.gif)

代码实现：
```c
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
```

视频中的伪代码：
![enter description here](./images/1699345147610.png)
>遍历：把数组里的每一个数据都跑一遍

#### 1.1算法复杂度 Complexity of Algorithm
>引入一个概念：算法 输入大小 和 运行步骤 之间的关系 叫做 算法复杂度 

算法复杂度分别有： 时间 和 空间 复杂度 *（数据结构）*

算法的标志就是这个图。（对，不开玩笑）

![算法复杂度为 N^2](./images/1699345356943.png)

#### 2.归并排序 Merge Sort
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 
算法描述：

 - 把长度为n的输入序列分成两个长度为n/2的子序列；
 - 对这两个子序列分别采用归并排序；
 - 将两个排序好的子序列合并成一个最终的排序序列。

![enter description here](./images/1699345532946.gif)
```c
function mergeSort(arr) {
    var len = arr.length;
    if (len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length>0 && right.length>0) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
```