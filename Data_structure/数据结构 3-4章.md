---
title: 数据结构 3-4章
grammar_cjkRuby: true
---
第三章 栈、队列、数组
# 栈(Stack)
## 定义：
线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为
![enter description here](./images/1706516224760.png)

栈(Stack)是**只允许任一端进行插入或删除操作**的**线性表**
举个例子：石头堆，一串肉（只能从头吃到尾，放入的时候从顶部放到最低位）等等。

逻辑结构：与普通线性表相同
数据的运算：插入、删除操作有区别。

重要术语：**栈顶**，**栈底**，**空栈**
![enter description here](./images/1706516370626.png)

## 基本操作
线性表： 创销增删改查。
![enter description here](./images/1706516484027.png)

Pop(&S,&x)：&x是因为要把这个x带出去。

**栈的常考题型：**
进栈顺序：
a→b→c→d→e
有哪些合法的出栈顺序？
![](./images/1706516726529.png)

知识整合：
![](./images/1706516758236.png)


## 顺序栈的实现（物理结构）
跟线性表几乎一样：
![](./images/1706516894401.png)

**初始化操作：**
![](./images/1706517018066.png)

**增（进栈操作）：**
![](./images/1706517087500.png)
S.data[++S.top] =x：先+1，后执行S.data[S.top] = 1
S.data[\+\+S.top] =x：先执行S.data[S.top] = 1,后\+\+S.top

**删（出栈操作）：**
![](./images/1706517403964.png)

**查（读取栈顶元素操作）：**
![](./images/1706517545800.png)
跟出栈操作没啥区别。

另一种方式：
![](./images/1706517850565.png)
![](./images/1706517863082.png)
**共享栈：**
![](./images/1706518002286.png)
**知识整合：**
![](./images/1706518019836.png)

## 链式存储的栈（链栈）
**进栈**：头插法建立单链表
**出栈**：单链表的删除操作

### 定义：
![](./images/1706518204676.png)

**知识整合：**
![](./images/1706518244437.png)


# 队列(Queue)

栈(Stack) 是 只允许在一端进行插入 或 删除 操作的 线性表

队列(Queue) 是 只允许在一端进行 插入 在 另一端 删除 的线性表 

队列 其实就是 排队
![enter description here](./images/1708499194729.png)

**基本操作**
![](./images/1708499228707.png)
**知识整合：**
![enter description here](./images/1708499316364.png)

## 队列的顺序实现
![](./images/1708499441403.png)

初始化操作
![](./images/1708501094587.png)
**入队操作**
![](./images/1708502150256.png)

**假设队列并没有存满：**
![](./images/1708502227704.png)
**循环队列：**
![](./images/1708502377286.png)

**循环队列的入队操作：**
![](./images/1708502406807.png)
（其中，要牺牲这个2的存储单元，避免队列被程序当作空）

**循环队列的出队操作和查：**
![](./images/1708502546237.png)
（只能从队头 出队）

**方案一：**
![](./images/1708502624464.png)

方案二：
![](./images/1708502658757.png)

方案三：
![](./images/1708502840384.png)

**其他出题方法：**
当队尾指针指向队尾元素的话..：**（注意审题）**
![](./images/1708502971665.png)

初始化可以让front = 0 rear = n-1
![](./images/1708503087359.png)**判断队空和队满：**
![](./images/1708503285474.png)

**知识整合：**
![](./images/1708503342424.png)

## 队列的链式存储
**和单链表几乎一样！（单链表的阉割版）**
![](./images/1708503595212.png)

**初始化（带头结点）：**
![](./images/1708503714845.png)

**初始化（不带头结点）：**
![](./images/1708503792217.png)

**入队（带头结点）**：
![](./images/1708503811548.png)

**入队（不带头结点）：**
![](./images/1708503941432.png)

**出队（带头结点）：**
![](./images/1708504037542.png)

**出队（不带头结点）：**
![](./images/1708504104015.png)
**队列满的条件：**
![、](./images/1708504162880.png)

**知识整合：**
![](./images/1708504187511.png)

## 双端队列
![](./images/1708504344286.png)

**双端队列的更多形式：**
![](./images/1708504355328.png)

**考点：判断输出序列合法性**
![](./images/1708504389862.png)
输出：
**1，2，3，4 的情况**
输入1，再输出1，输入2，输出2.... 因此**合法。**


**2，4，1，3 的情况**

输入1，2 -> 输出 2 -> 输入3,4 ->输出4，没办法输出1，**因此不合法。**

**3，2，4，1的情况**

输入1，2，3 -> 输出3，2 -> 输入4 -> 出4 -> 出1 **合法。**

**4，3，2，1的情况**
这不用说了吧。

**具体答案：**
![](./images/1708504661117.png)
**如果用的是双端队列：**


栈合法的，双端也会合法。
**输入受限的双端队列：**
![](./images/1708504816320.png)

**输出受限的双端队列：**
![](./images/1708504852360.png)

**知识整合：**
![](./images/1708504874902.png)

# 栈的应用
##  括号匹配
IDE ： 可视化编程环境

**括号都是成双成对的。**
![](./images/1708524890067.png)

![](./images/1708524931730.png)

算法演示：
![](./images/1708525052500.png)

第2种情况：
![](./images/1708525188838.png)

第3种情况：
![](./images/1708525201015.png)

第4种情况：
栈非空，左括号单身。
![](./images/1708525216503.png)

过程图：
![](./images/1708525330675.png)

算法实现：
![](./images/1708525349727.png)

知识整合：
用栈实现括号匹配：
依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检
查是否匹配。
匹配失败情况：
①左括号单身②右括号单身③左右括号不匹配

## 表达式的应用（考试重点：频率不低）

### 中缀，后缀，前缀表达式

**常见的中缀表达式**
![](./images/1708608071106.png)

**波兰数学家的灵感**
一个灵感：可以不用界限符也能无歧义地表达运算顺序
Reverse Polish notation(逆波兰表达式=后缀表达式)
Polish notation(波兰表达式=前缀表达式)
![](./images/1708608294286.png)
第二行：
后缀表达式：
(把 ab+ 当作一个整体)
前缀表达式：
(把 +ab 当作一个整体)

Example：
第二个中缀： a + b - c 
如果先执行b - c 
后缀： a b c - +
（把bc- 当作一个整体）

#### 中缀表达式 转 后缀表达式（手算）：
![](./images/1708608664407.png)

**例子：**
![](./images/1708608912317.png)

**"左优先"原则 很重要，可以保证运算顺序唯一**
![](./images/1708609225826.png)

#### 后缀表达式的计算（手算）
![](./images/1708609440141.png)

**核心特点：**
![](./images/1708609689117.png)

#### 后缀表达式的计算（机算）
用栈实现后缀表达式的计算：
①从左往右扫描下一个元素，直到处理完所有元素
②若扫描到操作数则压入栈，并回到①：否则执行③
③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①

![](./images/1708609730451.png)
==**注意：先出栈的是"右操作数"** #EE3F4D==
若表达式合法，则最后栈中只会留下一个元素，就是最终结果。

![](./images/1708610307662.png)
#### 中缀表达式转前缀表达式（手算）
![](./images/1708610529625.png)**"右优先"原则：只要右边的运算符能先计算，就优先算右边的**


![](./images/1708610642963.png)

#### 前缀表达式的计算
![](./images/1708612573854.png)
操作数是左还是右很重要，影响计算。

知识整合1：
![](./images/1708612692422.png)

#### 中缀表达式 转 后缀表达式 （机算）
（具体看视频）
![](./images/1708612799332.png)
其中，重点是 2 和 3的处理。
乘除 的 优先级 > 加减

**优先度高的先弹出！**

另一种情况：
![](./images/1708613415121.png)

用这个练练手！
![](./images/1708613499625.png)

#### 中缀表达式的计算（用栈实现）
**中缀转后缀** + **后缀表达式求值**
两个算法的结合

用栈实现中缀表达式的计算：
初始化两个栈，**操作数栈**和**运算符栈**
若扫描到操作数，压入操作数栈
若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，**每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈**

（如果不懂，还是看看视频吧）
![](./images/1708613766568.png)
> 为什么要搞怎么复杂，因为CPU很蠢，用这种算法来翻译公式，喂给计算机做。所以这个**算法非常重要！**


**知识整合2：**
![](./images/1708614017277.png)

## 递归！
**递归：函数调用函数的过程。**

函数调用背后的过程
![](./images/1708705371660.png)

IDE调试模式(CLion)
![](./images/1708705646614.png)
### 栈在递归中的应用
适合用“递归”算法解决：可以把原始问题转换为**属性相同**，但**规模较小**的问题

![](./images/1708705762888.png)
Eg.2递归算法求阶乘
![](./images/1708705791695.png)

![](./images/1708705948678.png)
Eg.2递归算法求斐波那契数列

![](./images/1708705980606.png)

知识整合：

![](./images/1708706034114.png)

# 队列应用
## 树的层次遍历
(会在树章节更多学习)
![](./images/1708706286706.png)

遍历过程：
![](./images/1708706473975.png)
## 图的广度优先遍历
(会在图章节更多学习)
![](./images/1708706601489.png)

## 队列在操作系统中的应用
多个进程争抢着使用有限的系统资源时,**FCFS(First Come First Service,
先来先服务)** 是一种常用策略。

例子：
![](./images/1708706664984.png)
![](./images/1708706672588.png)

# 数组和特殊矩阵
## 数组的存储结构
### 一维数组
![](./images/1708871739977.png)
各数组元素大小相同，且物理上连续存放。
数组元素a[i] 的存放地址=LOC+i*sizeof(ElemType) (0≤i<10)
注：除非题目特别说明，否则数组**下标默认从0开始**
**注意审题！易错！**

### 二维数组
![](./images/1708871820239.png)
内存这样线性存储，带来的好处就是可以做**随机存取！**（计算机可以直接算出存放地址）

行优先：
M行N列的二维数组b\[M\]\[N\]中，若按列优先存储，则
b\[i\]\[j\]的存储地址=LOC+(i*N+j)*sizeof(ElemType)

列优先：
M行N列的二维数组b\[M\]\[N\]中，若按列优先存储，则
b\[i\]\[j\]的存储地址=LOC+(j*M+i)*sizeof(ElemType)

## 普通矩阵的存储
![](./images/1708872115266.png)
## 特殊矩阵的存储

### 对称矩阵(线性代数知识)
![](./images/1708872151000.png)

策略：只存储主对角线+下三角区
![](./images/1708872264499.png)
如果要访问的话，只要用这**映射函数**就可以了！（考研最喜欢考察的一个点）
数组下标 -1 的原因是数组下标一开始是0。

![](./images/1708872328981.png)

如果要访问上三角区的呢？利用对称矩阵的性质

![](./images/1708872562110.png)
转换规则：
![](./images/1708872588264.png)
考题例子：
![](./images/1708872614186.png)

### 三角矩阵
![](./images/1708872633135.png)

三角矩阵的压缩存储
下三角：
![](./images/1708872855258.png)

上三角：
![](./images/1708872928690.png)
### 三对角矩阵的压缩存储
当|i-j| > 1 有aij = 0
![](./images/1708873037947.png)

若已知数组下标K，如何得到 i, j？
![](./images/1708873249951.png)

注意对于"刚好" 的东西。

![](./images/1708873290863.png)
### 稀疏矩阵
策略一：
![](./images/1708873383837.png)

策略二：
![](./images/1708873399263.png)

**知识整合：**
![](./images/1708873431202.png)