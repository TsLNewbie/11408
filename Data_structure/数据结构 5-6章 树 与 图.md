---
title: 数据结构 5-6章 树 与 图
category: /小书匠/日记/2024-03
grammar_cjkRuby: true
---

# 第五章 树
## 5.1.1~5.1.2树的定义和基本术语
![](./images/1709997123474.png)

![](./images/1709997298468.png)

树是n(n≥0)个**结点**的有限集合，n=0时，称为**空树**，这是一种特殊情况。在任意一棵**非空树**中应满足：
1)有且仅有一个特定的称为**根**的结点。
2)当n>1时，其余结点可分为m(m>0)个**互不相交的有限集合**T1,T2,...,Tm,其中每个集合本身又是一棵树，并且称为根结点的**子树**。

![](./images/1709997355029.png)

树形的逻辑结构的应用：（应用面很广的）
![](./images/1709999631286.png)

### 结点之间的关系描述
![](./images/1709999683773.png)

什么是祖先结点？
：从一个结点出发，往上走，直到根结点，路径上的所有结点。

什么是子孙结点？
：从一个结点出发，这个结点下面的所有结点（有关联的）。

什么是双亲结点（父节点）？
：从一个结点出发，一个结点的直接前驱。

什么是孩子结点？
：一个结点的后继。

什么是兄弟结点？
：同一个父结点的结点。

什么是堂兄弟结点？(使用频率很低)
：同一层次的结点。

什么是两个结点之间的路径？
：描述路径只能从上往下。（树上的边都是单向边）

什么是路径长度？
：经过几条边。

### 结点、树的属性描述
![](./images/1710000045695.png)

属性：
结点的层次（深度）(默认从1开始）一一从上往下数

结点的高度一一从下往上数

树的高度（深度）一一总共多少层

**结点的度**一一有几个孩子（分支）

**树的度**一一各结点的度的最大值

> 树的结点数 = 结点的总度数 + 1

### 有序树 v.s 无序树
有序树一一逻辑上看，树中结点的各了树从左至右是**有次序的**，不能互换

![](./images/1710000174707.png)

无序树一一逻辑上看，树中结点的各了树从左至右是**无次序的**，可以互换

![](./images/1710000186063.png)

>具体看你用树存什么，是否需要用结点的左右位置反映某些逻辑关系。

### 树 v.s 森林
森林：森林是m(m≥0)棵**互不相交**的树的集合
![](./images/1710000263616.png)
这有**考点！**

知识整合：
![](./images/1710000292651.png)

## 5.1.3树的常考性质：
### 常见考点1： 结点数=总度数+1
结点的度一一结点有几个孩子（分支）

### 常见考点2： 度为m的树、m叉树的区别

![](./images/1710000395327.png)
### 常见考点3： 度为m的树第i层至多有m^(i-1)个结点(i≥1)
m叉树第i层至多有m^(i-1)个结点(i≥1)

![](./images/1710000471007.png)

### 常见考点4：高度为h的m叉树至多有 (m^(h)-1 )/(m-1)个结点。
![](./images/1710000506437.png)
（等比数列公式应该是 a(1-q^(n)) / 1-q)

![](./images/1710000515041.png)
### 常见考点5： 高度为h的m叉树至少有h个结点；高度为h、度为m的树至少有h+m-1个结点。

![](./images/1710000587551.png)
### 常见考点6： 具有n个结点的m叉树的最小高度为log m (n(m-1)+1)
高度最小的情况一一所有结点都有个孩子

![](./images/1710000631811.png)
知识整合：（有🚩的是容易错的）
![](./images/1710000644935.png)

## 5.2.1_1 二叉树的定义以及基本术语

![](./images/1710080715880.png)和度为2不同，度是代表树中最大的分支是2（这个2是必须存在的）。而二叉树代表任何分支都是 <= 2(允许0）;

二叉树有五种形态：
![](./images/1710080753528.png)

### 几个特殊的二叉树(喜欢考察)
满二叉树：(都拉满了（都有两个分支))
![](./images/1710081467214.png)
特点：
①只有最后一层有叶子结点
②**不存在度为1**的结点
③按层序从1开始编号，结点i的左孩了为2i,右孩
了为2i+1:、结点i的父节点为\[i/2\](如果有的话)

完全二叉树：(去掉一部分的满二叉树)
![](./images/1710081480329.png)
特点：
①只有最后两层可能有叶了结点
②**最多只有一个度为1**的结点 ==(考点) #EE3F4D==
③同 满二叉树 ③
④i<=\[n/2\]为分支结点，i>\[n/2\]为叶子结点



注意：以下二叉树并非 **"完全二叉树"**
![](./images/1710081396024.png)


**二叉排序树：** 
一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
**左子树**上所有结点的**关键字**均**小于根结点**的关键字；
**右子树**上所有结点的**关键字**均**大于根结点**的关键字。
左子树和右子树又各是一棵二叉排序树。

二叉排序树可用于元素的排序、搜索

![](./images/1710081705881.png)
**平衡二叉树：**（主打的一个胖）
树上任一结点的左子树和右子树的**深度之差不超过1。**
平衡二叉树能有更高的搜索效率。

![](./images/1710081964630.png)

**知识整合：**
![](./images/1710082006563.png)

## 5.2.1_2二叉树的常考性质
### 常见考点1：设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2,则**n0=n2+1** （选择题中频率很高）
(叶子结点比二分支结点多一个)
假设树中结点总数为n,则
①n=n0+n1+n2 //二叉树只有度为0，1，2的结点，所以都加起来就是n
②n=n1+2n2+1 //树的结点数=总度数+1 （这个是算每个结点的子结点）
验证一下：
![](./images/1710082604544.png)

### 常见考点2：二叉树第i层至多有2^(i-1)个结点（≥1）；m叉树第i层至多有m^(i-1)个结点(i≥1)

![](./images/1710082842735.png)

### 常见考点3：高度为h的二叉树至多有2^h - 1个结点（满二叉树)；高度为h的m叉树至多有个结点(m^(h)-1 )/(m-1)


## 完全二叉树的常考性质

### 常见考点1：具有n个(n>0)结点的完全二叉树的高度h为\[log2(n+1)\]或\[log2(n)\]+1
![](./images/1710082955113.png)

![](./images/1710083122804.png)

### 常见考点2：对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n0、n1和n2

![](./images/1710083048774.png)

**知识整合：**
二叉树：
- **n0=n2 +1**
- 第i层至多有2^(i-1)个结点（≥1）
- 高度为h的二叉树至多有2^(h)-1个结点

完全二义树：
- 具有n个(n>0)结点的完全二叉树的高度h为\[log2(n+1)\]或\[Iog2(n)\]+1
- 对于完全二叉树，可以由的结点数n推出为0、1和2的结点个数为n0、n1和n2(突破点：完全二叉树最多只会有一个度为1的结点)

## 5.2.2 二叉树的存储结构
>从上至下，从左到右的顺序 依次存储 **完全二叉树**

![](./images/1710944322135.png)
![](./images/1710944645771.png)


如果不是完全二叉树的话怎么办：
![](./images/1710944761693.png)


> 顺序存储中：一定要把二叉树的结点编号与完全二叉树对应起来。

![](./images/1710944771348.png)

>**最坏情况：** 高度为h且只有h个结点的单支树（所有结点只有右孩子），也至少需要2^(h)-1个存储单元
结论：二叉树的顺序存储结构，只适合存储完全二叉树


链式存储：
![](./images/1710944909973.png)
实现代码：
![](./images/1710944991335.png)

![](./images/1710945112253.png)

知识整合：
![](./images/1710945206312.png)
![](./images/1710945321133.png)


## 5.3.1 二叉树的先/中/后序遍历

>遍历：按照某种次序把所有结点都访问一遍。

![](./images/1710945427832.png)
> 层次遍历：基于树的层次特性确定的次序规则

![](./images/1710945453055.png)


> 先/中/后续遍历：基于树的递归特性确定的次序规则

![](./images/1710945506445.png)

![](./images/1710945514279.png)
>顺序很重要！
>先序遍历：根左右(NLR)
中序遍历：左根右(LNR)
后序遍历：左右根(LRN)

![](./images/1710945652184.png)
![](./images/1710946129790.png)

![](./images/1710946260446.png)
先序遍历:
![](./images/1710946427755.png)

中序遍历：
![](./images/1710946613857.png)

后序遍历：
![](./images/1710946591519.png)


>照顾一下跨考的同学（比如我）简述一下遍历的事：

![](./images/1710946729727.png)
先序：
![](./images/1710947003832.png)
中序：
![](./images/1710947079242.png)

后序：
![](./images/1710947091290.png)

例子：
![](./images/1710947105456.png)

知识整合：
![](./images/1710947113681.png)
## 5.3.2_2 二叉树的层次遍历

![](./images/1711033047551.png)
![](./images/1711033270701.png)

知识整合：
![](./images/1711033287171.png)

## 5.3.1_3 由遍历序列构造二叉树 *重要考点


不同二叉树的中序遍历序列
![](./images/1712062521310.png)
> 给定一个遍历序列，不代表就知道二叉树形态。

前序遍历序列：
![](./images/1712062645118.png)
后序遍历序列：
![](./images/1712062661558.png)
层次遍历：
![](./images/1712062681536.png)

>结论：若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树

![](./images/1712062710291.png)
>必须有一个中序的才能知道二叉树。

### 前序+中序遍历序列
![](./images/1712062743420.png)
例1：前序+中序遍历序列
![](./images/1712062813856.png)

>BDC也得考虑，但是也是可以用上述的方式推断，只是范围小了。

![](./images/1712062836284.png)答案：
![](./images/1712062882344.png)

例2： 前序 + 中序

![](./images/1712062913601.png)

其中EAF
![](./images/1712062932108.png)

其中：HCBGI
![](./images/1712062948590.png)

其中HC 和 GI
![](./images/1712062957856.png)

### 后序 + 中序 遍历序列
![](./images/1712062992554.png)


例3：后序 + 中序
![](./images/1712063041560.png)

其中EAF:
![](./images/1712063058281.png)

其中HCBGI
![](./images/1712063076393.png)

![](./images/1712063090077.png)

### 层序 + 中序遍历序列
![](./images/1712063140213.png)

例4：层序 + 中序
![](./images/1712063178194.png)


![](./images/1712063188390.png)
![](./images/1712063215254.png)


例5：层序+中序
![](./images/1712063234745.png)
![](./images/1712063247494.png)
![](./images/1712063282700.png)
![](./images/1712063257667.png)


知识整合：
![](./images/1712063299650.png)
>Key.找到**树的根节点**，并根据**中序序列**划分**左右子树**，再找到左右子树根节点.


## 5.3.2_1 线索二叉树的概念 （*难和重要
![](./images/1712063452432.png)

二叉树的中序遍历序列：
![](./images/1712063499366.png)

>序列让二叉树变成了线性表的效果。(唯一前驱和唯一后序)
>而树是有唯一前驱，多个后继。

>只有知道根结点，我们才能知道整个二叉树（为整个二叉树进行遍历）
>但如果只知道一个结点呢？怎么去遍历整个结点？
>如果按照普通二叉树，是没办法只根据一个点进行遍历的。

>二叉树只有**向下**的指针，没有**向上**的指针。


1.如果要找到指定结点p在中序遍历序列的前驱，就得用到q 和 和pre了
![enter description here](./images/1712065871080.png)

### 中序线索二叉树 (左中右)
![](./images/1712065934599.png)
### 存储结构：
![](./images/1712066094656.png)

中序线索二叉树的存储：

>注意Tag值的内容。

![](./images/1712066129595.png)

### 先序线索二叉树 (中左右)
![](./images/1712066451879.png)

存储：
![](./images/1712066537605.png)
### 后序线索二叉树 （左右中）
![](./images/1712066590525.png)
存储：
![](./images/1712066609733.png)


### 三种线索二叉树的对比：

>这部分可能有和选择题有关的内容，有混淆的意思。

![](./images/1712066639711.png)

>中序前驱的意思是：在进行中序遍历后，某个指定的节点前驱是什么？ eg. E 的中序前驱是E
>先序前驱，后序后继同样意思。 eg. E的先序前驱是 G， 后序后继是 B。


知识整合：
![](./images/1712066651547.png)



## 5.3.2_2二叉树的线索化
>代码实现线索化：中序，先序，后序线索化。


用土办法找到中序前驱：

>就是上集提到的，q和Pre指针的利用。

![](./images/1712066912157.png)

### 中序线索化
![](./images/1712067039377.png)

![](./images/1712067421797.png)
最后存储效果：
![](./images/1712067988186.png)
王道教材书：
![](./images/1712068007988.png)


### 先序线索化
![](./images/1712068232888.png)

>在第三个的时候，也就是遍历到 D 位置的时候， D的左子树就已经指向 pre ，也就是B位置了，根据代码内容，就会爱滴魔力转圈圈了

所以修改调整：加一个判断，和 ltag = 1 有关系。
![](./images/1712068419678.png)

整体代码效果：
![](./images/1712068477218.png)


王道教材Style
![](./images/1712068505826.png)

### 后序线索化

>后序线索化不存在转圈问题。

![](./images/1712068527884.png)

知识整合：
![](./images/1712068578586.png)


## 5.3.2_3 在线索二叉树中找前驱后继
![](./images/1712068689812.png)

### 中序线索二叉树找 中序后继
![](./images/1712068807069.png)

代码实现：
![](./images/1712069017981.png)
### 中序线索二叉树找 中序前驱
![](./images/1712069215357.png)

代码实现：
![](./images/1712069254967.png)

### 先序线索二叉树找 先序后继
![](./images/1712069309479.png)

>试试做一个？
>（留个代码位）

### 先序线索二叉树找 先序前驱

![](./images/1712069393765.png)
>找不到哇！


可以搞个三插列表：能找到父节点那种：
![](./images/1712069521364.png)
>3 的情况就是找最后一个的叶子节点。

### 后序线索二叉树找后序前驱
![](./images/1712069642019.png)

>留个给自己写代码的空间:
>

### 后序线索二叉树找后序后继
![](./images/1712069902187.png)

>做不到啊！

三叉链表，可以知道父节点的情况下：
![](./images/1712069934267.png)

>3情况是找到最下面的叶子节点。

知识整合:
![](./images/1712069964383.png)


>根据现场题目进行推断吧，理解才是重要的。

![](./images/1712070086446.png)

## 5.4.1 树的存储结构
![](./images/1712070207792.png)

2024/4/3

树的逻辑结构：
![](./images/1712136591335.png)

回顾：二叉树的顺序存储
![](./images/1712136987898.png)
树的顺序存储。
![](./images/1712137115612.png)


![](./images/1712137173378.png)
### 树的存储1：双亲表示法（顺序存储）
![](./images/1712137251721.png)

双亲表示法存储"森林"
![](./images/1712137343916.png)
双亲表示法的优缺点

>找 双亲（父节点）很方便
>但找孩子不方便

![](./images/1712137381894.png)

### 树的存储2：孩子表示法(顺序+链式存储)

>孩子表示法：用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针.

![](./images/1712137455691.png)

![](./images/1712137546707.png)
拓展：孩子表示法存储"森林"
![](./images/1712137656198.png)

孩子表示法的优缺点：

>优点：找孩子很方便
缺点：找双亲（父节点）不方便，只能遍历每个链表

![](./images/1712137677552.png)
>比如说客服系统，普通话请按1，粤语请按2 ....


### 树的存储3：孩子兄弟表示法(链式存储)

>树的孩子兄弟表示法，与二叉树类似，采用二叉链表实现。每个结点内保存数据元素和两个指针，但两个指针的含义与二叉树结点不同。

![](./images/1712137740571.png)

存储效果：
![](./images/1712139453081.png)

拓展：孩子兄弟表示法存储"森林"
![](./images/1712139579366.png)

知识整合：
![](./images/1712139669447.png)

## 5.4.2 树、森林与二叉树的转换
![](./images/1712139841640.png)

### 树 转 二叉树

> 树→二叉树转换技巧：
①先在二叉树中，画·个根节点。
②按“树的层序”依次处理每个结点。

>**兄弟冰糖葫芦法！**

![](./images/1712139887296.png)
![](./images/1712148282727.png)


### 森林 转 二叉树

>和树 -> 二叉树 差不多，但要看森林每个根节点当作平级兄弟关系。

![](./images/1712148301399.png)

![](./images/1712148456445.png)
>只有平级兄弟关系才要串葫芦，如果是另一个父节点的就别管了。

### 二叉树 转 树

>还是和葫芦离不开了。

![](./images/1712148694887.png)
![](./images/1712148773260.png)
### 二叉树 转 森林

> 和 二叉树 -> 树 几乎一样，但就是根节点看作兄弟关系。

![](./images/1712148861869.png)
![](./images/1712148896398.png)

知识整合：
![](./images/1712148909846.png)

## 5.4.3 树和森林的遍历
![](./images/1712149139768.png)

>树是一种**递归定义**的数据结构

### 树的先根遍历
![](./images/1712149587362.png)

### 树的后根遍历
![](./images/1712149770318.png)

### 树的层次遍历
![](./images/1712149860907.png)


### 森林的先序遍历
![](./images/1712150011380.png)

>可以先转成二叉树，然后再先序遍历。

![](./images/1712150771398.png)

### 森林的中序遍历
![](./images/1712150801074.png)

>可以先转成二叉树，然后再中序遍历。

![](./images/1712150826836.png)

知识整合：
![](./images/1712150844626.png)

## 5.5.1 哈夫曼树
![](./images/1712151074391.png)

### 带权路径长度
![](./images/1712151088149.png)

### 哈夫曼树

>中间两个都是哈夫曼树！
>在含有n个**带权叶结点的二叉树中**，其中带权路径长度(WPL)**最小**的二叉树称为哈夫曼树，也称**最优二叉树**.

>例子：根据例子中 1 , 3 ,4,5 叶子结点 构造的 二叉树其中WPL是最小的。

![](./images/1712151208123.png)
### 哈夫曼树的构造
![](./images/1712151321376.png)
另外一种哈夫曼树构造：
![](./images/1712151563148.png)

### 哈夫曼编码

假设在考试的时候（都是选择题），小渣要传信息给老渣。
![](./images/1712151623808.png)

稍微调整后，WPL就大幅降低了。
![](./images/1712151881296.png)
但是也需要避免有歧义。
![](./images/1712151925339.png)

![](./images/1712152060272.png)
英语字母频次
![](./images/1712152198772.png)

> 试试？

知识整合：
![](./images/1712152218740.png)

## 5.5.2_1并查集
![](./images/1712152299689.png)


漏网之鱼：逻辑结构--“集合”
![](./images/1712152360914.png)
### 逻辑结构- 集合

![](./images/1712152386978.png)

![](./images/1712152412894.png)

>思路： A和H不是同一个集合
>而A和E是属于同一个集合。

### 回顾：森林

>森林就是**互不相交**的

![](./images/1712152494443.png)

>用互不相交的树，表示多个"集合"
>
>如何“查”到一个元素到底属于哪一个集合？ (查)
一一从指定元素出发，一路向北，找到**根节点**
如何判断两个元素是否属于同一个集合？ 
一一分别查到两个**元素的根**，判断根节点是否相同即可
如何把两个集合“并”为一个集合？（并）
一一让一棵树成为另一棵树的子树即可


### 回忆：树的存储——双亲表示法
![](./images/1712152739253.png)

>用双亲表示法，在并和查这方面都很方便，所以就用他了。

### "并查集"的存储结构
![](./images/1712152950551.png)


### "并查集"的基本操作
![](./images/1712153206019.png)
### "并查集"的代码实现
初始化
![](./images/1712153344304.png)

并、查
![](./images/1712153407985.png)
举个例，A和C "并" 在一起。 那么就是 把 C的**S[]**，变成 A的 **数组下标**。
如果不是根，那就先找到根，然后再并即可。
图示：
![](./images/1712153532037.png)

### 时间复杂度分析：
![](./images/1712242385751.png)

>优化思路：在每次Union操作构建树的时候，尽可能让树不长高高
**①用根节点的绝对值表示树的结点总数**
**②Union操作，让小树合并到大树**

![](./images/1712242523893.png)

![](./images/1712242540555.png)![](./images/1712242715140.png)

![](./images/1712242725036.png)
![](./images/1712242733155.png)

>合并完就把S[]的数量+在一起。

![](./images/1712242768858.png)

知识整合：
![](./images/1712242789909.png)
## 5.5.2_2并查集的进一步优化

# 第六章 图
## 6.1.1图的基本概念