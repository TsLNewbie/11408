---
title: 第7-8章 查找和排序
category: /小书匠/日记/2024-06
grammar_cjkRuby: true
---
# 第 7 章 查找
[toc!]
## 7.1 查找的基本概念

**查找**一一一在数据集合中寻找满足某种条件的数据元素的过程称为查找
**查找表**(查找结构)一一一用于查找的数据集合称为查找表，它由**同一类型**的**数据元素**（或记录）组成
**关键字**一一一数据元素中**唯一标识该元素的某个数据项的值**，使用基于关键字的查找，查找结果应该是唯一的。

![](./images/1717420619729.png)
![](./images/1717420640493.png)

对查找表的常见操作

![](./images/1717420668262.png)
### 查找算法的评价指标

查找长度一在查找运算中，需要**对比**关键字的**次数**称为查找长度
**平均查找长度(ASL,Average Search Length)** 一**所有**查找过程中进行关键字的比较次数的平均值

![](./images/1717420723775.png)

![](./images/1717420841661.png)

![](./images/1717420853305.png)
知识整合：
![](./images/1717420866112.png)

## 7.2 顺序，折版，分块查找

### 7.2.1 顺序查找

#### 算法思想
顺序查找，又叫“线性查找”，通常用于线性表。
算法思想：从头到 jio挨个找（或者反过来也OK)

![](./images/1717421153378.png)
### 算法实现

![](./images/1717421224104.png)
![](./images/1717421391564.png)

（哨兵）—— 数据从下标1开始存。

![](./images/1717421417839.png)
从最后开始。

![](./images/1717421474566.png)


>减少了内存调用开销！！


![](./images/1717421506205.png)

![](./images/1717421498191.png)
![](./images/1717421556760.png)

### 算法优化

![](./images/1717421996039.png)

![](./images/1717421672621.png)

![](./images/1717421807305.png)
>（被查概率不相等）
>对于查找失败的问题还是很明显的。而上面的顺序查找成功和查找失败都很平均。

![](./images/1717421820325.png)

知识整合：

![](./images/1717421834444.png)

### 7.2.2 折半查找（考察频率高）

### 算法思想

>折半查找，又称“二分查找”，仅适用于**有序**的**顺序表。**

![](./images/1717422509004.png)

![](./images/1717422555109.png)

注：只有在[low,high]之间才有可能找到目标关键字

![](./images/1717422566587.png)

![](./images/1717422585796.png)

![](./images/1717422597969.png)
如果查找失败：

![](./images/1717422674173.png)

![](./images/1717422680598.png)

![](./images/1717422694469.png)

![](./images/1717422703369.png)


![](./images/1717422709882.png)

### 算法实现


![](./images/1717422804092.png)


### 查找判定树

![](./images/1717424379291.png)

![](./images/1717424406567.png)

![](./images/1717424426711.png)

![](./images/1717424434681.png)

![](./images/1717424450180.png)


![](./images/1717424460356.png)

![](./images/1717424534924.png)


![](./images/1717424521938.png)


![](./images/1717424550895.png)

![](./images/1717424566310.png)

![](./images/1717424725843.png)


>平衡二叉排序树！
>失败结点：成功结点的空指针。

![](./images/1717424763129.png)

![](./images/1717424781206.png)
![](./images/1717424847173.png)




### 折半查找效率

![](./images/1717424227450.png)

![](./images/1717424234392.png)


![](./images/1717424242778.png)

![](./images/1717424250271.png)


![](./images/1717424264048.png)
知识整合：

![](./images/1717424865063.png)
### 拓展思考

![](./images/1717424928476.png)
>如果向上取值

![](./images/1717424990270.png)

![](./images/1717425010800.png)


![](./images/1717425023727.png)


### 7.2.3 分块查找

分块区间：也就是有序的进行分块

![](./images/1717475441939.png)
![](./images/1717475497389.png)


实际查找的效果：

![](./images/1717475538099.png)
30 >= 22，那么22肯定在这个分块里面。

![](./images/1717475544224.png)


在 索引在 8 的位置， 30 和 29不匹配，所以会到下一个分块，结果就是超出范围了。

![](./images/1717475581934.png)

>分块查找，又称**索引顺序查找**，算法过程如下：
①在**索引表**中确定待查记录所属的分块（可顺序、可折半）
②在块内**顺序查找**

### 用折半查找查索引

![](./images/1717475664268.png)
>mid是30，匹配了，然后读取里面，然后就是 顺序查找，最终获得 30 是对的。

![](./images/1717475671144.png)


![](./images/1717475700508.png)
>进行折半查找。

![](./images/1717475710833.png)

![](./images/1717475800505.png)
>如果按照折半查找，会出问题，所以要改改： 当 low>high，low 所指分块中查找。

![](./images/1717475807978.png)

![](./images/1717475864655.png)
查找失败的例子：

![](./images/1717476022260.png)



### 查找效率分析 ASL


![](./images/1717476028094.png)
![](./images/1717476215522.png)



![](./images/1717476565879.png)

![](./images/1717476045291.png)

![](./images/1717476052356.png)
![](./images/1717476298159.png)


知识整合：
![](./images/1717476625728.png)

![](./images/1717476636992.png)

## 7.3 树形查找

### 7.3.1 二叉排序树 BST
#### 定义

二叉排序树 ——> 二叉查找树（BST,Binary Search Tree)

一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
左子树上所有结点的关键字均**小于** **根结点**的关键字：
右子树上所有结点的关键字均**大于** **根结点**的关键字。
左子树和右子树又各是一棵二叉排序树。

>**中序遍历** 可以得到一个递增的有序序列

![](./images/1717476928888.png)
#### 查找

![](./images/1717476978615.png)


![](./images/1717477020779.png)
查找失败：

![](./images/1717477036438.png)


>递归实现

![](./images/1717477088291.png)
#### 插入

![](./images/1717477193509.png)
> 二叉树不允许存在两个 **关键字** 相同的结点。

#### 构造

![](./images/1717477219234.png)
![](./images/1717477236613.png)


#### 删除
先搜索找到目标结点：
①若被删除结点z是**叶结点**，则直接删除，不会破坏二叉排序树的性质。

![](./images/1717477292174.png)
②若结点z只有一棵左子树或右子树，则让z的**子树**成为z**父结点的子树**，替代z的位置。

![](./images/1717477407495.png)

![](./images/1717477412988.png)
③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z,然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。

>第一种思路，直接后继

![](./images/1717477437662.png)
![](./images/1717477486568.png)


>第二种思路，直接前驱。


![](./images/1717477552836.png)
![](./images/1717477560961.png)

>查找长度：**对比关键字的次数**。

#### 查找效率分析 ASL

![](./images/1717477581502.png)

>平衡二叉树：任何结点 左子树 和 右子树 之差 <= 1。

![](./images/1717477670083.png)
>查找失败

![](./images/1717477718933.png)


#### 知识整合：
![](./images/1717477744198.png)

### 7.3.2 平衡二叉树 AVL

#### 定义
平衡二叉树(Balanced Binary Tree),简称平衡树(AVL树)一一树上任一结点的左子树和右子树的高度之差不超过1。
**结点的平衡因子**=左子树高-右子树高。


![](./images/1717477876701.png)



#### 插入操作

![](./images/1717477976836.png)
![](./images/1717477986236.png)

#### 插入新结点后如何调整“不平衡”问题 (最关键)

![](./images/1717478086400.png)
##### LL（左孩子的左子树）

![](./images/1717478095415.png)
>1)L平衡旋转（右单旋转）。由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，
>需要一次向右的旋转操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

##### RR（右孩子的右子树）

![](./images/1717478469517.png)

>2)RR平衡旋转（左单旋转）。由于在结点A的右孩子(R)的右子树(R)上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需
>要一次向左的旋转操作。将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

##### 代码思路

![](./images/1717478528068.png)
##### LR 左孩子的右子树

![](./images/1717478974599.png)
>3)LR平衡旋转（先左后右双旋转）。由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，
>需要进行两次旋转操作，**先左旋转后右旋转。** 先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置
>先让C 左旋， 然后 A 右选。

> C **左旋**顶替 B ，然后 C 再**右旋**顶替 A

![](./images/1717478989806.png)

![](./images/1717479189870.png)


###### RL 右孩子的左子树

![](./images/1717479229765.png)

>同样，C **右选**顶替 B ，然后 C 再**左旋**顶替 A


![](./images/1717479263545.png)

![](./images/1717479361958.png)
##### 汇总：

![](./images/1717479376364.png)
>LL ——> 左孩子 右旋
RR ——> 右孩子 左旋
LR ——> 左孩子的右孩子 左旋右旋
RL ——> 右孩子的左孩子 右旋左旋


#### 拓展探讨 / 练习

![](./images/1717479529709.png)

![](./images/1717479592661.png)
![](./images/1717479604957.png)

问题解答：
![](./images/1717479612673.png)
练习1：

![](./images/1717479669801.png)

![](./images/1717479677696.png)
练习2：

![](./images/1717479705543.png)
![](./images/1717479757108.png)

![](./images/1717479794100.png)
练习3：

![](./images/1717479854640.png)
![](./images/1717479930832.png)
#### 查找效率分析

![](./images/1717479992845.png)
![](./images/1717480085755.png)

#### 知识整合

![](./images/1717480023653.png)

#### 删除（7.3.2_2)

>平衡二叉树的特性： 左<中<右

![](./images/1717480446319.png)
>平衡二叉树的删除操作具体步骤：
①删除结点（方法同“二叉排序树”）
②一路向北找到 **最小不平衡子树**，找不到就完结撒花（不需要调整）
③找最小不平衡子树下，“**个头”最高**的儿子、孙子
④根据孙子的位置，调整平衡(LL/RR/R/RL)
⑤如果不平衡向上传导，继续②


偷看：二叉排序树的知识整合。

![](./images/1717481123513.png)

##### AVL树删除操作 —— 例1 无问题

![](./images/1717481286027.png)

![](./images/1717481340564.png)

##### AVL树删除操作 —— 例2 RR

![](./images/1717481372707.png)

![](./images/1717481380341.png)

![](./images/1717481443202.png)
>"个头" 并非看 关键字的量，而是高度（深度）

![](./images/1717481458834.png)

![](./images/1717481597517.png)

![](./images/1717481609997.png)

##### AVL树删除操作 —— 例3 RL

![](./images/1717481914948.png)

![](./images/1717481927180.png)

![](./images/1717481933251.png)

![](./images/1717481941254.png)
![](./images/1717482026458.png)


![](./images/1717482036981.png)

##### AVL树删除操作 —— 例4 不平衡向上传导

![](./images/1717482082238.png)
![](./images/1717482109084.png)

>不平衡向上传导

![](./images/1717482118768.png)
![](./images/1717482157619.png)


![](./images/1717482176329.png)

![](./images/1717482183092.png)

这样就完成了。

##### AVL树删除操作 —— 例5 删除的结点有两颗子树(选前驱)

![](./images/1717482238002.png)
>前驱：左孩子一路往右
>后继：右孩子一路往左

![](./images/1717482265257.png)

![](./images/1717482273763.png)
![](./images/1717482359572.png)


情况RR：右子树左转。 == 儿子左转
![](./images/1717482366641.png)
![](./images/1717482410525.png)

##### AVL树删除操作 —— 例6 删除的结点有两颗子树(选后继)

![](./images/1717482429750.png)
![](./images/1717482484640.png)


![](./images/1717482490604.png)
>两个选择，85 和 95 个头都是最高的孙子，两者都可以选。

![](./images/1717482514111.png)

![](./images/1717482547597.png)

![](./images/1717482568519.png)

![](./images/1717482573653.png)

![](./images/1717482580285.png)
>不可能考这种有多处理方式的题目。

知识整合：

![](./images/1717482619276.png)
>平衡二叉树的删除操作 比较少考

### 7.3.3 红黑树 RB T

![](./images/1717482962692.png)

> BST ——> AVL ——> RBT

![](./images/1717483009147.png)

![](./images/1717483033142.png)

#### 定义：

> 红黑树 = 二叉排序树 ——> 左 <= 根 <= 右

![](./images/1717483418247.png)
>1.结点要么红，要么黑。
>2.根一定黑
>3.叶也一定黑
>4.红不相连
>5.每条路上黑的量相同。

>左根右，根叶黑，不相红，黑路同。

![](./images/1717483655935.png)


![](./images/1717483668053.png)
![](./images/1717483897402.png)

![](./images/1717483906275.png)
这个才是符合的。

![](./images/1717483954055.png)
一种可能的出题思路。

![](./images/1717483972420.png)
>结点的黑高：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数。

![](./images/1717484001132.png)

![](./images/1717484037096.png)

>红黑树的查找 == BST,AVL 查找

![](./images/1717484085456.png)

#### 插入：

>AVL 插入 操作 回顾： 
其实 红黑树 的插入 和 AVL 插入 有异曲同工之妙。

![](./images/1717485572723.png)

>左根右，根叶黑，不相红，黑路同。！！！

![](./images/1717484159916.png)
> 非根，红  ——> 目的：保证黑路同
> 

![](./images/1717485647317.png)

![](./images/1717485730603.png)
>染色： 换色。

![](./images/1717486007541.png)
![](./images/1717486021816.png)


![](./images/1717486226126.png)

![](./images/1717486257362.png)


![](./images/1717486285437.png)

![](./images/1717486315206.png)

![](./images/1717486324771.png)
![](./images/1717486336335.png)



![](./images/1717486390379.png)

![](./images/1717486408644.png)

![](./images/1717486418060.png)

![](./images/1717486472866.png)

![](./images/1717486483515.png)

![](./images/1717486492160.png)

![](./images/1717486504556.png)
![](./images/1717486515532.png)


![](./images/1717486531363.png)

![](./images/1717486543637.png)
![](./images/1717486557351.png)

>数据结构是应用科学，不是理论科学。如果出现两个相同的数值，就按照个人意愿来决定。

![](./images/1717486572684.png)

![](./images/1717486585379.png)

![](./images/1717486596737.png)

![](./images/1717486605730.png)




>非根的时候，插入的过程，最主要是有没有违反 不相红 、 不红红。

>[Red/Black Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)

##### 知识整合：

![](./images/1717486624181.png)
![](./images/1717487546557.png)



#### 删除：

![](./images/1717487837565.png)
>红黑树删除太麻烦，不考。

>红黑树 主要考察： 定义和性质
## 7.4 B树 和 B+ 树

### 7.4.1 B树

>排名前三的难点：B树

>考试当中，考察的是B树的 性质，插入删除查找的操作，代码不要求掌握。


回顾：二叉查找树（BST)

![](./images/1717502858649.png)
5叉查找树：

![](./images/1717502902663.png)
>结点内关键字有序.

查找目标：

![](./images/1717506351378.png)

![](./images/1717506371781.png)
>每个结点如果关键字太多，其实是可以搞 折半查找（但方便理解，用顺序查找）


查找目标： 41

![](./images/1717506452013.png)
>失败结点指向的就是NULL

![](./images/1717506503660.png)
>根节点没办法啊。

![](./images/1717506585727.png)


![](./images/1717506644837.png)
#### B树！

>保证以上两个策略：
>m叉查找树中，规定除了根节点外，任何结点至少有[m/2]个分叉，即至少含有[m/2]一1个关键字（向上取整）
>m叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同，

![](./images/1717506701159.png)

![](./images/1717506842368.png)
![](./images/1717506997066.png)

> P = 结点当中的指针 = n +1
>K = 结点当中的关键字 = n （关键字是有序的）

>本次 平衡 是绝对平衡（高度一样）

#### m阶B树的核心特性：：**(重点)**

![](./images/1717507075129.png)
#### B树的高度

![](./images/1717507173650.png)
![](./images/1717507316699.png)

(m-1) = 关键字 ，后续是分叉。

![](./images/1717507358940.png)

另一个角度来推算。

![](./images/1717507454204.png)


#### 知识整合：

![](./images/1717507684647.png)
>B树 = Balance tree （并非官方解释）




### 7.4.1_2 B树的插入和删除


#### 插入

![](./images/1717507826784.png)

![](./images/1717507836146.png)
>超了！超了！

![](./images/1717507842650.png)
>接下来就得分裂了！

![](./images/1717507868856.png)
插入 90 元素：

![](./images/1717507927225.png)

![](./images/1717507964605.png)

在插入99和88之后，又一次发生了：

![](./images/1717507988629.png)
>左边保留，中间上去，右边开个新的。

![](./images/1717508038716.png)

>再插入 83,87,70


![](./images/1717508086677.png)

![](./images/1717508118048.png)
>接下来再插入三个元素： 92,93,94

![](./images/1717508158370.png)
![](./images/1717508171717.png)

>之后再插入： 73,74,75

![](./images/1717508194792.png)

![](./images/1717508203994.png)


![](./images/1717508230865.png)

![](./images/1717508255172.png)
#### 插入的核心要求：

![](./images/1717508264859.png)

#### 删除

![](./images/1717508310404.png)
>第一个删除的元素：60

![](./images/1717508347786.png)
>第二次删除，80（根结点）

![](./images/1717508384481.png)
>把非终端结点的删除操作，变成了终端结点的删除操作（这种删除和前面的平衡二叉树很相似）

![](./images/1717508491599.png)

![](./images/1717508501344.png)

![](./images/1717508511570.png)



>关键字低于下限的情况，那么就删除关键字： 38。

>情况1：兄弟够借
>向兄弟结点借一个。但是借的过程需要通过父结点。

![](./images/1717508585939.png)

![](./images/1717508626311.png)
>说白了，当右兄弟很宽裕时，用当前结点的**后继**、**后继的后继**来填补空缺
>这个例子：25的后继 = 49 ，后继的后继 = 70

>继续删除，删除的是90：

![](./images/1717508767307.png)
>左兄弟，结点的前驱 ，前驱的前驱来填补。
>例子：92的前驱 = 88 , 前驱的前驱  = 87

![](./images/1717508842591.png)
>情况2：兄弟不够借：
>兄弟也没钱了，这时候就是进行合并。

![](./images/1717508865050.png)


![](./images/1717508896338.png)

![](./images/1717508908483.png)

![](./images/1717508935798.png)
>此时 73 的位置的结点也出现问题，也出现了兄弟不够借的情况，所以还需要再合并。

![](./images/1717508999973.png)

![](./images/1717509020613.png)

#### 知识整合：

![](./images/1717509079091.png)

### 7.4.2 B+树

>把关键字想象成学号，记录就是该学生的各种信息。

![](./images/1717509160489.png)

对比：分块查找

![](./images/1717509690184.png)

![](./images/1717509707498.png)
> B+ 树 的叶子结点不是 Null的结点。

>重点: 结点的子树个数 == 关键字个数
>（B树是关键字 = 结点 - 1）

![](./images/1717509743643.png)

>非叶根结点至少有两棵子树。

![](./images/1717516463420.png)
![](./images/1717516504974.png)

>查找要找到**叶子结点**的位置才能知道 9 号的记录。


![](./images/1717516540451.png)

![](./images/1717516548739.png)
>B+树中，无论查找成功与否，最终一定都要走到最下面一层结点

>对比B树的查找：：

![](./images/1717516564344.png)

>除了根结点往下查找，还能顺序查找
>1>3>6>8>9 查到了。


![](./images/1717516670819.png)

![](./images/1717516702540.png)


> B+树(跟分块有点相似的) 和 B树 的对比是比较常见的。



m阶B+树：
1)结点中的n个关键字对应n棵子树

2)根节点的关键字数n∈[1，m]
其他结点的关键字数n∈[[m/2],m] （向上取整）

3)在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中

4)在B+树中，叶结点包含信息，所有**非叶结点**仅起**索引作用**，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。

m阶B树：
1)结点中的n个关键字对应n+1棵子树

2)根节点的关键字数n∈[1，m-1]
其他结点的关键字数n∈[[m/2]-1,m-1] (向上取整)

3)在B树中，各结点中包含的关键字是不重复的

4)B树的结点中都包含了关键字对应的记录的存储地址


#### 拓展内容：
![](./images/1717517160881.png)
>操作系统 读取硬盘的过程就是 B+树 的行为。
>B+树就好处就是，上面的块不需要预留空间给这么多。

#### 知识整合：

![](./images/1717517179094.png)
>B+树不会考很难，通常考这种内容）


## 7.5 散列表

### 7.5.1 散列表的基本概念

![](./images/1717555087363.png)

![](./images/1717555111884.png)
>key % 13 取余。

#### 冲突、同义词

![](./images/1717555201133.png)

![](./images/1717555251276.png)

#### 解决冲突的方法：

![](./images/1717555278538.png)
>拉链法：把所有“同义词”存储在一个链表中

![](./images/1717555319834.png)

> 开放定址法：如果发生“冲突”，就给新元素找另一个空闲位置。

![](./images/1717555342119.png)
#### 知识整合：

![](./images/1717555413595.png)



### 7.5.2 散列函数的构造

![](./images/1717555463327.png)
>考试最常考，也是现实最常用的： 除留余数法


![](./images/1717555635895.png)
#### 除留余数法（重点）

>使用场景： 较为通用，只要关键字是整数即可。

![](./images/1717555655555.png)


![](./images/1717556107207.png)
#### 直接定址法

>适用场景：关键字分布基本连续

![](./images/1717556243112.png)
#### 数字分析法

>适用场景： 关键字集合已知，且关键字的某几个数码位分布均匀。

![](./images/1717556277322.png)

#### 平方取中法

>适用场景：关键字的每位取值都不够均匀

![](./images/1717556294775.png)

#### 知识整合：

![](./images/1717556307644.png)


### 7.5.3 处理冲突的方法_拉链法

![](./images/1717556358402.png)
>Tips: 散列表通常不考代码，着重于掌握手算分析方法。


#### 插入

>考试：默认头插法。

![](./images/1717567683132.png)

![](./images/1717567767768.png)

![](./images/1717567776560.png)

![](./images/1717567785993.png)

![](./images/1717567793110.png)


#### 查找

![](./images/1717567842618.png)

![](./images/1717567853597.png)

![](./images/1717567866648.png)

![](./images/1717567877734.png)

####  删除

![](./images/1717567903818.png)

![](./images/1717567982508.png)
![](./images/1717567992276.png)

![](./images/1717567999362.png)
![](./images/1717568009002.png)


#### 知识整合：


![](./images/1717568029859.png)
#### 拓展优化：

![](./images/1717568055221.png)


>新元素用“头插法”插入链表，每个链表是**乱序**的。
新元素插入链表时，若能保持链表**有序**，可以略微提高“查找”效率。


![](./images/1717568072402.png)



### 7.5.3_2 处理冲突的方法_开放定址法

![](./images/1717568127209.png)

#### 开放定址法的原理


![](./images/1717568160422.png)

>为什么叫“开放定址” —— 一个散列地址，即对**同义词开放**，也对**非同义词开放**。
>同义词就是 ： 同个地址的关键字

![](./images/1717568263323.png)

![](./images/1717568406338.png)


> **偏移量的探测序列** 四种（序列各不相同）


#### 线性探测法

![](./images/1717568579815.png)


#### 平方探测法（二次探测法）

![](./images/1717568726721.png)

#### 双散列法

![](./images/1717568806045.png)
>hash2(第二个散列函数)

#### 伪随机序列法

>程序员来设计伪随机序列：

![](./images/1717568924037.png)

#### 删除操作

![](./images/1717568981828.png)
> 先查找，然后删除。

#### 特别注意：关于删除操作

![](./images/1717569037576.png)

![](./images/1717569053157.png)

![](./images/1717569065848.png)
> 进行逻辑删除，不能进行物理删除。

![](./images/1717569091781.png)

![](./images/1717569145859.png)

#### 知识整合：

![](./images/1717569174892.png)

#### 拓展： 线性探测法的“探测覆盖率”

![](./images/1717569201917.png)
#### 拓展： 平方探测法的“探测覆盖率”

![](./images/1717569225279.png)
#### 拓展： 双散列法的“探测覆盖率”

![](./images/1717569250358.png)


#### 拓展： 伪随机序列法的“探测覆盖率”

![](./images/1717569273485.png)
# 第 八 章 排序 （最后一章）

>[排序算法（七大经典排序算法）-CSDN博客](https://blog.csdn.net/ypt523/article/details/80462873)

## 8.1 排序的基本概念

> 排序(Sort)，就是重新排列表中的元素，使表中的元素满足**按关键字有序**的过程。

![](./images/1717592971621.png)

![](./images/1717592982388.png)
评价指标：

![](./images/1717592995754.png)


![](./images/1717593010652.png)

排序算法的分类：

![](./images/1717593102720.png)

### 知识整合：

![](./images/1717593293199.png)
>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

## 8.2 插入排序（插入和希尔）

### 插入排序

>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。


![](./images/1717593574545.png)

![](./images/1717593588412.png)


![](./images/1717593599758.png)


![](./images/1717593626828.png)

。。。。

![](./images/1717593662404.png)

>其实就是顺序，然后和前面每个进行对比，挪位置。

#### 算法实现（重点）

![](./images/1717593675018.png)
>思路：如果 A[5] < A[4] ，就会先保存 A[5]的数据，然后从A[4] 开始 ，如果A[4]大于 temp，挪位，接下来A[3]，挪位，A[2] ，发现

#### 算法实现（带哨兵）


![](./images/1717593954880.png)
>不一样的是，0是没有东西的，然后上述的temp 就作为 A[0] 了。

![](./images/1717594057267.png)
>优点，不需要判断 j >= 0

#### 算法效率分析

![](./images/1717594113734.png)

![](./images/1717594144033.png)

![](./images/1717594153077.png)

![](./images/1717594167894.png)

>空间复杂度：O(1)
>最好的情况：O(n) 
>最坏的情况：O(n^2)
>平均的时间复杂度： O(n^2)
>算法稳定性：稳定

#### 优化——折半插入排序

![](./images/1717594290550.png)
>A[0] 保存数据。

![](./images/1717594298248.png)

>然后就进行**折半查找**

![](./images/1717594318905.png)

![](./images/1717594335078.png)


>当low > high ，就该停止了。

![](./images/1717594348298.png)

![](./images/1717594362259.png)

![](./images/1717594368032.png)
>当A[mid] == A[0] ，为了保证算法“稳定性”，应该继续在mid 所指位置右边寻找插入位置。

![](./images/1717594477356.png)

![](./images/1717594498531.png)

![](./images/1717594508566.png)

![](./images/1717594519145.png)



![](./images/1717594535089.png)
>这种情况还是会 low >high 的情况。


![](./images/1717594564658.png)
优化后的代码：

![](./images/1717594579736.png)

对链表进行插入排序

![](./images/1717594607667.png)

#### 知识整合：

![](./images/1717594621563.png)

### 希尔排序 Shell Sort

>希尔排序：先追求表中元素**部分有序**，再逐渐逼近**全局有序**。 （先部分，后全局）

![](./images/1717594828380.png)

![](./images/1717594868101.png)
>相距距离为4的当作同个数组先。


![](./images/1717594897530.png)

![](./images/1717594968435.png)

![](./images/1717595015930.png)
>第二趟是之前第一趟的基础上 除以2；

![](./images/1717595025595.png)

![](./images/1717595049788.png)

![](./images/1717595076603.png)

![](./images/1717595085129.png)

![](./images/1717595095075.png)
>最后进行“直接插入排序”即可。

![](./images/1717595102947.png)

![](./images/1717595128790.png)



>如果增量是奇数呢：：


![](./images/1717595197493.png)

![](./images/1717595205942.png)

![](./images/1717595216357.png)


![](./images/1717595229700.png)

![](./images/1717595237513.png)

![](./images/1717595245613.png)


![](./images/1717595252438.png)


![](./images/1717595264763.png)
>考试中可能遇到各种增量。


#### 算法实现

![](./images/1717595291988.png)
> d = 增量，第一趟 （元素个数 / 2) = 4
> i = d + 1 (指向第一个子表的第二个位置（判断完就可以了)

![](./images/1717595575221.png)
> d = 2的情况

![](./images/1717595763161.png)

>如果按照直接插入排序，就应该会处理 49 , 76 。但其实根据代码的情况，应该是处理下一个 （也就是4的index的位置）。因为代码是 i ++.

>在我的想法，我认为这个应该叫隔着来排序。

最后情况：

![](./images/1717595832601.png)

>最后一轮，直接插入排序了。

![](./images/1717595854604.png)


#### 算法性能分析


![](./images/1717595877823.png)

![](./images/1717595890230.png)

#### 知识整合：


![](./images/1717595911763.png)



## 8.3 交换排序（冒泡和快速）

>基于“交换”的排序：根据序列中两个元素关键字的**比较结果**来对换这两个记录在序列中的位置

### 冒泡排序


![](./images/1717596270183.png)








### 快速排序












## 8.4 选择排序（简单选择和堆）

## 8.5 归并排序（归并和基数）

## 8.6 外部排序（外部，败者树，置换-选择，最佳归并）



