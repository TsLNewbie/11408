---
title: 第7-8章 查找和排序
category: /小书匠/日记/2024-06
grammar_cjkRuby: true
---
# 第 7 章 查找
[toc!]
## 7.1 查找的基本概念

**查找**一一一在数据集合中寻找满足某种条件的数据元素的过程称为查找
**查找表**(查找结构)一一一用于查找的数据集合称为查找表，它由**同一类型**的**数据元素**（或记录）组成
**关键字**一一一数据元素中**唯一标识该元素的某个数据项的值**，使用基于关键字的查找，查找结果应该是唯一的。

![](./images/1717420619729.png)
![](./images/1717420640493.png)

对查找表的常见操作

![](./images/1717420668262.png)
### 查找算法的评价指标

查找长度一在查找运算中，需要**对比**关键字的**次数**称为查找长度
**平均查找长度(ASL,Average Search Length)** 一**所有**查找过程中进行关键字的比较次数的平均值

![](./images/1717420723775.png)

![](./images/1717420841661.png)

![](./images/1717420853305.png)
知识整合：
![](./images/1717420866112.png)

## 7.2 顺序，折版，分块查找

### 7.2.1 顺序查找

#### 算法思想
顺序查找，又叫“线性查找”，通常用于线性表。
算法思想：从头到 jio挨个找（或者反过来也OK)

![](./images/1717421153378.png)
### 算法实现

![](./images/1717421224104.png)
![](./images/1717421391564.png)

（哨兵）—— 数据从下标1开始存。

![](./images/1717421417839.png)
从最后开始。

![](./images/1717421474566.png)


>减少了内存调用开销！！


![](./images/1717421506205.png)

![](./images/1717421498191.png)
![](./images/1717421556760.png)

### 算法优化

![](./images/1717421996039.png)

![](./images/1717421672621.png)

![](./images/1717421807305.png)
>（被查概率不相等）
>对于查找失败的问题还是很明显的。而上面的顺序查找成功和查找失败都很平均。

![](./images/1717421820325.png)

知识整合：

![](./images/1717421834444.png)

### 7.2.2 折半查找（考察频率高）

### 算法思想

>折半查找，又称“二分查找”，仅适用于**有序**的**顺序表。**

![](./images/1717422509004.png)

![](./images/1717422555109.png)

注：只有在[low,high]之间才有可能找到目标关键字

![](./images/1717422566587.png)

![](./images/1717422585796.png)

![](./images/1717422597969.png)
如果查找失败：

![](./images/1717422674173.png)

![](./images/1717422680598.png)

![](./images/1717422694469.png)

![](./images/1717422703369.png)


![](./images/1717422709882.png)

### 算法实现


![](./images/1717422804092.png)


### 查找判定树

![](./images/1717424379291.png)

![](./images/1717424406567.png)

![](./images/1717424426711.png)

![](./images/1717424434681.png)

![](./images/1717424450180.png)


![](./images/1717424460356.png)

![](./images/1717424534924.png)


![](./images/1717424521938.png)


![](./images/1717424550895.png)

![](./images/1717424566310.png)

![](./images/1717424725843.png)


>平衡二叉排序树！
>失败结点：成功结点的空指针。

![](./images/1717424763129.png)

![](./images/1717424781206.png)
![](./images/1717424847173.png)




### 折半查找效率

![](./images/1717424227450.png)

![](./images/1717424234392.png)


![](./images/1717424242778.png)

![](./images/1717424250271.png)


![](./images/1717424264048.png)
知识整合：

![](./images/1717424865063.png)
### 拓展思考

![](./images/1717424928476.png)
>如果向上取值

![](./images/1717424990270.png)

![](./images/1717425010800.png)


![](./images/1717425023727.png)


### 7.2.3 分块查找

分块区间：也就是有序的进行分块

![](./images/1717475441939.png)
![](./images/1717475497389.png)


实际查找的效果：

![](./images/1717475538099.png)
30 >= 22，那么22肯定在这个分块里面。

![](./images/1717475544224.png)


在 索引在 8 的位置， 30 和 29不匹配，所以会到下一个分块，结果就是超出范围了。

![](./images/1717475581934.png)

>分块查找，又称**索引顺序查找**，算法过程如下：
①在**索引表**中确定待查记录所属的分块（可顺序、可折半）
②在块内**顺序查找**

### 用折半查找查索引

![](./images/1717475664268.png)
>mid是30，匹配了，然后读取里面，然后就是 顺序查找，最终获得 30 是对的。

![](./images/1717475671144.png)


![](./images/1717475700508.png)
>进行折半查找。

![](./images/1717475710833.png)

![](./images/1717475800505.png)
>如果按照折半查找，会出问题，所以要改改： 当 low>high，low 所指分块中查找。

![](./images/1717475807978.png)

![](./images/1717475864655.png)
查找失败的例子：

![](./images/1717476022260.png)



### 查找效率分析 ASL


![](./images/1717476028094.png)
![](./images/1717476215522.png)



![](./images/1717476565879.png)

![](./images/1717476045291.png)

![](./images/1717476052356.png)
![](./images/1717476298159.png)


知识整合：
![](./images/1717476625728.png)

![](./images/1717476636992.png)

## 7.3 树形查找

### 7.3.1 二叉排序树 BST
#### 定义

二叉排序树 ——> 二叉查找树（BST,Binary Search Tree)

一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
左子树上所有结点的关键字均**小于** **根结点**的关键字：
右子树上所有结点的关键字均**大于** **根结点**的关键字。
左子树和右子树又各是一棵二叉排序树。

>**中序遍历** 可以得到一个递增的有序序列

![](./images/1717476928888.png)
#### 查找

![](./images/1717476978615.png)


![](./images/1717477020779.png)
查找失败：

![](./images/1717477036438.png)


>递归实现

![](./images/1717477088291.png)
#### 插入

![](./images/1717477193509.png)
> 二叉树不允许存在两个 **关键字** 相同的结点。

#### 构造

![](./images/1717477219234.png)
![](./images/1717477236613.png)


#### 删除
先搜索找到目标结点：
①若被删除结点z是**叶结点**，则直接删除，不会破坏二叉排序树的性质。

![](./images/1717477292174.png)
②若结点z只有一棵左子树或右子树，则让z的**子树**成为z**父结点的子树**，替代z的位置。

![](./images/1717477407495.png)

![](./images/1717477412988.png)
③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z,然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。

>第一种思路，直接后继

![](./images/1717477437662.png)
![](./images/1717477486568.png)


>第二种思路，直接前驱。


![](./images/1717477552836.png)
![](./images/1717477560961.png)

>查找长度：**对比关键字的次数**。

#### 查找效率分析 ASL

![](./images/1717477581502.png)

>平衡二叉树：任何结点 左子树 和 右子树 之差 <= 1。

![](./images/1717477670083.png)
>查找失败

![](./images/1717477718933.png)


#### 知识整合：
![](./images/1717477744198.png)

### 7.3.2 平衡二叉树 AVL

#### 定义
平衡二叉树(Balanced Binary Tree),简称平衡树(AVL树)一一树上任一结点的左子树和右子树的高度之差不超过1。
**结点的平衡因子**=左子树高-右子树高。


![](./images/1717477876701.png)



#### 插入操作

![](./images/1717477976836.png)
![](./images/1717477986236.png)

#### 插入新结点后如何调整“不平衡”问题 (最关键)

![](./images/1717478086400.png)
##### LL（左孩子的左子树）

![](./images/1717478095415.png)
>1)L平衡旋转（右单旋转）。由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，
>需要一次向右的旋转操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

##### RR（右孩子的右子树）

![](./images/1717478469517.png)

>2)RR平衡旋转（左单旋转）。由于在结点A的右孩子(R)的右子树(R)上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需
>要一次向左的旋转操作。将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

##### 代码思路

![](./images/1717478528068.png)
##### LR 左孩子的右子树

![](./images/1717478974599.png)
>3)LR平衡旋转（先左后右双旋转）。由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，
>需要进行两次旋转操作，**先左旋转后右旋转。** 先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置
>先让C 左旋， 然后 A 右选。

> C **左旋**顶替 B ，然后 C 再**右旋**顶替 A

![](./images/1717478989806.png)

![](./images/1717479189870.png)


###### RL 右孩子的左子树

![](./images/1717479229765.png)

>同样，C **右选**顶替 B ，然后 C 再**左旋**顶替 A


![](./images/1717479263545.png)

![](./images/1717479361958.png)
##### 汇总：

![](./images/1717479376364.png)
>LL ——> 左孩子 右旋
RR ——> 右孩子 左旋
LR ——> 左孩子的右孩子 左旋右旋
RL ——> 右孩子的左孩子 右旋左旋


#### 拓展探讨 / 练习

![](./images/1717479529709.png)

![](./images/1717479592661.png)
![](./images/1717479604957.png)

问题解答：
![](./images/1717479612673.png)
练习1：

![](./images/1717479669801.png)

![](./images/1717479677696.png)
练习2：

![](./images/1717479705543.png)
![](./images/1717479757108.png)

![](./images/1717479794100.png)
练习3：

![](./images/1717479854640.png)
![](./images/1717479930832.png)
#### 查找效率分析

![](./images/1717479992845.png)
![](./images/1717480085755.png)

#### 知识整合

![](./images/1717480023653.png)

#### 删除（7.3.2_2)

>平衡二叉树的特性： 左<中<右

![](./images/1717480446319.png)
>平衡二叉树的删除操作具体步骤：
①删除结点（方法同“二叉排序树”）
②一路向北找到 **最小不平衡子树**，找不到就完结撒花（不需要调整）
③找最小不平衡子树下，“**个头”最高**的儿子、孙子
④根据孙子的位置，调整平衡(LL/RR/R/RL)
⑤如果不平衡向上传导，继续②


偷看：二叉排序树的知识整合。

![](./images/1717481123513.png)

##### AVL树删除操作 —— 例1 无问题

![](./images/1717481286027.png)

![](./images/1717481340564.png)

##### AVL树删除操作 —— 例2 RR

![](./images/1717481372707.png)

![](./images/1717481380341.png)

![](./images/1717481443202.png)
>"个头" 并非看 关键字的量，而是高度（深度）

![](./images/1717481458834.png)

![](./images/1717481597517.png)

![](./images/1717481609997.png)

##### AVL树删除操作 —— 例3 RL

![](./images/1717481914948.png)

![](./images/1717481927180.png)

![](./images/1717481933251.png)

![](./images/1717481941254.png)
![](./images/1717482026458.png)


![](./images/1717482036981.png)

##### AVL树删除操作 —— 例4 不平衡向上传导

![](./images/1717482082238.png)
![](./images/1717482109084.png)

>不平衡向上传导

![](./images/1717482118768.png)
![](./images/1717482157619.png)


![](./images/1717482176329.png)

![](./images/1717482183092.png)

这样就完成了。

##### AVL树删除操作 —— 例5 删除的结点有两颗子树(选前驱)

![](./images/1717482238002.png)
>前驱：左孩子一路往右
>后继：右孩子一路往左

![](./images/1717482265257.png)

![](./images/1717482273763.png)
![](./images/1717482359572.png)


情况RR：右子树左转。 == 儿子左转
![](./images/1717482366641.png)
![](./images/1717482410525.png)

##### AVL树删除操作 —— 例6 删除的结点有两颗子树(选后继)

![](./images/1717482429750.png)
![](./images/1717482484640.png)


![](./images/1717482490604.png)
>两个选择，85 和 95 个头都是最高的孙子，两者都可以选。

![](./images/1717482514111.png)

![](./images/1717482547597.png)

![](./images/1717482568519.png)

![](./images/1717482573653.png)

![](./images/1717482580285.png)
>不可能考这种有多处理方式的题目。

知识整合：

![](./images/1717482619276.png)
>平衡二叉树的删除操作 比较少考

### 7.3.3 红黑树 RB T

![](./images/1717482962692.png)

> BST ——> AVL ——> RBT

![](./images/1717483009147.png)

![](./images/1717483033142.png)

#### 定义：

> 红黑树 = 二叉排序树 ——> 左 <= 根 <= 右

![](./images/1717483418247.png)
>1.结点要么红，要么黑。
>2.根一定黑
>3.叶也一定黑
>4.红不相连
>5.每条路上黑的量相同。

>左根右，根叶黑，不相红，黑路同。

![](./images/1717483655935.png)


![](./images/1717483668053.png)
![](./images/1717483897402.png)

![](./images/1717483906275.png)
这个才是符合的。

![](./images/1717483954055.png)
一种可能的出题思路。

![](./images/1717483972420.png)
>结点的黑高：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数。

![](./images/1717484001132.png)
![](./images/1717484037096.png)

>红黑树的查找 == BST,AVL 查找

![](./images/1717484085456.png)

#### 插入：

![](./images/1717484159916.png)


#### 删除：
