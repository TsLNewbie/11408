---
title: 第7-8章 查找和排序
category: /小书匠/日记/2024-06
grammar_cjkRuby: true
---
# 第 7 章 查找
[toc!]
## 7.1 查找的基本概念

**查找**一一一在数据集合中寻找满足某种条件的数据元素的过程称为查找
**查找表**(查找结构)一一一用于查找的数据集合称为查找表，它由**同一类型**的**数据元素**（或记录）组成
**关键字**一一一数据元素中**唯一标识该元素的某个数据项的值**，使用基于关键字的查找，查找结果应该是唯一的。

![](./images/1717420619729.png)
![](./images/1717420640493.png)

对查找表的常见操作

![](./images/1717420668262.png)
### 查找算法的评价指标

查找长度一在查找运算中，需要**对比**关键字的**次数**称为查找长度
**平均查找长度(ASL,Average Search Length)** 一**所有**查找过程中进行关键字的比较次数的平均值

![](./images/1717420723775.png)

![](./images/1717420841661.png)

![](./images/1717420853305.png)
知识整合：
![](./images/1717420866112.png)

## 7.2 顺序，折版，分块查找

### 7.2.1 顺序查找

#### 算法思想
顺序查找，又叫“线性查找”，通常用于线性表。
算法思想：从头到 jio挨个找（或者反过来也OK)

![](./images/1717421153378.png)
### 算法实现

![](./images/1717421224104.png)
![](./images/1717421391564.png)

（哨兵）—— 数据从下标1开始存。

![](./images/1717421417839.png)
从最后开始。

![](./images/1717421474566.png)


>减少了内存调用开销！！


![](./images/1717421506205.png)

![](./images/1717421498191.png)
![](./images/1717421556760.png)

### 算法优化

![](./images/1717421996039.png)

![](./images/1717421672621.png)

![](./images/1717421807305.png)
>（被查概率不相等）
>对于查找失败的问题还是很明显的。而上面的顺序查找成功和查找失败都很平均。

![](./images/1717421820325.png)

知识整合：

![](./images/1717421834444.png)

### 7.2.2 折半查找（考察频率高）

### 算法思想

>折半查找，又称“二分查找”，仅适用于**有序**的**顺序表。**

![](./images/1717422509004.png)

![](./images/1717422555109.png)

注：只有在[low,high]之间才有可能找到目标关键字

![](./images/1717422566587.png)

![](./images/1717422585796.png)

![](./images/1717422597969.png)
如果查找失败：

![](./images/1717422674173.png)

![](./images/1717422680598.png)

![](./images/1717422694469.png)

![](./images/1717422703369.png)


![](./images/1717422709882.png)

### 算法实现


![](./images/1717422804092.png)


### 查找判定树

![](./images/1717424379291.png)

![](./images/1717424406567.png)

![](./images/1717424426711.png)

![](./images/1717424434681.png)

![](./images/1717424450180.png)


![](./images/1717424460356.png)

![](./images/1717424534924.png)


![](./images/1717424521938.png)


![](./images/1717424550895.png)

![](./images/1717424566310.png)

![](./images/1717424725843.png)


>平衡二叉排序树！
>失败结点：成功结点的空指针。

![](./images/1717424763129.png)

![](./images/1717424781206.png)
![](./images/1717424847173.png)




### 折半查找效率

![](./images/1717424227450.png)

![](./images/1717424234392.png)


![](./images/1717424242778.png)

![](./images/1717424250271.png)


![](./images/1717424264048.png)
知识整合：

![](./images/1717424865063.png)
### 拓展思考

![](./images/1717424928476.png)
>如果向上取值

![](./images/1717424990270.png)

![](./images/1717425010800.png)


![](./images/1717425023727.png)


### 7.2.3 分块查找

分块区间：也就是有序的进行分块

![](./images/1717475441939.png)
![](./images/1717475497389.png)


实际查找的效果：

![](./images/1717475538099.png)
30 >= 22，那么22肯定在这个分块里面。

![](./images/1717475544224.png)


在 索引在 8 的位置， 30 和 29不匹配，所以会到下一个分块，结果就是超出范围了。

![](./images/1717475581934.png)

>分块查找，又称**索引顺序查找**，算法过程如下：
①在**索引表**中确定待查记录所属的分块（可顺序、可折半）
②在块内**顺序查找**

### 用折半查找查索引

![](./images/1717475664268.png)
>mid是30，匹配了，然后读取里面，然后就是 顺序查找，最终获得 30 是对的。

![](./images/1717475671144.png)


![](./images/1717475700508.png)
>进行折半查找。

![](./images/1717475710833.png)

![](./images/1717475800505.png)
>如果按照折半查找，会出问题，所以要改改： 当 low>high，low 所指分块中查找。

![](./images/1717475807978.png)

![](./images/1717475864655.png)
查找失败的例子：

![](./images/1717476022260.png)



### 查找效率分析 ASL


![](./images/1717476028094.png)
![](./images/1717476215522.png)



![](./images/1717476565879.png)

![](./images/1717476045291.png)

![](./images/1717476052356.png)
![](./images/1717476298159.png)