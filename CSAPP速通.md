---
title: CSAPP速通
category: /小书匠/日记/2024-05
grammar_cjkRuby: true
---
内容来源：[【CSAPP-深入理解计算机系统】](https://www.bilibili.com/video/BV1cD4y1D7uR/?spm_id_from=333.337.search-card.all.click&vd_source=d1002d9c1ba92da4ba3fca4fdca6d750)作者：九曲阑干

# 第一章 计算机系统漫游
一个Hello Program的生命周期：
![](./images/1716303432503.png)

The Hello Program—— hello.c
```c
#include<stdio.h>
int main()
{
	printf("hello,world\n");
}
```

>linux> gcc -o hello hell.c

通过以上的命令，便能生成一个可执行程序——hello.

>编译过程分为四个阶段：**预处理，编译，汇编，连接**

![](./images/1716303711950.png)

预处理器——会通过#开头的代码，来修改原始程序，将内容直接插入到源程序中。——hello.i（文本文件）

编译——词法分析，语法分析，语义分析——（进行翻译）——hello.s

汇编——翻译成机器指令的文件——hello.o(可重定位目标文件)(二进制文件)

链接——hello中调用了printf的函数，printf在printf.o文件中（提前编译号的目标文件），把两个进行合并。——可执行目标文件hello



了解这些知识是为了:
- 优化程序性能（第三章，第五章）
	- 一个函数调用的开销有多大？
		- while比for循环高效？
		- switch语句是不是要比一连串if-else高效的多？
- 理解链接时出现的错误（第七章）
	- 很多问题往往在链接时出现问题。
		- 函数库的调用
		- 静态变量/全局变量的区别
		- 静态库和动态库的区别？
- 避免安全漏洞（第三章）
	-   缓冲区溢出是常见的问题。
		-   理解数据和控制信息在程序栈上是如何存储
		-   书写方式

**运行一个 hello程序 by Shell**

![](./images/1716358526708.png)
## 计算机的硬件组成
![](./images/1716359102190.png)
(第四章讲述CPU)
中央处理单元(Central Processing Unit,CPU)

程序计数器 Program Count(PC)

32-bit:
1 word = 4 Byte

64-bit:
1 word = 8 Byte

系统上电，直到系统结束，CPU就不断在执行PC指向的指令。然后更新PC，指向下一条要执行的指令（两个指令不一定是相邻的）

寄存器 Register File 
CPU内部的存储设备：临时存放数据的空间

算术逻辑单元 Arithmatic/logic Unit (ALU)
用来进行算术

主存/内存 Main Memory （第六章）
存放程序指令以及数据。
物理上，随机动态存储器芯片组成。
逻辑上，看成一个从零开始的大数组。 每个字节都有相对应的地址。

总线 bus
内存和处理器之间通过总线来进行数据传递。
通常总线被设计为传送固定长度的字节块，也就是Word。

I/O 输入输出设备 （第六章、第十章）
每个 I/O 设备都通过一个控制器或者适配器与 I/O 总线相连。

**Hello程序执行的过程：**
1) 输入hello
![](./images/1716359177699.png)
2) 点击回车键，完成指令输入
![](./images/1716359205982.png)
3) 执行Main()函数的代码：
![](./images/1716359259300.png)


>存储关系：
>大容量的存储设备的存取速度要比小容量的慢
>运行速度更快的设备的价格相对于低速设备要更贵

系统设计人员在寄存器文件和内存之间引入了高速缓存
![](./images/1716359616141.png)

**存储层次**
![](./images/1716359650059.png)

>真正操控硬件的是**操作系统**
>所有的应用程序对硬件的操作必须通过操作系统来完成。
>目的有二：
>1.防止硬件被失控的应用程序滥用
>2.系统提供统一的机制来控制这些复杂的底层硬件

**抽象的概念：**
![](./images/1716359858853.png)


## 进程
借助hello程序运行的场景来解释 **进程**

![](./images/1716360225959.png)
通过shell进程加载hello进程，shell进程系统调用。
系统调用会将控制权从shell进程传递到操作系统，操作系统保存shell进程的上下文，然后创建一个新的hello进程及其上下文，将控制权转交给hello进程。
hello进程结束，系统就会恢复shell进程的上下文，并将控制权交给shell进程，shell进程等待下个命令行的输入。

Context（上下文）：操作系统会跟随进程运行中所需要的所有状态信息。（PC和寄存器的值，内存的内容等等）（第八章）

一个进程由多个线程组成，共享代码和数据。
![](./images/1716360756324.png)


## 虚拟内存
>它为每个进程提供了一个假象，就是每个进程都在独自占用整个内存空间。
>每个进程看到的内存都是一样的，便是 **虚拟地址空间**

虚拟地址空间：
![](./images/1716360887224.png)




第一个区域用来 **存放程序的代码** 和 **数据**
该区域的内容是从可执行目标文件中加载而来的。
C语言中，全局变量便是放在这。

第二区域 堆（malloc）
Memory Allocate
堆可以运行时动态的扩展和收缩

第三区域，共享库的存放区域
C语言标准库和数学库这种共享库的代码和数据

第四区域，用户栈
函数调用本质就是压栈：每次当程序进行函数调用的时候，栈就会增长，函数执行完毕返回时，栈就会收缩。
需要注意的是：栈的增长方向是从高地址到低地址。

最顶部区域，内核保留的区域
对应用程序是不可见的。

> Linux系统的哲学思想是：一切皆为文件（Everything is File）
> I/O设备，键盘，磁盘，显示器，网络都是文件。

![](./images/1716361297474.png)

>从一个系统来看，网络也可以视为一个IO设备

![](./images/1716363529552.png)

![](./images/1716364009969.png)
如何用ssh，通过网络在远程主机上运行hello程序。

![](./images/1716364100100.png)

## 阿姆达尔定律 Amdahl's Law
![](./images/1716364165613.png)
定量的看一下系统的加速比。
>定律的主要思想是，当我们对系统的某一部分进行加速时，被加速部分的重要性和加速程度是影响整体系统性能的关键因素。

假设一个应用程序的执行所需要的全部时间用Told表示。
红色部分为不可加速，另外一部分是可加速的。
其中可以加速部分速度 = a \* Told
所以不可加速部分为： Told - a \* Told = (1-a) Told

可加速的性能比例为k
可加速所花费的时间就是 (a\*Told)/k
最后可以得到加速比S

![](./images/1716364429335.png)
![](./images/1716364493722.png)
>因此，如果我们需要把系统的性能提高到2倍甚至更多，我们需要优化大部分组件。

**如何获得更高的计算能力？Concurrency（并发） and Parallelism(并行)**
1. 线程级并发
2. 指令级并行
3. 单指令，多数据并行


## 线程级并发

多核处理器的组织结构：

![](./images/1716364618796.png)

超线程（hyperthreading）/同时多线程

CPU内部，PC和寄存器存在多个备份，浮点运算部分只有一份。

![](./images/1716364759471.png)
超线程处理器可以在单周期的基础上决定执行哪一个线程。

## 指令集并行
![](./images/1716365126598.png)

近几年的处理器可以保持每个周期2-4条指令的执行速率。

## 单指令，多数据并行
单指令，多数据(Single Instruction Multiple Data,SIMD)
SIMD指令多是为了提高处理视频，以及声音这类数据的执行速度。

![](./images/1716365280909.png)


## 计算机系统的抽象 **

![](./images/1716365314162.png)

# 第二章 信息的表示和处理

Summary
1. Information Stroage（信息存储）
2. Integer Respresentations（整数表示）
3. Integer Arithmetic（整数运算）
4. Floating Point（浮点数）

## 2.1 信息存储
>通常情况下，程序将内存视为一个非常大的数组，数组的元素由**一个个字节**组成。每个字节都有唯一的数字表示，也就是**地址**。
>所有地址的集合——虚拟地址空间（virtual address space）

![](./images/1716365502638.png)
### 字节 Byte

>1 Byte = 8 bit

![](./images/1716365821132.png)
### 16进制数 Hexadecimal Notation
>十六进制好处：节省显示位置，方便与2进制转换。

十六进制表示：

![](./images/1716365943408.png)
无论是大小写，还是混合都正确。

二，十，十六进制的转换。

![](./images/1716366006624.png)
十六进制的转换比较直接，从图中能看出来。

>CSAPP原书介绍了一个小技巧：（好像没必要记住）
>记住 十六进制的 A,C,F
>那么B，D的数值可以由AC加一得到，E的数值可以由F减一得到。



#### 十六进制与二进制转换

>从最后一个，每四位分成一组，若最前一组出现没有四位的情况，那就补0

![](./images/1716366222778.png)
>记住这个： 2^(n)  -> n = i + 4j
>其中 
>i = 0 ，1，2，3
>hex = 1，2，4，8... 2^(i) (十进制)

![](./images/1716366324902.png)
#### 十进制与十六进制转换

>一直除 16，把余数拿来当作位数即可。

![](./images/1716366454548.png)
>对16进制，对应位置乘以 16^(i) 即可。

![](./images/1716366510992.png)

### 字 Word

**字长**

![](./images/1716366581005.png)

>大多数64-bit的机器做了向后兼容，因此32-bit可以在64-bit的机器上运用。
>主要的区别是：程序是如何编译的。

![](./images/1716366640443.png)
表格：C 的各个数据所占字节数的大小。

![](./images/1716366706479.png)

### 变量所在地址 *

>重点：**大端法(Big endian)**，**小端法(Little endian)**
>新的处理器，支持双端法，但android和IOS只支持小端法。

![](./images/1716366766061.png)

CSAPP原书在四个系统中尝试字节打印程序：

![](./images/1716366867524.png)

打印字节程序

![](./images/1716366894178.png)
其中：byte_pointer是强制切换为字节的序列。

![](./images/1716366963685.png)
![](./images/1716366978554.png)

因为不同操作系统使用不同的存储分配规则，指针的值是完全不同的。且32位用4Byte的地址，64位用8Byte的地址。

![](./images/1716366989620.png)
虽然整型和浮点数都是12345进行编码，但是却有完全不同的字节模式：

![](./images/1716367075119.png)

若换成二进制，并进行适当的移位，就发现有13个位的匹配：

![](./images/1716367116758.png)

> C语言的字符串被编码为以NULL字符结尾的字符数组。

![](./images/1716367275615.png)

### 布尔运算 *

>重点如图所示。与，非，或，异或。

![](./images/1716367360310.png)
C语言的特性：按位级运算支持布尔运算。

![](./images/1716367403472.png)
> 位运算的常见场景便是**掩码运算**

例如：对于一个数组，如何去获取最低有效数值？可以通过 & 0xFF

![](./images/1716367473819.png)

#### 逻辑运算：
(只有 True 和 False)

![](./images/1716367516722.png)

![](./images/1716367543829.png)
#### 移位运算：

>右移 分 逻辑右移 和 算术右移

![](./images/1716367636427.png)

![](./images/1716367693111.png)
再看看例子：

![](./images/1716367715182.png)
>实际上，几乎所有的编译器以及机器的组合都是对**有符号数**使用**算术右移**，**无符号数**就是 **逻辑右移**


## 2.2 整数的表示

表格(64位机器上的取值范围）：

![](./images/1716367803857.png)
>long类型的大小：取值范围是与机器字长相关的。

![](./images/1716367873978.png)

### 无符号数编码

>假设一个整数的数据类型有w位，用向量x来表示。
>把向量x看成一个二进制表示的数，每个元素=一个二进制位，每个位取值为0/1;
>B2U = Binary to unsigned

![](./images/1716368039061.png)

CSAPP原书的图形表示法：

![](./images/1716368096574.png)

### 有符号数编码 
Two's Complement Encodings （补码）

>主要注意的是，最高位的权重是 **负数**

![](./images/1716368200193.png)
补码图形化：

![](./images/1716368248155.png)

### 可表示的整数范围

无符号数：

![](./images/1716368309910.png)

有符号数：
最大数：

![](./images/1716368332757.png)

最小值：

![](./images/1716368365971.png)

特别注意： 

![](./images/1716368391592.png)

例子：

![](./images/1716368445312.png)


### 有符号数 / 无符号数的转换

通过强制转换，就会出现问题：

![](./images/1716368514699.png)
>位模式不变，解释这些位的方式改变了。

**有符号数与无符号数之差**
> B2U = 无符号数
> B2T = 有符号数 
> T2U= 有符号数到无符号数的函数映射

![](./images/1716368709923.png)
>有符号数到无符号数的规则：
>当有符号数为正数，那么就是 相同的数
>当有符号数为负数，那么就是 数值 + (最大的位+1)

>无符号数到有符号数的规则：
>当无符号数的最高位=0，那么就是 相同的数
>当无符号数的最高位=1，那么就是 数值 - (最大的位+1)


C语言会隐式的将有符号数强制转换为无符号数来执行运算。

![](./images/1716369015000.png)

>将一个较大的数据类型 转换 较小的类型 是不可能的。
>但较小的数据类型 转换 较大的类型 是可以的。


无符号数的转换：**零扩展**

![](./images/1716369145178.png)
#有符号数的转换： 符号位扩展

![](./images/1716369179768.png)
原书内容：

>数学归纳法

![](./images/1716369250197.png)

![](./images/1716369302109.png)
![](./images/1716369337681.png)


>较大数值 -> 较小数值
>高16位被丢弃，只留下低16位的数据. 

>总之，无符号数以及有符号数的转换会出现一些难以发现的错误（非直观）。了解这类知识，就避免这种问题。


## 2.3 整数运算

### 无符号数加法：

![](./images/1716369578870.png)
>产生这个结果的原因是 以及超过char的数值。(溢出)

引入无符号数的加法的标志：

![](./images/1716369638693.png)
两个无符号数加法的情况：

![](./images/1716369654251.png)


原因：

![](./images/1716369700215.png)
>由于加完1就溢出了，为了避免位数增加，因此变成这样，且不会报错。

**判断溢出：**

![](./images/1716369778229.png)
原理：

![](./images/1716369854738.png)

### 有符号数加法：

引入符号：

![](./images/1716369875620.png)
情况：

![](./images/1716369917225.png)
例子：

![](./images/1716369939807.png)

原理：

![](./images/1716369967829.png)

**检测是否发生溢出：**
![](./images/1716370056299.png)


### 加法逆元（Additive Inverse）

图中：x' 便是 加法逆元。

![](./images/1716370199286.png)

**无符号数的逆元：**

![](./images/1716370534274.png)
**有符号数的逆元**

![](./images/1716370564413.png)

### 乘除运算

**无符号数**

![](./images/1716386761592.png)
C语言中，定义了无符号数乘法所产生的结果是w位
因此结果会截取低w位的成果。——取模

![](./images/1716386837319.png)
**补码**

>与无符号数多了一个操作，就是把无符号数**补码**——转成有符号数

![](./images/1716386901798.png)
例子：

![](./images/1716386959401.png)
>虽然有符号数和无符号数在计算出来的位级表示可存在不同，但是截断后是**相同的**。

通过数学的方法来表示。 x，y有符号数，x' , y' 为 无符号数。

![](./images/1716387059862.png)
有符号数和无符号数的关系如下：

![](./images/1716387084333.png)
取模的推导过程：

![](./images/1716387096352.png)
很多C语言的编译器试图用**移位**、加法以及减法来代替整数乘法操作。

![](./images/1716387180158.png)
移位操作通过数学公式表达：

![](./images/1716387225093.png)
例子：

![](./images/1716387310257.png)

### 除法（右移）

>对于无符号数采用的是**逻辑右移**，而有符号数采用的是**算术右移（补1/0）**

![](./images/1716387410612.png)
会遇到除不尽的情况：

3.14向零舍入的结果是3，-3.14向零舍入的结果是-3
(1)正数，向下舍入
(2)负数，向上舍入

![](./images/1716387551637.png)
**无符号数除以2的幂的情况**

![](./images/1716387617719.png)

> x >> k：进行右移K位

![](./images/1716387703072.png)
> x << k: x左移K位 = x1 × 2^(k)

![](./images/1716387765773.png)
>x1 左移 k位 与 x2 相加之和 与 x 相等。

![](./images/1716387802411.png)
>由于 x2 的长度为 k 位， 因此 x2 的取值范围大于等于 0 ，小于2 的k 次方
>x 除以 2 的k次方，取整的结果 = x1


**补码**

![](./images/1716388137432.png)
>特别注意：当需要舍入时，移位导致 -771.25 向下舍入为 -772
>我们期望得到的结果是-771。
>因此需要加入偏置，修正这种不合适的舍入。



![](./images/1716388288065.png)
>当右移四位时，偏置量 = 15（1 << 4 -1)
>当右移八位时，偏置量 = 255 (1 << 8 - 1)
>注意红圈的位置。

![](./images/1716388532318.png)
> (1) 先加入偏置量，再进行**算术右移**
> (2) 直接进行**算术右移**

## 2.3 浮点数 Floating Point

考虑含有小数值的二进制数

十进制表示小数：

![](./images/1716389280566.png)
二进制表示小数：

![](./images/1716389319350.png)

IEEE对浮点数的表示：

![](./images/1716389512740.png)

>以上红色的数字代表长度。
>exp与阶码的值是相关的
>frac与尾数M是相关的

浮点数的数值分为三类：
1. 规格化的值
2. 非规格化的值
3. 特殊值

![](./images/1716389645042.png)
### 规格化的值

![](./images/1716389755291.png)
![](./images/1716390044906.png)

>单精度浮点数：
>阶码的最小值是 -126，最大值是127
>小数字段：M = 1+f
>1 是 因为 我们可以调整E的取值，使得尾数M的取值范围大于等于1，小于2，既然第一位总是1，就没必要显示的表示出来。

### 非规格化的值

![](./images/1716390120377.png)
>与规格化的解释方法不同。

### 特殊值

![](./images/1716390183327.png)
>NaN 的意思是 NOT A Number.
>当阶码字段全为1，且小数字段不为0时，可以表示NaN。

**例子：8为浮点数的表示**

![](./images/1716390324819.png)

非规格化：

![](./images/1716390268317.png)

规格化、特殊值：

![](./images/1716390343016.png)

在之前进行过整型数和单精度浮点数的对比：

![](./images/1716428655044.png)
通过移位，发现二者有一段数位是相同的。

![](./images/1716428664557.png)
通过 转换 就能发现为什么会有数位相同的情况。

### 整型 转换 浮点数

整型 12345 如下，因为高位都是0，所以忽略。

![](./images/1716428777148.png)
根据规格化的表示规则，如下表示：可以发现阶码E的值=13

![](./images/1716428835769.png)
由于单精度小数字段长度为23，末端需要补0：

![](./images/1716428872383.png)
这样就获得了浮点数的小数字段。

阶码E的值=13 ，由于单精度的浮点数bias = 127 （固定值），并可以通过以下公式进行计算：

![](./images/1716428989672.png)
这样浮点数的表示就出现了。

![](./images/1716429010696.png)
由于表示方法原因，限制了浮点数的范围。

希望可以找到“最接近的值 x' 代替x”

![](./images/1716429200208.png)
IEEE定义了四种舍入方式：
1. 向偶数舍入(Round-to-even)
2. 向零舍入(Round-toward-zero)
3. 向下舍入(Round-down)
4. 向上舍入(Round-up)

**向下舍入，向上舍入，向零舍入：**

![](./images/1716430041945.png)

**向偶数舍入（向最近的值舍入）**

>当遇到两个可能结果的中间数值时（1.5，2.5），才需要进行这个舍入判断。
>一句话： **四舍六入五偶**

![](./images/1716430100015.png)
>为什么要用？
>因为如果总是用向上/向下舍入，会导致结果的平均值对于真实值略高/略低。
>向偶数舍入就避免这种偏差，让向上/向下舍入都有50%的概率。

例子：**四舍六入五偶**

![](./images/1716430381427.png)

二进制也能进行舍入：

![](./images/1716430423069.png)

## 浮点数加减乘除：
>浮点数加减法不具备**结合性**(会通过舍入丢失)
>乘法不具备结合性（溢出和舍入导致丢失）
>乘法在加法上不具备**分配性**。

![](./images/1716430587437.png)
## int , float , double

1. int ——> float
	- 数值不会发生溢出，但是可能会被舍入
		- 单精度浮点数的小数字段为**23位**，可能会出现无法保留精度的情况。
2. int/float ——> float
	- Double类型有更大的范围，可以保留精确数值。
3. double ——> float
	- float类型数值范围更小，可能会发生溢出。
	- 精度也较小，转换后还可能被舍入
4. float/double ——> int
	- 值会向零舍入。
	- 发生溢出。

# 第三章  程序的机器级表示 （上难度了）

>详细提及：C语言，汇编代码，机器代码之间的关系

## 3.1 机器级表示

C代码例子：

![](./images/1716432587240.png)

```
linux > gcc -Og -o prog main.c mstore.c
```

>其中 （第七章详细讲解）
>gcc = GCC编译器，是linux系统上默认的编译器。
>-Og = 编译选项，告诉编译器生成符合原始C代码整体结构的机器代码。
>（为了获得更高性能，会使用 -O1 -O2，但是使用高级别的会产生变形)
>-o prog = 生成可执行文件的文件名

### C代码 转换 汇编代码-S(.s)

其中用 mstore.c 看看 C代码和汇编代码之间的关系。

![](./images/1716432828256.png)
>利用linux那一行的指令，便能生成出mstore.s的汇编代码。
>其中 -S 告诉编译器GCC产生的文件为汇编文件。

大致文件内容：

![](./images/1716432934096.png)

>白色的以“.”为开头的文字： 指导汇编器和链接器工作的伪指令。（在这可忽略）
>剩下的汇编代码与源文件中的C代码是相关的。

重点：
- pushq %rbx
	- 将寄存器rbx的值压入程序栈进行保存。
	- 理解这一步操作，先理解寄存器的背景故事。
- movq %rdx, %rbx
	- 将寄存器rdx的内容复制寄存器rbx。
	- ![](./images/1716433727532.png)
	- mov q ，q是数据大小。（看后面部分的数据类型）
	- 数据传送指令有四个变种：
		- movb
			- Move byte
		- movw
			- Move word
		- movl
			- Move double word
		- movq
			- Move quarter
- call mult2
	- 函数调用。
	- 该函数的返回值会保存到寄存器rax中（本代码rax保存了x和y的乘积结果）
- movq
	-  将寄存器rax的值送到内存(rbx)中
- popq %rbx
	- 恢复寄存器rbx的内容。
- ret 
	-  函数返回。

**寄存器背景故事**

>在Intel x86-64的处理器中包含了16个通用目的寄存器。
>这些寄存器用来存放**整数数据**和**指针**
>都是%r开头

![](./images/1716433189384.png)
>还需要了解两个概念：
>1.调用者保存寄存器
>2.被调用着保存寄存器

图中，func_A 调用了 func_B，因此func_A 是调用者 ，func_B 是被调用者。

![](./images/1716433280092.png)
>由于调用了函数B，寄存器rbx在函数b中被修改了（代码内容）
>逻辑上rbx的内容在调用函数b的**前后**应该保持一致。


解决方法：**先保存，后调用，再恢复。**
**调用者(Caller)保存**

![](./images/1716433446453.png)

**被调用者(Callee)保存：**

![](./images/1716433484065.png)

具体用哪个策略，每个寄存器都不同：具体为：

![](./images/1716433522262.png)
**数据类型的大小：**

![](./images/1716433766761.png)

### C代码 转换成 机器代码-c(.o)

![](./images/1716434090787.png)
文件为二进制格式的，无法直接查看。
因此借助反汇编程序 objdump 
汇编器将汇编代码 翻译成 二进制的机器代码
反汇编器就是机器代码 翻译成 汇编代码

![](./images/1716434178164.png)
通过反汇编给出的代码：

![](./images/1716434190211.png)
>有区别，其中就和q有关。（q表示大小指示符）

## 3.2寄存器与数据传送指令

最早8086 CPU中，包含8个16位的通用寄存器。

![](./images/1716434301340.png)

CPU 扩展 32位 寄存器也扩展

![](./images/1716434329515.png)
再到现在64位CPU，寄存器已经到64位。

![](./images/1716434361207.png)
寄存器有不同的用处：

![](./images/1716434374059.png)


大多数的指令包含两部分—— **操作码** 和 **操作数**

![](./images/1716434450443.png)
**操作数**可以分为三类：
- 立即数(Immediate)
	- 在AT&T格式的汇编中，$符号开头，后面跟着整数（需要满足标准C语言定义）。
- 寄存器(Register)
	- %rdi,%rax...etc.
- 内存引用(Memory Reference)
	- (%rdi) 

### 内存引用 Memory

>要从内存中获得数据，需要**目的数据起始地址addr**以及**数据长度b**。Mb[addr]表示内存引用。


最常用的内存引用包含四个部分：
1. 立即数
2. 基址寄存器
3. 变址寄存器
4. 比例因子

其中的Imm（rb,ri,s) 是有效地址。

![](./images/1716434725258.png)
>比例因子的取值 与 源代码中 定义的 **数组类型** 是相关的。
>例如：
>char 比例因子 = 1
>int 比例因子 = 4
>double 比例因子 = 8

**内存引用的其他形式：**

![](./images/1716434920002.png)
![](./images/1716434993092.png)

### MOV 操作数 

![](./images/1716435049462.png)
>x86-64处理器有一条限制，mov指令的源操作数和目的操作数不能都是**内存的地址**。（因为内存太慢了，所以不能这样做）

如果要 Memory ——> Memory，就只能这样做了。

![](./images/1716435144633.png)
>mov指令的 后缀 与 寄存器的大小 一定得是**匹配**的。
>例如：
>&eax 32位  movl 对应
>&al 8位 movb 对应

![](./images/1716435186626.png)


**特殊情况**

>立即数只能是 **32位** 补码表示。
>扩展后带到64位寄存器中。

![](./images/1716435292053.png)
>带来一个问题，当**立即数** 为 64位怎么办？

引入movabsq，该指令的源操作数可以是任意的64位立即数。目的操作数只能是**寄存器**。

![](./images/1716435385248.png)
**例子：**

首先进行了movabsq的指令，寄存器保存数值如图所示。（注意：大端法）

![](./images/1716435489991.png)
接下进行movb，低八位发生了变化。

![](./images/1716435569053.png)
再加上：

![](./images/1716435611614.png)

再来：

![](./images/1716435625721.png)
>当movl 的 目的操作数是寄存器时，会把该寄存器的高4字节**设置为0**
>这是x86-64的规定。

当源操作数的数位**小于**目的操作数时：
>需要对目的操作数剩余的字节进行**零扩展**或者**符号位扩展**。

零扩展：

![](./images/1716435752512.png)
符号位扩展：

![](./images/1716435848535.png)

>cltq 源操作数总是 %eax， 目的操作数总是 %rax

总结：

![](./images/1716470384112.png)

## 3.3 栈与数据传送指令

>先从计算机系统的视角，看一下程序执行时数据传送的情况。
>最初，可执行文件是保存在硬盘上。
>通过shell程序，将可执行程序从硬盘加载到内存。
>此时，程序指令以及数据都保存在内存中。
>实际上，在一些程序的执行过程中，需要CPU和内存之间进行频繁的数据存取。（所以为什么内存要靠近CPU）

假设：

![](./images/1716471573223.png)

那么就得先：假设是64位处理器、%rax 为 8 Byte。

MOV Memory, Register

变量A为 long变量，因此也是 8 Byte，此时%rax就得存满变量A的数据。

如果变量A是int类型，那么就只需要4个字节来存储变量。(%eax)(低32位)

如果变量A是short类型，那么只需要2个字节，寄存器的低16位(%ax)

![](./images/1716471825404.png)
>虽然用的是不同符号，但是实际上是针对 **同一寄存器** 的 不同数位进行操作。

处理器完成加法运算和，会在通过**一条数据传送指令**将计算结果保存到内存。

>数据传输指令很常用，所以需要了解。

### 数据传送代码示例

![](./images/1716471995169.png)
其中exchange函数：

>x 放到 %rax 中

![](./images/1716473430513.png)
 >C语言所谓的指针其实就是地址。

### 程序栈

>还有两个数据传送指令需要借助**程序栈**。
>通过 push 压入栈 通过 pop 删除数据。

程序栈本质上是一个区域。图中User Stack便是。

![](./images/1716473546361.png)
栈顶在顶部，栈底在底部。

![](./images/1716473561607.png)
以下展示 pushq 的操作。

![](./images/1716473672382.png)

>pushq %rax =将%rax的数据放入栈中，等效以下两步：
>**subq $8，%rsp** 
>//这一步代表了 %rsp位置减8，从图中可知为什么要减8
>movq %rax,(%rsp)

>popq %rbx = 将栈顶保存的数据复制到寄存器rbx中，等效以下两条指令。
>movq (%rsp), %rbx
>addq $8,%rsp

>注意：popq 是通过**移动指针位置**进行删除的，并非真的删除数据。（这个是很常用的情况）
>就如同删除时数据是会保留，只有在被替代的时候才会消失。

## 3-4 算术和逻辑运算指令

### LEAQ
>功能：加载有效地址，q代表长度是4个字。
>因为64位处理器，因此不存在leab，leaw

![](./images/1716473979495.png)

![](./images/1716474035069.png)

这条指令的含义是把有效地址复制到寄存器rax中。

![](./images/1716474172037.png)
>有效地址的计算方式与之前讲到的内存地址的计算方式是一致的。

![](./images/1716474196558.png)
>这个代码并非为去内存地址(5x+7)处读取数据。
>而是将有效地址（5x+7）这个值直接写入到目的寄存器rax。

**leaq指令可以用来表示加法和有限的乘法运算**

以下scale函数代码编译后获得右侧的机器代码：

![](./images/1716474318851.png)
>其中：**x in %rdi， y in %rsi ， z in %rdx** （都是属于常规）

![](./images/1716474491264.png)

为什么不能用以下的代码？ 因为比例因子只有 1，2，4，8 。要操作就得拆分。

![](./images/1716474568826.png)

### 一元操作 Unary Operations

> 这一组指令只有一个操作数，因此操作数既是**源**，也是**目的**。

![](./images/1716474661808.png)
### 二元操作 Binary Operations

>这一组操作数包含两个：
>第一：源操作数：立即数，寄存器，内存地址
>第二：源操作数 /目的操作数：寄存器，内存地址，**不能是立即数**

![](./images/1716474735725.png)
例子：

一开始，内存以及寄存器中所保存的数据如图所示。

![](./images/1716474847496.png)
>(%rax) => 0x100地址的内存
>以下为：0x100的数据和%rcx 相加， 再存到0x100内存内。 （0x都是十六进制）

![](./images/1716474922636.png)

具体效果：

![](./images/1716475038553.png)
以下为：0x108的数据减去%rdx的数据，并再存到0x108内存中。

![](./images/1716475063261.png)

具体效果：

![](./images/1716475117190.png)
以下为：一元操作，自 +1;

![](./images/1716475150161.png)

具体效果：

![](./images/1716475181726.png)

最后一个：二元操作： SUB S,D   D <—— D - S

![](./images/1716475652708.png)
>要记住，可以多做书中习题。

### 移位运算

>**算术右移**和**逻辑右移**和C语言讲述的移位操作是一致的。

![](./images/1716476026492.png)
### 移位量k Shirt Amount

>可以是立即数，或者是放在寄存器cl中的数。（只允许%cl）
>移位量的编码范围 = 2^8 - 1 （255）

> 对于 **w位** 的操作数进行移位操作。移位量是由 寄存器cl 的 **低m位** 来决定。


![](./images/1716476202827.png)

对于指令salb ，对低3位来决定。(btye = 8 = 2^3)

![](./images/1716476239318.png)
salw，低4位来决定。(word = 16 = 2^4)

![](./images/1716476312233.png)
以此类推，双字对应的是低5位，四字对应的是低6位。


>如果数据只有8位，最多只能移动8为，如果移位9，就取9%8 = 1 ，移1位。



例子：

![](./images/1716476354656.png)
重点看这一指令：

![](./images/1716476373366.png)
第一步：

![](./images/1716476385525.png)

第二步：

![](./images/1716476401275.png)
>为什么编译器不直接使用乘法指令进行运算？ 主要是执行需要更长的时间。


### 特殊的算术指令

![](./images/1716476481894.png)
## 3-5. 指令与条件码

>在C语言中，存在条件语句，循环语句（if, while)
>根据数据测试的结果来决定操作执行的顺序。

减法指令 subq ，需要用到算术逻辑单元 ALU


![](./images/1716536426928.png)
>其中条件码寄存器（Condition Code Register）会被该运算结果去设置此寄存器。

### 条件码寄存器

>是CPU来维护的，长度是**单个比特位**。
>它描述了**最近执行操作的属性**

条件码寄存器：

![](./images/1716536588665.png)

例如：ALU执行两条连续的算术指令，t1时刻执行addq ，t2时刻执行subq
>T1 时刻 条件码寄存器 保存的是 指令1的执行结果的属性
>T2 时刻 条件码寄存器 会被 指令2 所覆盖。

![](./images/1716536643697.png)
#### 常用的条件码寄存器

**CF——Carry Flag（进位标志）**

>当CPU最近执行的一条指令最高位产生了进位时，CF = 1。
>可以用来检查无符号数操作的溢出。

![](./images/1716536793753.png)

**ZF —— Zero Flag （零标志）**

>当最近操作的结果 = 0 时， ZF = 1;

![](./images/1716536847771.png)
**SF —— Sign Flag （符号标志）**

>当最近操作的结果 < 0 时， SF = 1；

**OF —— Overflow Flag （溢出标志）**

>最近的操作导致 正溢出 / 负溢出 时 ， OF =1；

#### 条件码寄存器的值

>条件码寄存器的值是由ALU 在执行**算术和运算指令时写入的**。以下都会改变条件码寄存器的值。

![](./images/1716536993280.png)
>不同指令有不同相应的规则：
>XOR ——> CF = 0,OF = 0
>INC(加一) DEC（减一） ——> OF,ZF

**CMP指令 AND TEST指令**

![](./images/1716537148753.png)
>CMP 指令 = 根据 两个操作数的差 来 设置 **条件码寄存器。**
>和SUB 指令 很像，但CMP只设置条件码寄存器。

> TEST 指令 = 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置**符号标志位**、**零标志位**和**奇偶标志位**。
> 和AND操作很像，也是只设置条件码寄存器。


**例子（条件代码）：**

![](./images/1716537511589.png)

>注意：图中的comq  写错了，应该是 cmpq

第一步：cmpq 指令，操作 =  a - b
根据a - b 结果设置**ZF**， 当 a = b 时， ZF = 1；

第二步：sete指令 =  根据零标志（ZF） 的值 对 寄存器 al 进行赋值。

if ZF = 1 , %al = 1;
if ZF = 0 , %al = 0;

第三步 movzbl 对 %al 进行零扩展。

**复杂的例子：**

>其中，sete 变成了 setl
>指令setl 的含义 = 如果 a < b ，将%al = 1； （后缀 l = less 的缩写）

![](./images/1716537723695.png)
判断小于的情况会复杂一些，如图所示：**SF ^ OF (符号标志 异或 零标志)**
异或：两者相同  = 0 ，两者不相同 = 1；

![](./images/1716537820888.png)
根据多个例子：

![](./images/1716539196434.png)
其他的判断情况：

![](./images/1716539214103.png)

无符号数的比较情况：

![](./images/1716539230434.png)
>并不需要去记住，但了解是怎么做的！

## 3.6 跳转指令与循环

>absdiff_se  ： 计算两数之差的绝对值。

![](./images/1716540476854.png)
cmpq ——> 实现条件语句 x < y 。根据结果，设置 SF(符号) 和 OF（溢出）
jl ——> 根据 SF ^ OF 的结果判断，是顺序还是跳转到.L4处执行。


### 跳转指令

跳转指令会根据条件寄存器的某种组合来决定是否进行跳转。与上一节 set 指令意思一样。

![](./images/1716540527789.png)
>if-else 在现代CPU上处理速度可能有点低，针对这种情况，有一种替代的策略：
>使用 数据的条件转移 来代替 控制的条件转移。

另一种实现方式：

![](./images/1716540656937.png)
写法看上去差别不大，但是右侧的汇编效率就很快了。以下为对应的汇编指令：

![](./images/1716540822781.png)
重点是 CMOV ：根据**条件码的某种组合**来进行**有条件的传送数据**。当满足规定条件时，将 %rax = %rdx

![](./images/1716540862521.png)
本次代码便是只有 x >= y ，才会执行这一条指令。

![](./images/1716540924589.png)

**更多条件传送指令：**

![](./images/1716540968716.png)
>Q:为什么条件指令 比 跳转指令 的 代码效率高？（第四章会有详细讲解）
>A:这是因为现代CPU通过流水线来获得高性能。
>当遇到跳转指令时，会根据 分**支预测器** 来猜测**每条**跳转指令是否执行。此时发生错误预测，就会浪费大量时间。
>当遇到条件传送，CPU无需预测便可执行。

### 循环结构 do-while, while, for

![](./images/1716541143538.png)
汇编语言中没有给出专门的语句用于循环，循环语句是通过 **条件测试** 与 **跳转** 的结合实现的。

#### do-while

![](./images/1716541205893.png)
其中：cmpq指令 ——> 检测 (%rdi - 1) 调整：ZF 

#### while

> 能看到最大的差别就是 while() 的位置不同，do while 是**先执行后检测**， while是**先检测后执行**。

![](./images/1716543459458.png)

#### For

![](./images/1716543524079.png)


#### 循环实现n的阶乘：

![](./images/1716543555375.png)

重点是这个：For 循环 和 while 循环的汇编代码：

>除了跳转指令不同，其他皆为相同。

![](./images/1716543582177.png)

#### Switch

![](./images/1716543615765.png)

对应的汇编指令：

> 如果 n 大于 6 ，程序跳转到 default 对应的 L8 程序段。

![](./images/1716543637593.png)

对应 case0~ case6 的情况，可以通过跳转表 来访问不同分支
C代码将跳转表声明为一个长度为**7的数组**。（leaq .L4(%rip))
每个元素都是一个指向代码位置的指针。
case 4 ， case 6 相同，因此使用相同的标号
对于缺失的case 1 和 case 5 ，使用默认情况的标号

![](./images/1716543738905.png)
>与if-else 相比， 使用跳转表的有点是执行switch 语句的时间与case的数量无关的（因为只需要跳转一次）

## 3.7 过程（函数调用）

>在大型软件的构建过程中，需要对复杂功能进行切分
>过程（Procedures）提供了一种封装代码的方式

![](./images/1716544097577.png)
以**C语言中的函数调用**为例，讲述过程的机制。

假设：函数P 调用 函数Q ， 函数Q 执行完返回 函数P
这一系列操作就包括图中的机制：

![](./images/1716544174226.png)
- Passing control 传递控制
- Pasing data 传递数据
- Allocating and deallocating memory 分配和释放内存

### 栈的函数调用

在先前章节中提到：栈为 函数调用 提供了 后进先出 的内存管理机制。

![](./images/1716544279987.png)
当函数Q正在执行时，函数P以及相关调用链上的函数都会被暂时挂起。

### 栈帧

>当函数执行所需要的 存储空间 超出 寄存器 能够存放的大小时：就会借助栈上的存储空间，把这部分存储空间称为 = **函数的栈帧**

对于函数P调用函数Q的例子，包括：较早的帧，调用函数P的帧，正在执行函数Q的帧：

![](./images/1716544520626.png)
当函数P调用函数Q时，会把返回地址压入栈中： return address
该地址指明了当函数Q执行结束返回时，**要从函数P的哪个位置继续执行。**
返回地址的压栈操作 = 指令call 来实现。

以main函数调用multstore函数为例，解释 指令call 和 指令ret 的执行情况。

![](./images/1716544636997.png)
节选了相关的反汇编代码：

![](./images/1716544691336.png)

![](./images/1716544989430.png)

>callq 对应 multstore函数的调用
>指令call ： 
>1.将函数multstore的第一条指令的地址存入到程序指令%rip中，实现函数调用。
>2.将返回地址压入栈中。（地址就是函数multstore执行完的**下一个指令的地址**）

![](./images/1716544908552.png)

>当multstore执行完毕，指令ret从栈中将返回的地址弹出，写入到指令寄存器 %rip 中

![](./images/1716544930027.png)
>按照自己的语言总结：假设 一个 main函数 一个 Change函数
>main函数调用  Change时： change的函数首地址存放在 %rip 中，其次生成一个返回地址（利用指令ret），该地址为调用的下一个代码地址。
>在执行完毕后，就会到指令ret ，就会把栈中的返回地址弹出，弹到 %rip 中，这样就回去了。

### 参数传递

>如果一个函数的参数数量 > 6 ，超出的部分就要通过**栈来传递**。

![](./images/1716545399436.png)
>**参数1~参数6 相对应的寄存器（这个是固定，得记一记）**
>%rdi , %rsi , %rdx , %rcx ,%r8 ,%r9
>(di,si,dx,cx,8,9)
>寄存器也有特殊顺序规定：

![](./images/1716545409370.png)
![](./images/1716545654011.png)


>栈指针是 %rsp 里面存的地址

![](./images/1716545517240.png)
>注意：
>第一：通过栈来传递参数时，所有数据的大小都是向8的倍数对齐（无论如何）
>第二：返回地址占用了栈顶的位置（栈顶是最底位置），所有两个参数是+8,+16...


### 局部变量

>函数caller 定义了两个局部变量 arg1 , arg2

![](./images/1716545708354.png)
>函数caller 对应的 汇编代码

![](./images/1716547655007.png)

本次汇编代码如下：

- subq
	- 在栈上分配16个字节的空间(图1-1)
- movq 
	- 一个534 存储在 (%rsp)
	- 一个 1057 存储在 8(%rsp) （图1-2）
- leaq 
	- 功能：加载有效地址，q代表长度是4个字。
	- 将 8(%rsp) （地址） 写入 %rsi 
- movq
	- %rdi (第一个寄存器) = %rsp (内存)（这个位置的数值是534)
- call swap
	- 调用swap函数，把两个数值对调。
 - movq 
	 - %rdx(第三个寄存器) = (%rsp) (内存)（第一个位置）
- subq
	- %rdx = %rdx - 8(%rsp) (内存，第二个位置，数值 = 534)(已经swap了)
...
- addq
	- 通过对栈顶指针 + 16,释放栈帧。
![图1-1](./images/1716547728850.png)
![图1-2](./images/1716547879374.png)


另一个例子：

x1 = 8字节， x2 = 4字节 x3 = 2字节 x4 = 1字节

![](./images/1716548478755.png)
>注意：**传递的参数**需要8个字节**对齐**，而**局部变量**是**不需要对齐的**

>总结：
>当函数运气需要局部存储空间时，栈提供了内存分配与回收的机制。


>在程序执行的过程中，寄存器是被所有函数共享的一种资源。
>避免数据覆盖的问题：所以有通用惯例，如下：

除了寄存器rsp之外，其他如下定义。

![](./images/1716548654284.png)
例子：

![](./images/1716548751817.png)

递归调用的例子：

![](./images/1716548767388.png)

![](./images/1716548818532.png)

## 3-8 数组的分配和访问

基本概念：

char的地址和int的地址概念：
>addr(A[i]) = xa + i (原因char = 1 byte)
>int = 4 byte

![](./images/1716555796764.png)

在C语言中，允许对指针进行运算

例子：

>对指针进行运算时，会根据该指针的引用的数据类型 进行**相应的伸缩**

![](./images/1716560134506.png)
再来一个例子：

对于数组的每一个元素都有两个属性：**1.存储的内容** **2.存储地址**

![](./images/1716566106562.png)
> E[2] = 访问内容
> *（E + 2) = 也是访问内容（理解为 该地址处取数据）（引用）

>C语言的指针其实就是**地址的抽象表述**

### 嵌套数组（二维数组）

![](./images/1716566482678.png)
>行优先排列成一行。

**计算数组元素的地址：**

![](./images/1716566530505.png)
Xd = 起始地址
L = 数据类型T的大小
C = 每个小单元的大小，常数。
i，j = 元素位置（非地址），常数。

例子：

![](./images/1716566649797.png)

**利用汇编代码：**

![](./images/1716566689472.png)
### 定长多维数组的优化

>这个代码是用来计算矩阵A的 第i行 与 矩阵B 的 第k列 的 内积

![](./images/1716566757786.png)
**汇编代码**访问数组元素部分：

>编译器进行了优化，所以会有点晦涩难懂。

![](./images/1716566873549.png)

>首四行是用来计算 3个数组元素的地址：
>1. 数组A第i行的 首个元素的地址
>2. 数组b第k列 的 第一个元素 
>3. 数组b第k列 的 最后一个元素


>然后分别放到不同的寄存器中。引入三个指针，方便阅读。\*Aptr , \*Bptr , \*Bend

![](./images/1716567057686.png)
>接下来就是循环部分的实现：

![](./images/1716567069450.png)
movl = 读取 \*Aptr 的数据
imull = \*Aptr 的元素 与 \*bptr 的元素 相乘
addl = 将乘积结果进行累加，保存到%eax
addq = 对Aptr 移动 4 byte （因为int 是 4 byte）
addq = 对Bptr 移动 64 byte (因为数组B一行元素有16个，每个元素占4个字节，因此**相邻列元素**的地址相差6字节)
cmpq = 判断 Bptr 和 Bend 是不是指向 同一个地址。如果二者不相等，就跳转到L7继续执行。

>其中 addq 是很巧妙的一个设计。

### 变长数组

>C89的标准中，程序员在使用 **变长数组**时 需要使用 malloc 这类函数，为数组动态分配存储空间。
>ISO C99标准中，引入了 **变长数组** 的概念。

图中便是变长数组，它可以作为局部变量，也可以作为函数的参数。

![](./images/1716567504897.png)
>变长数组元素的地址计算与定长数组类似，不同的是多了n。
>需要使用乘法指令来计算 n 乘以 i

![](./images/1716567577147.png)

![](./images/1716567659400.png)


对比二者的方法，就能看到了。

![](./images/1716567915545.png)
## 3.9 结构体与联合体

![](./images/1716568081364.png)
>图中的汇编代码是 将 字段i 的值复制到 字段j 。

![](./images/1716568160085.png)
这个就是读取地址：

![](./images/1716568176087.png)

>重点总结：
>无论是单个变量 还是 数组元素：都是通过 **起始地址** 加 **偏移量** 来访问。

### 地址对齐

>若直观的看，认为只有9字节的空间。但其实是12字节。
>其实是因为系统对于数据存储的合法地址做出了一些限制：
>例如 变量j 是 int 类型，所以它的**起始地址** **必须是 4的倍数**。（重点：是起始地址）

![](./images/1716568291781.png)
地址对齐的原则表格：（重点）

![](./images/1716568376002.png)

另外：虽然可以通过这样来进行9个字节的分配，但是！是无法满足所有数组元素的对齐要求，所以编译器自动的还是会补3个字节（末端）。

![](./images/1716568470763.png)
展示一个结构体的数据对齐

![](./images/1716568666751.png)

>每个白色的框都是为了进行对齐而出现，都是为了**后一个数据的对齐**。


### 联合体

>联合体中的所有字段共享同一存储区域。
>联合体的大小 取决于 它 最大字段的大小

图中，变量v 和 数组 i 都是占 8字节，所以就是8byte。

![](./images/1716568822062.png)
>联合体的一种应用情况就是，我们事先知道两个不同字段的使用是互斥的，那么就可以声明为一个联合体。

二叉树：
内部结点：不含数据，但有指向两个孩子节点的指针
叶子结点：都有两个double类型的数据值

我们事先知道 二叉树的任意一个节点不是 内部节点 就是 叶子节点

我们可以用联合体来定义节点：这样每个节点就只需要16byte的存储空间了。（结构体定义方式 32byte）

![](./images/1716569072967.png)
一个问题，没办法确定一个节点是 叶子 还是内部。
解决方法：引入一个枚举类型，创建一个结构体（包含一个标签，一个联合体）

![](./images/1716569144717.png)

联合体还可以用来访问不同数据类型的**位模式**

当我们使用简答的强制类型转换：强制把 double d 转换为 unsigned long （此时位数差距很大）


![](./images/1716569235381.png)
>将这两个类型的变量 声明 为 一个联合体，
>这样可以以一种类型来存储，以另外一种类型来访问。
>这样就会存在相同的位表示了。

![](./images/1716569269723.png)

## 3-10 缓冲区溢出

>栈帧，会保存程序执行所需要的重要信息：返回地址，保存的寄存器的值等。
>在C语言中，不会做任何的边界检查，如果越界写操作，就会破坏信息。

![](./images/1716601150317.png)

>gets : 标准输入读入一行字符串，在回车或者某错误停止。
>gets 函数 无法确定 是否有 足够大的空间 来保存整个字符串。

>实际分配了24byte的空间。

![](./images/1716601342523.png)
如以下情况，只要输入字符串不超过 23 时，不会发生严重后果。超过以后，返回地址以及更多状态信息就会被破坏。
历史上，缓冲区溢出就是病毒的首要攻击地方。

![](./images/1716601400388.png)

>现代计算机有多个对抗的手段（机制）。

![](./images/1716601470009.png)
### 栈随机化

>之前，程序的栈很容易被预测。因此知道了，就会可以攻击。
>栈随机化的思想：在程序每次运气时都有变化。

如图所示，64 Linux 的随机范围：

![](./images/1716601606175.png)
标准行为：地址空间布局随机化 （Address-Space Layout Randomization，ASLR）

### 栈破坏检测

>**汇编代码**中栈保护者的机制检测缓冲区越界。
>就是缓冲区与栈保存的状态值 之间 存储一个 特殊值 ： 金丝雀值(煤矿工人判断有毒气体含量)
>金丝雀值是**随机产生的**

![](./images/1716601821473.png)
看看例子如何避免栈溢出攻击：

![](./images/1716601837390.png)
movq %fs:40（内存地址，只读段） %rax 
movq %rax 8(%rsp)

图中两行代码内存中读取一个数组，该数组放到栈上（金丝雀值）

函数范围之前，通过xor来判断金丝雀值是否被更改，

### 限制可执行代码区域

![](./images/1716602029022.png)
内存保护引入了不可执行位：将可读和可执行 访问模式分开了。
这样就可以标记为可读，可写，但不可执行。

# 第四章 处理器体系结构

### 指令系统结构

Instruction Set Architecture 指令系统结构

程序员根据指令系统设计软件；处理器设计人员根据指令系统实现硬件。

X86太复杂，所以参考这个，自定义了一个Y86-64

### Y86-64 指令集体系结构(重点)

>程序员：汇编代码写程序的人 / 机产生机器级代码的编译器
>可见状态：每条指令都会去读取或者修改处理器的某些部分
>例如：内存，寄存器，条件码，程序计数器，程序状态等。

![](./images/1716602562696.png)
> %rsp 栈指针。
> 程序计数器PC = 保存当前执行指令的**地址！**
> 状态码 = 程序状态

X86-64 的 movq 指令 简化，分成四种不同的指令：

>直接通过movq前缀就知道源操作数和目的操作数：
>r = register
>i = immediate
>m = memory

![](./images/1716602831366.png)
**编码：(重点)**

> 第一个字节：表明指令类型。其中：
> （高）4bit = 指令代码 Instrction code
> （低）4bit = 指令功能 instrction function
> 第二个字节：当有寄存器类型的操作数时，这个会附上。：寄存器指示符字节。
> 

![](./images/1716602970821.png)
>寄存器的编号：
>其中：**用F就是此处没有寄存器操作数。**

![](./images/1716603121364.png)

四条整数操作指令，只能对寄存器数据操作（X86能对内存数据操作）：

>除了功能部分，其他都相同。

![](./images/1716603261204.png)

跳转指令一共有 7 条：
>也是根据**条件码的某种组合**来判断是否进行跳转

![](./images/1716603297176.png)

条件传送指令 6 条：

>与数据传送指令 rrmovq 有相同的指令格式。
>只有条件码满足条件时，才会更新目的寄存器的值。

![](./images/1716603345104.png)


halt 系统暂停运行
nop 空指令
call 函数调用
ret 返回
push 入栈
pop 出栈

![](./images/1716603440281.png)

>以上就是Y86的规则。

我们可以将 Y86-64 的汇编代码翻译成 **二进制** 表示：

![](./images/1716603617356.png)
根据规则：

![](./images/1716603630386.png)
首先，第一字节的 4 ，0 直接写入。
其次：第二字节的 rA ，rB 对应 %rsp , %rdx ，查表可得。 4 与 2.
最后：偏移量有 8byte，需要补齐才能放入。同时X86用的是**小端法**，最小的放最前。

![](./images/1716603722508.png)
最终得：

![](./images/1716603641331.png)
### 状态码

1.AOK 没问题
2.HLT 执行了暂停 
3.ADR 程序在试图 从 非法地址读取数据 / 非法地址写入数据
4.INS 遇到非法指令

![](./images/1716603838327.png)

### 4.2 数字电路与处理器设计

> 寄存器的集合称为**寄存器文件（一切皆为文件）** 或者称 **寄存器堆**

>在CPU内部，寄存器文件和算术逻辑单元（ALU）是**串联**的
>寄存器的输出端口，与ALU的输入端口相联。

![](./images/1716604991371.png)
以寄存器文件为例，解析它的具体实现，阐述CPU设计与数字电路之间的关系。


### 寄存器文件

>有一个读端口（d_out) 和 一个 写端口(d_in) ，数据位宽 64 位
>读写操作共用地址线(addr)，定义了15个程序寄存器，所以4位即可。
>时钟信号(clock)，复位信号(reset)，写使能信号(we_)

![](./images/1716605076758.png)
>可以使用硬件描述语言（HDL） 对寄存器文件进行 **行为级建模**
>通常的硬件描述语言： Verilog ， VHDL

图中：Verilog 程序就是对 寄存器文件的描述。

![](./images/1716605336076.png)
采用 电子设计自动化（EDA） 工具对这段程序进行 逻辑综合。

![](./images/1716605413015.png)

#### 寄存器文件的内部结构

当执行读取操作，使用地址线来存储寄存器的编号。
**多路选择器**根据地址信号筛选出寄存器的值。
最终数值通过输出信号输出。

>红色线：时钟信号，白色线：复位信号（后续观看暂时省略掉）

![](./images/1716605541477.png)

>执行写操作需要确定三个参数：1.目的寄存器ID，2.写入的数据，3.是否能够写入
>说白： 能不能写，往哪儿写，写什么！

>能不能写：看**we信号**（write enable）
>写什么： 看**data信号**
>这个例子中地址信号线是 读操作 和 写操作 共用的。
>往哪儿写：**地址解析后的信号** 和 **we信号**

图中便是比较详细的寄存器描述。

![](./images/1716605770290.png)
>还是存在一些疑问：
>1.多路选择器是怎么实现的？
>2.虚线框里的寄存器又是如何存储数据的（我感觉在CCCS中看过，和与或非门有关（就在第6集（寄存器与内存）中）

番外内容：(锁存！)

![](./images/1716606118416.png)

![](./images/1716606169224.png)
允许写入线，让门锁打开，就可以写入数据。关闭后，就可以保存数据了。(Memory!)

![](./images/1716606211415.png)

### 逻辑门


>逻辑门是数字电路的基本计算单元。
>与，或，非门。
>输出 = 输入值按位进行相应的布尔运算。
>逻辑门 由 晶体管级电路实现的。


![](./images/1716606427251.png)
>在现代计算机中，晶体管通常是指基于CMOS（Complementary Metal-Oxide Semiconductor，互补金属氧化物半导体)工艺的。
>两种晶体管，一种N沟道MOS晶体管，简称N管
>另一种叫 P沟道 MOS 晶体管，简称P管。


![](./images/1716606621557.png)
P管 N管 串联起来实现 非门。
二者 漏极 连接 作为输出。
栅极 连接 作为输入。
P 管的源极 接 电源。
N 管的源极 接 地。

![](./images/1716606650761.png)

![](./images/1716606756647.png)


![](./images/1716606766255.png)
在CMOS工艺中，与门 和 或门 不如 **与非门** 和 **或非门** 高效。

![](./images/1716606808021.png)
### 多路选择器/多路复用器 Multiplexor

>最后一个逻辑门画错了，应该是OR的逻辑门。

![](./images/1716606831040.png)

通过情况下，寄存器文件内的存储部件是由**D触发器**实现的。

![](./images/1716607015338.png)
D触发器的门级实现：

![](./images/1716607035992.png)

目前，电路的逻辑设计通常采用硬件描述语言来实现，然后采用电子设计自动化（EDA）工具进行综合和后端设计。

### D触发器的Verilog实现。


>dfilpflop表示模块的名称，D,C,G = 输入， Q = 输出。
>always = 当时钟C 上升的时候，if G = 1 ，就把 输出Q = 输入D的值 ，否则不变。

![](./images/1716607238937.png)
Verilog 是**并行执行**， C程序是 **串行执行**的。

Verilog 语言需要知道这个。

![](./images/1716607301419.png)
Verilog 做设计只用三种语句：

![](./images/1716607346602.png)
## 4-3 Y86-64 的顺序实现

Y86-64的规则：

 ![](./images/1716651048429.png)

例子：

本代码：计算数组的元素之和。

![](./images/1716651169431.png)
除了数据传送指令，其他的指令于X86指令差异不大。

Y86汇编器，图中汇编代码翻译称二进制指令。

![](./images/1716651281694.png)
>实现所有Y86指令所需要的计算 = 6个基本阶段
>：**取值，译码，执行，访存，写回，更新PC** （重点）

![](./images/1716651367934.png)

### 取值阶段 Fetch

>所有指令都是需要的。
>还会根据指令代码来判断指令是否含有寄存器指示符。是否含有常数，从而计算出当前指令的指令长度。

### 译码阶段 Decode

>从寄存器种读取数据。
>寄存器文件有两个读端口，可以支持同时进行两个读操作。

![](./images/1716651717241.png)

### 执行阶段 Execute

> 算术逻辑单元ALU 主要执行三类操作。
> 1.执行算术逻辑运算
> 2.计算内存引用的有效地址
> 3.针对push 和 pop 指令。

![](./images/1716651773852.png)

### 访存阶段 Memory

>对内存的读写操作
>既可以从内存读出数据，也可以数据写入内存。

![](./images/1716651872764.png)

### 写回阶段 Write Back

> 此阶段于译码阶段类似，都是对寄存器文件的操作。
> 不同：译码阶段是 **读**寄存器文件，写回阶段 是**写**寄存器文件

### 更新PC  Update

>将PC设置成下一条指令的地址。


### 例子1：减法指令
通过例子来看看操作：

本次例子为减法指令。

![](./images/1716652648452.png)
>取值阶段，valP = PC + 2 （2是因为长度为2）
>译码阶段，根据寄存器指示符，读取寄存器的值
>执行阶段，执行具体运算，set CC（条件码寄存器）
>访存阶段，不需要读取内存
>写回阶段，把数据写回寄存器文件夹中。
>更新PC，PC移到下一个指令。

![](./images/1716652977609.png)
### 例子2：数据传送指令irmovq

>i = 立即数 r = register 寄存器
>操作：将一个立即数 传送给 寄存器

![](./images/1716653184743.png)
>注意：执行阶段 使用ALU 对 常数进行加0

![](./images/1716653324445.png)
### 例子3.指令pushq

![](./images/1716653533396.png)

![](./images/1716653717155.png)

### 例子4：跳转指令je

![](./images/1716653746672.png)

>执行阶段： cond的硬件单元会根据**条件码 CC**和**指令功能 ifun**来判断是否执行跳转。
>这个模块产生一个信号Cnd 。 cnd = 1 跳转； cnd = 0 ， 不执行跳转；

![](./images/1716653898872.png)
## 4-4 Y86-64处理器硬件结构

### 取值阶段

>以程序计数器（PC）的值作为起始地址。
>每次从指令内存中读取10个字节。：在取之前无法判断当前指令的长度。取10个可以保证获取一条完整的Y86-64指令。

![](./images/1716654678313.png)
然后分层两部分：

![](./images/1716654701758.png)
>Instr vaild = 判断这条指令是否是一条合法的指令
Need regids = 是否包含寄存器指示符
Need valC = 是否包含常数字节
通常看第一个就已经可以判断 指令长度了。
下一条指令的地址：通过当前PC值 + 当前指令的长度计算出来。


![](./images/1716733473658.png)
>Align单元：
>可以产生 寄存器字段rA,rB 和 常数字段valC
>当need_regid = 1 ，该指令包含寄存器指示符字节。
>那么第一字节将被分层两部分，每一部分占 4 bit，分别转入 rA，rB
>当 need_regid = 0 ， 没有 寄存器指示符。
>此时 rA，rB = 0xF。
>当只含有1个寄存器操作数，另外一个字段 = 0xF

![](./images/1716733808099.png)
>如果含有常数，align单元还产生 常数字段valC
>当 need_regids == 1 ，2~9字节 = valC
>当 need_regids == 0 ， 1~8 字节 = valC


![](./images/1716733875204.png)

### 译码阶段

>寄存器文件：两个读端口(srcA,srcB)，读出输出（valA,valB)
>下面的srcA，srcB -> 产生寄存器的ID值
>iCode 是 指令方式（有些代码需要读取%rsp（栈顶指针)（右边的指令，只含有目的寄存器）

![](./images/1716734254267.png)

### 执行阶段

>算术逻辑单元，ALU
>条件码CC = ZF（零），SF（符号），OF（溢出）
>根据ifun（指令功能） 来 判断 进行何种计算。

![](./images/1716734546796.png)
### 访存阶段

>从内存中读数据，或者写入数据。
>读控制块，写控制块
>产生内存地址，输入数据的控制块。
>注意：最后，会根据信号来计算状态码stat

![](./images/1716734587182.png)
### 写回阶段

>将数据写入寄存器文件。
>写端口：M，E ，对应地址输入 dstE dstM
>写入操作要根据 执行阶段的 cnd信号：不满足条件，目的寄存器设置0xF 来禁止写入寄存器文件。

![](./images/1716734629348.png)
### 更新PC

>四种情况：
>1.call Dest ——> 新PC = call指令的常数字段
  2.ret ——> 在访存阶段会从内存（栈）中读出返回地址，新PC值 = 返回地址。
  3.jxx Dest（跳转） ——> cnd信号 = 1（满足跳转条件） 新PC = 常数字段
  4.Other Instructions ——> 新PC = 当前PC的值 + 当前指令长度

![](./images/1716734801827.png)

![](./images/1716735210116.png)


>指令执行速度太慢了，需要流水线。

## 4.5 流水线的通用原理（重点）

未流水化的硬件设计

三条程序顺序摆放，就可以得到流水线。

![](./images/1716802433932.png)

>电路的延迟 = 皮秒ps = 1 X (10)^(-12) （秒）
>延迟 = 一条指令从开始到结束的时间

### 吞吐量

>GIPS 每秒千兆条指令

![](./images/1716802510068.png)
>电路设计中，需要注意的是寄存器 
>其中：时钟信号 直接将它的 输入 和 输出 连接到电路中，
>寄存器输出就是寄存器的状态值。
>但输入时，会受到时钟信号的影响，当时钟 低电平，不会立即 发生变化，只有在 高电平 时 才会发生变化。

![](./images/1716802878396.png)
### 流水化

时钟周期设置 120ps，那么这个代码就需要 3个完整的时钟周期。
图中：comb.Logic 组合逻辑单元

![](./images/1716802928731.png)


![](./images/1716803139596.png)

### 流水线计算的时序和操作

>指令在流水线各个阶段的**转移**是由 时钟信号 来控制的
>每隔120ps，信号从0上升1，流水线开始下一个阶段的计算

指令1用青色表示，指令2用金色表示，指令3用蓝色表示

![](./images/1716803504753.png)

![](./images/1716803552518.png)

![](./images/1716803568086.png)

![](./images/1716803577176.png)

>用我的理解和话语来讲：闯关游戏。
>每个Comb.Logic都是一个关卡，而reg是中场休息关，然后这些之间的位置就是门。图中所画的就是门。当时钟信号 = 1时，这些门就会开，这样就可以到reg里，当时钟信号 = 0 ，这些门会关闭。
>抽象的说：只有门开了寄存器才会记录。才会移位。


上述只是理想化的情况，在现实中，个个延迟都不等。

![](./images/1716803846398.png)

![](./images/1716803881374.png)

>过多流水线也会导致系统性能的下降

![](./images/1716803919725.png)
### 数据依赖 / 数据相关

![](./images/1716804009804.png)

### 控制依赖

>跳转指令。

![](./images/1716804035007.png)
在顺序结构中，这些相关是通过反馈来解决的。
不过，反馈路径是很危险的。

![](./images/1716804113850.png)

## 4.6 流水线硬件结构


### 顺序结构：
>取指阶段：
>iCode = 指令代码 4 bit
>ifun = 指令功能 4 bit
>valC （常数字段）= 8 字节
>PC Inc = PC增加器
>valP = PC 加上当前指令的长度。
>
>译码阶段：
>Reg File 寄存器文件 ——> A,B 两个读端口
>
>执行阶段
>ALU 根据 ifun 来进行运算
>valE = 计算结果
>CC = 条件码
>Cnd = 信号（用于影响跳转）
>ALU除了算数，还要计算访存的有效地址，以及针对栈指针的运算（+8,-8的操作）
>因此：ALU的输出端口会与数据内存的地址逻辑单元相连。
>
>访存阶段
>valP ——> Data  错了，应该是 valC ——> Data 
>写入内存，读取内存。
>写入的数据 可以由 寄存器文件 提供， 也可以是 指令中的常数字段（valC）
>
>写回阶段
>寄存器文件有两个写入端口M，E
>valE ——> E, Memory ——>
>
>更新PC
>根据 当前执行的指令 以及执行的状态来进行 判断。
>iCode，Cnd（跳转），valC



![](./images/1716804657941.png)
### 电路重定时

改进：**电路重定时** 改变了系统的状态表示：更新PC在开始的时候执行。

![](./images/1716804752202.png)


### 顺序结构 ——> 流水结构


顺序结构：
![](./images/1716804801313.png)

流水结构：
![](./images/1716804790783.png)
#### 五级流水线的硬件结构

> 第一个寄存器F：
> predPC PC预测值


![](./images/1716804938054.png)

## 4.7 数据冒险

### 代码示例流水线情况：

> F:Fetch(取指) D:Decode(译码) E:Execute(执行) M:Memory(访存) W:Write Back(写回)

时间从左到右变大，在 第 5 个 时钟周期时，整个流水线中同时在执行5条指令。通常都会用这个流水图来表示流水的状态。

![](./images/1716815996511.png)
### 数据冒险/冲突

在这个示例中：指令irmovq 和 指令 addq 之间存在 数据相关。
addq需要前两个指令结束后的数据结果。
但是按照流水线，第一指令还没在访存阶段，还没写回，第二指令在执行阶段。
因此addq 就变成了 0 + 0 的情况了。

如果这种 数据相关 导致了 流水线产生错误的结果 ——> 数据冒险/冲突


![](./images/1716816614917.png)
**避免冒险：**

>法一：
>先暂停addq指令，等指令1和指令2执行完，再执行addq。
>思考：需要判断什么时候执行暂停，如何实现暂停，还有暂停多久。
>方法：指令在译码阶段读取寄存器时，通过读取寄存器的ID值分别与**执行阶段（E）**，**访存阶段（M）** 以及 **写回阶段（W）** 所执行指令 的 目的寄存器进行对比。如果存在相等，数据存在相关。
>此时就插入气泡bubble。

![](./images/1716817158988.png)
法2：直接把运算结果传给addq指令（**数据转发，旁路**）

irmovq在 访存是没有执行任何东西的。

![](./images/1716817215062.png)
多加了两个**逻辑块**。

![](./images/1716817289265.png)
还有一类数据冒险不能单纯的使用转发来解决。

>这个mrmovq 需要读取内存空间
>这个时候就需要结合 暂停 和 转发 一起了。

![](./images/1716817489285.png)

>重点总结：解决冒险的方法：暂停（Bubble)、转发(旁路）。

## 4.8 控制冒险

### 控制冒险发生

在流水线设计中，我们期望每个时钟周期都能完成一条指令的执行。
流水线在每个时钟周期都要取到一条指令。
因此每次取指操作后，必须马上确定下一条指令的地址。

情况一：
当取出的指令是**返回指令ret**。
下一条指令要在栈中读出，
必须 **访存操作（M）** 结束后才能确定下一条指令的地址。

情况二：
取到的指令是**分支条件指令**。
跳转操作的判断，这一部分需要经过**执行阶段（E）**，才能确定是否进行跳转。

![](./images/1716817895753.png)
### 示例代码：返回地址ret指令
白色字为地址。
第一个 irmovq 初始化栈指针
call 函数调用

![](./images/1716817969524.png)
根据指令的执行顺序：

通过暂停来避免（Bubble）

![](./images/1716818112399.png)
### 示例代码：跳转指令 jXX指令

避免控制冒险（Avoiding Control Hazards）

>假定一个策略：**分支预测（Branch Prediction）**

![](./images/1716818267568.png)
示例代码：

![](./images/1716818254037.png)
if 当遇到分支，总是执行：

>情况：首先让irmovq $2 和 irmovq $3 跟着流水线进去了。
>结果当jne到 执行阶段（E）发现是不用跳转的。
>就对刚刚两个指令当前阶段进行插入气泡，把他两个剔除（并非暂停）。

![](./images/1716818455839.png)
### 暂停和插入气泡如何实现

>流水线寄存器，是通过 **时钟的上升沿** 来改变输出的值。
>设置暂停信号和插入气泡信号，就可以实现了。
>当暂停值 = 1，寄存器保持以前的状态（一直）。
>气泡信号，寄存器状态 = 某个固定的复位配置 等效于 nop 状态。

![](./images/1716818820803.png)

假如：寄存器E中插入气泡，那么就：
在寄存器E中的iCode 字段 = INOP
dstE = dstM = srcA = srcB = RNONE
这样就达到与指令NOP一样的效果。

![](./images/1716818945399.png)

>重点：
>返回指令ret ——> **访存阶段（M）** 后，用的是**暂停**
>跳转指令jxx ——> **执行阶段（E）** 后，用的是**分支预测**。
>控制冒险的处理方法：流水线插入**气泡来解决**。

## 4.9 Y86-64的流水实现

### 取值阶段

>最复杂的地方：如何预测下一条指令的地址（Next PC Prediction）
>指令地址无非就两种情况： 1.顺序执行，2.跳转执行
>顺序执行：valP = 当前指令的地址 + 当前指令的长度
>跳转执行：跳转：直接将 **常数字段（valC）** 作为下一条指令的地址。
>实际分支预测的效果很复杂。
>ret难以预测，不会尝试对返回地址做预测。因此放到顺序执行方面。
>PC预测逻辑单元会根据指令类型（icode），来预测下一条地址是 valP / valC


![](./images/1716821166016.png)
#### 纠错部件(PC Select PC选择逻辑单元)


>改正的方法：读取信号
>W = 寄存器W（写回），M = 寄存器M（访存）
>ret指令：
>W_icode （指令类型）：如果是判断出ret指令，则 PC = W_valM
>W_valM (访存结果) 
>
>跳转指令：
>M_icode
>M_Cnd(跳转信号)
>M_valA(下一条指令的地址)

![](./images/1716821641711.png)


### 译码阶段(重点)

>数据转发的机制
>主要根据寄存器ID 从 寄存器文件 中读取数据
>寄存器ID = rA ， rB ，经过srcA 和 srcB 逻辑单元输入到 寄存器文件
>最终译码的结果 = valA ，valB
>提高流水线效率，引入 **数据转发** ： Sel + Fwd A , Fwd B
>判断的依据：当前需要读取寄存器的ID值 = 转发目的寄存器的ID值 ？
>其中：e_detE , e_valE , M_dstE , M_valE , M_dstM , M_valM, W_dstM,W_valM,W_dstE,W_valE
>E = 执行 / 寄存器E，M = 访存 / 寄存器M，W = 写回 / 寄存器W 。
>其中白色是寄存器ID值，红色是转发数据
>如果不满足上述所有的转发条件：
>选择从寄存器文件的 **A端口** 读出的数据作为输出。
>Sel + Fwd A 逻辑单元扮演了两个角色： 多了valP的输入（比起 Fwd B），实现了valP valA 信号的合并功能。
>valP表示 顺序执行时，下一条指令的地址，valA 寄存器文件中读到的数据。
>只有在 函数调用指令 和 跳转指令 在后面阶段才需要用到valP
>这两类指令 并不需要 从寄存器的A端口读取数据。
>所以可以根据 指令代码 icode 来判断当前指令 是否属于这两类。


![](./images/1716822291275.png)

## 4.10 流水线的控制逻辑

处理流水线的冒险以及异常情况，我们需要在设计中添加 控制逻辑单元（Pipeline Control Logic）。

### 加载/ 使用 冒险

>顺序出现，二者出现 数据相关
>mrmovq 和 pop 都有机会。

![](./images/1716877182872.png)
>mrmovq 在执行阶段，而 addq 在译码阶段的时候：
>mrmovq 进行完访存阶段，然后把数据转发给addq中。
>具体解决方法： 保持流水线寄存器F，D的状态不变，E插入一个bubble。

![](./images/1716880388848.png)


### 分支预测发生错误

> 跳转指令达到 **执行阶段**时 可以检测到 **预测错误**
> 下一个时钟周期 需要取消两条已经取到的指令。
> 具体的解决方法： 向流水线寄存器D和E 中插入气泡。

![](./images/1716880496663.png)
### 返回指令的处理

> 指令ret 需要经过 译码，执行，访存阶段之后才能读到下一条指令的地址。
>具体实现方法：插入三个bubble，浪费掉三次的时间周期。

![](./images/1716880571788.png)

>控制逻辑操作 = 出现特殊情况时 ： 通过 **暂停** 和 **插入气泡（清零）**

### 组合特殊情况

#### 返回 + 跳转

> 假设 ZF = 1 ，不发生跳转，则应执行irmovq。
> 而流水线代码在跳转时 保持 “一定跳转” 的情况。
> 所以就会发生图中的情况，ret 已经到了decode阶段。
> 此时就需要把F stall ， D和 E 插入一个Bubble，把ret 清零，
> 然后jne 所做出来的M寄存器会有 下一个PC的地址，给到Fetch阶段即可。

![](./images/1716880864227.png)
#### 加载 / 使用冒险 + 返回指令

> 其中：加载 目的寄存器是 %rsp
> 返回 默认使用的也是 %rsp

>图中对两种指令的情况都做了控制，显然是不合理的。
>对这种组合需要进行特殊的处理。

![](./images/1716881209561.png)
### CPI（一条指令的时钟周期数） —— Cycles Per Insturction

Cb/Ci  = 惩罚项 （一条指令平均要插入多少 bubble）
lp = load penalty (加载/使用冒险暂停时插入气泡平均数)
mp = mispredicted branch penalty （分支预测错误取消指令时 插入气泡的 平均数）
re: return penalty (返回指令 造成暂停的 插入气泡的 平均数)

![](./images/1716881481322.png)

![](./images/1716881544950.png)
# 第 五 章 优化程序性能

1. 选择合适的算法和数据结构
2. 编译器的能力和局限性
3. 探索并行化

![](./images/1716881713767.png)

## 5.1 优化程序性能（一）

> add1 需要执行 6 次 内存引用: 两次读xp指向的内存位置，两次读yp的内存位置，两次写xp的内存位置
> add2 3次，1次 读xp指向的内存位置，1次 读 yp ，一次写xp

![](./images/1716882120257.png)
>但存在问题：所以不能轻易的用
>If xp 和 yp 指向同一个内存位置，就会出现以下情况：

![](./images/1716882214712.png)
>妨碍优化的因素：内存别名引用，函数调用

### 内存别名引用

> 内存别名引用 ——> 两个指针指向同一个内存位置

图中上方的是不同指向，下方是相同指向。

![](./images/1716883874556.png)
### 函数调用

> 虽然func2 效率更高，但是根据 f() 的情况，
> func1 调用了四次，而func2 只调用了一次。
> 其中注意： counter++ 是最后才进行+1，所以func2 = 0

![](./images/1716884200721.png)
>所以需要程序员花费更多的精力来编写高质量的代码。

### 如何表示程序的性能

> 对于一个向量a 包含 n个元素， n 是一个变量
> 计算出向量a的前缀和(the prefix sum)，保持到向量p中。


**前缀和：**


![](./images/1716884472419.png)
**实现计算前缀和：**

![](./images/1716884520680.png)
**更加高效的实现方法**：psum2 一次迭代可以计算出两个元素的值。

![](./images/1716884558313.png)
> 这种技术叫做 ： **循环展开**

**对比 psum1 和 psum2的性能：**

横坐标：元素的个数
纵坐标：时钟周期数

6 和 9  = 线性因子。 

![](./images/1716884693800.png)
>CPE ——> **每个元素**执行所需要的周期数。
>psum 1 的 CPE = 9.0 （线性因子）
>psum 2 的 CPE = 6.0 （线性因子）

## 5.2 优化程序性能（二）
如何优化程序的性能

### 向量的抽象数据类型

>两个内存块： 头部 Header 和 数组 Data

头部声明为结构体（如图左边表示）
len = 向量的长度
data_t 向量元素的数据类型

![](./images/1716884886390.png)
### 代码示例1（对向量的所有元素进行求和/求积）：

![](./images/1716885043157.png)
>vac_length 向量的长度
>get_vac_element 获取向量第 i 个元素的值，结果保存到变量 val 中。


其中，评估是通过CPE来进行，所以数值越小越好。

![](./images/1716885313640.png)
#### 如何优化代码：

>每次for ，都得调用 vec_length(v)。但实际上在运行时，该长度不会产生变化。

![](./images/1716885373324.png)
>因此再执行循环前，先调用，把数据给局部变量 length 就可以了。
>之后就不会继续调用了。
>这个方法就是：**代码移动**

![](./images/1716885403233.png)
修改后：

![](./images/1716885489240.png)
### 代码例子2：把字符串 所有大写 转成 小写

>同样使用了 **代码移动**。

![](./images/1716885598840.png)
随着string 长度增加，很明显能看到性能的变化。

![](./images/1716885617303.png)

>一个很小的场景，就能导致非常大的性能变动，因此有经验的程序员应该避免这类问题。

### 继续例子代码1的情况

如果把代码一中的get_vec_element 也优化了，也许会有提升？

![](./images/1716885757059.png)
引入新的函数get_vec_start ，它可以返回数组的起始地址：


![](./images/1716885777385.png)
最后for里面就只有 采用直接访问数组的方式来获取向量的元素。

性能：发现性能没有提升，甚至性能还有所下降了、

![](./images/1716885896848.png)
> 推断：循环中可能存在其他的限制因素，性能的限制超过了函数调用。因此消除了函数调用，也没啥用。

找出限制因素，看 **combine3** 的 汇编代码：

![](./images/1716886044488.png)
>可以看的出来，每次迭代时，累积变量的数值都要从内存中读出，然后再写入内存。
>涉及两次读内存，一次写内存的操作。

消除不必要的内存引用，引入临时变量acc

它用来记录累积的结果，直到循环结束后，再把结果写回目的地址。

这样一来，每次迭代只需要一次读内存操作

![](./images/1716887519260.png)

CPE 情况：登登！ 显著的提高！
而在CSAPP中，combine3用了compiled -O2 编译选项来优化，可以得到combine4 相关的效果。

![](./images/1716887505534.png)
问题：
究竟有什么因素制约着代码的性能？
程序的性能还能进一步提高吗？
——> 处理器角度看看。

>总结： 
>1.降低函数调用的开销
>2.消除不必要的内存引用

## 5.3 理解现代处理器

如果想要继续提升性能，必须考虑利用处理器的微体系结构来进行优化。

第四章总讲述流水线的实现，但实际上现代CPU的内部结构要复杂的多，它能够同时执行多条指令。—— **指令级并行**

整体设计主要分为两部分： **指令控制单元（ICU）** 和 **执行单元（EU）**

指令控制单元 负责从 内存中读取指令序列，然后对指令进行译码，从而产生一系列的操作。


![](./images/1716899787585.png)
一个例子说明一下：

![](./images/1716900929474.png)
源操作数和目的操作数都是寄存器，因此这指令会转化成  加法操作。

![](./images/1716900940786.png)
包含 内存引用 和 算术运算 时 ，图中这加法指令会被 译码成 三个操作：读操作，写操作，加法操作。

读操作： 从内存中读取数据到CPU中
加法操作：从内存中读到的数据 与 寄存器中的数值 进行相加
写操作： 加法运算得到的结果写回到 内存里

分解，允许任务在一组专门的硬件单元之间进行分割。
读操作：由加载单元来执行
写操作：由存储单元来执行
——> 处理器的执行单元就可以并行的执行多条指令的不同部分

> 现代处理器每个 时钟周期 可以执行多个操作，且是 **乱序执行**的
> 代表：允许指令的执行顺序与 原始的顺序不一致。

>当执行遇到分支：
>1.选择分支 2.不选择分支。
>现代CPU 采用 分支预测技术 进行猜测 是否分支 和 预测 目标地址。
>甚至不确定分支预测 是否正确之前就开始 执行这些指令
>
>如果之后发现预测错误，就会状态重新设置到分支点之前的状态。
>开始执行另外一个方向上的指令—— **投机执行**（词）


![](./images/1716901901308.png)
图中，分支逻辑单元 是用来 确定分支预测是否正确，并非是确定分支该往哪执行。
如果执行错误，执行单元会丢弃分支点之后计算出来的结果。
执行单元发信号给分支单元，预测是错误的，指出正确的分支。
此时，分支逻辑单元在新的位置取指

### Intel Core i7 （不考，可以了解）

该处理器有 8个功能单元，编号0~7

![](./images/1716902069598.png)
编号1的单元： 整数运算（加法，位级，移位），整数乘法，浮点数的加法和乘法。

处理器有 4个功能 单元可以执行 整数运算。（单元0，1，5，6）


#### 算术运算性能：

>三个名词：延迟（Latency)，发射(Issue)，容量(Capacity) (名词)
>延迟：完成运算所需要的总时间
>发射：两次运算之间**间隔**的  最小时钟周期数。（前运算可以未运算完成）
>容量：执行该运算的**功能单元数量**。


![](./images/1716902443622.png)
对于除法运算，它的发射时间 = 延迟，这意味着，在开始新的一条新运算时，除法器必须完成整个除法。（除法依赖 除数和被除数）

### 退役单元

包含寄存器文件，同时控制寄存器的更新。
指令在译码时，指令相关的信息被放置在一个 先进先出 的队列中。这些信息会一直保留，直到发生两个情况：
1.指令操作完成，所有分支点 = 正确，这指令就可以退役。对程序寄存器的更新可以执行了。
2.如果指令某个分支点错误，这指令不应该执行。那么这条指令会被清空，丢弃所有计算出来的结果。

## 5.4 数据流图

延迟界限，吞吐量界限的CPE值（每个元素的时间周期数（越小越好））

![](./images/1716902981592.png)
>由于CPU 只包含一个整数乘法器，发射时间 = 1 时钟周期
因此CPU 不可能支持每个时钟周期 大于 1 条乘法的速度
理论上每个周期有可能执行4个 整数加法 的操作。
但是要读取内存，所有限制了。
两个加载单元 限制了 CPU 每个 时钟周期 最多能够读取 **两个数据值**。
使得 吞吐量 = 0.5。


![](./images/1716903205607.png)
拿出之前combine4的性能指标，可以看到几乎差不多。
它表明了 函数的性能是由 所执行的 求和 或者 乘积 计算来决定的。
（就相当于，时间复杂度是按照最大的值来决定的意思）

### 数据流图
>图形化，能展示不同操作之间的 **数据相关** 如何限制他们的**执行顺序**
>这些限制 形成了 **性能关键路径**。

combine4 的代码，主要是 循环 影响性能。

![](./images/1716903357034.png)
图中的循环编译出的代码 如下：


![](./images/1716903560734.png)

>其中**%rdx** 存放 指向数组data 的 第i个元素的指针。
>**%rax** 存放 指向数组末尾的指针。
>（记得，内存地址是从低到高的，所以第一数组在最底方）
>**%xmm0** 存放 累计值acc 
>每次进行乘法累积，运算结果会 存放 到%xmm0中


图：

顶部 = 循环开始时寄存器的值
底部 = 最后寄存器的值

![](./images/1716903669456.png)
> 循环开始的第一条指令 vmulsd 被分为 load（加载）操作，和mul(乘法)操作
> mul 执行乘法运算，放到%xmm0中
> add 成果写回 %rdx 
> cmp 检测 %rax和 %rdx 是否一致。
> jne 按照条件码寄存器 来决定循环是否继续。


寄存器可以分为四种：
1. 只读寄存器 Read-only
	- 这些寄存器在循环中不会被修改
	- 例：%rax 它始终指向数组的结束位置。
2. 只写寄存器 Write-only
	- 数据传送的目的寄存器
3. 局部寄存器 Local
	- 循环内部 被修改和使用，两次不同的迭代之间是**不相关的**。
	- 例：条件码寄存器。（ZF,SF,OF)
4. 循环寄存器 Loop
	- 即是源寄存器，也是目的值。
	- 一次迭代产生的值 会在 另一次迭代中得到。
	- 例： %rdx %xmm0

> 循环寄存器之间的操作链 成为了限制程序性能的关键因素。

**进一步改进：**

目标：只保留影响程序执行时间的操作 以及 **数据相关**的部分。

由于比较操作 和 分支操作 不直接影响程序的数据流，也去掉（%rax也是）。

![](./images/1716907553886.png)
这个就抽象看成模板，这个模板进行N次复制，便能获得 函数combine4 内n次迭代的数据流表示。

![](./images/1716907618859.png)
>图中可以看到，程序有两条数据相关链。
>1.mul操作 对 程序值acc的修改
>2.add操作 对 data+i 的修改
>（ acc 和 data + i ）是上述高级语言中的。

假设： 
浮点数乘法的延迟 为 5 时钟周期
整数加法延迟 = 1时钟周期

左边的链 会成为 关键路径，需要 5n 个 时钟周期 的执行时间
右边的链 只需要 n 个时钟周期 就能完成。

所以左边的链 是 **制约性能的关键路径**

combine4 的CPE 测试 = 1.27
左边和右边形成相关链来预测的CPE = 1.0

所以实际上的测试值 比 预测值 要慢一些。

>一个问题：
>数据流表示的关键路径 所提供的只是 程序执行周期数的下界。
>还有一些其他因素会限制程序的性能。

例如：可用的功能单元的数量 以及 功能单元之间能够传递数值的数量。


## 5.5 循环展开

在5-1的视频中，提到过向量前缀和的计算问题，其中函数psum2就运用了 **“循环展开”**
每次迭代可以算出两个元素的值。

![](./images/1716908447102.png)
>循环展开(Loop Unrolling) 可以两个方面提升程序的性能
>1.减少与程序结果无关操作的数量
 例如 迭代次数减半，循环索引的计算 以及条件分支 操作都会减少
>2.减少整个计算中关键路径的操作数量

### 函数combine5 使用2X1的循环展开

>2 = 每次迭代处理两个数据元素
>每次迭代循环的索引值 i 需要加2

![](./images/1716908663917.png)
>由于每次处理2个数据，如果数组并非是2的倍数，那这函数会超过数组界限。
>因此需要用图中的方法，解决循环越界的问题。
>对于长度为n的向量
>limit = 保证循环索引值 i 小于 n-1 时才会循环。
>最大的数组索引值 i + 1 = n

![](./images/1716968985076.png)

性能提升：

![](./images/1716969201198.png)

整数下降了，其他的已经达到延迟界限。
就算在加 3X1 的迭代，也无法继续减低CPE。

无法超越界限的原因：

![](./images/1716969349391.png)
> 第一指令: data[i] 加到 acc 上，
> 第二条指令： data[i+1] 加到 acc上
> 第三条指令：循环的索引值i在%rdx中，每次循环执行+2操作
> 第四条指令：cmpq %rdx = %rbp？ 是就不循环，不是就循环。数组的起始地址data 放在%rax 中，循环的界限 %rbp 


![](./images/1716974962710.png)
图中： cmpq %rax , %rdx 写错了 应该是 cmpq %rax,%rdp


进行简化和重排列：（5-4的知识）

![](./images/1716975061242.png)
模板复制 n/2 次，就有数据流表示。

![](./images/1716975102897.png)
关键路径上还是n个乘法操作
：是因为两个乘法指令是 相关的，后条用到前条，所以没法并行。

### 提高并行性

函数combine6：2X2循环展开。

两次循环展开 + 两路并行的计算方法。

>索引值 偶数 = acc0 ，索引值 奇数 = acc1
>对于向量长度 不为2的倍数， 的for(; i < length ; i\+\+)  图中这个循环要累积剩下的数组元素。
>

![](./images/1716975247793.png)

大幅度提升，突破了延迟界限。

![](./images/1716975404267.png)

comb6的汇编代码：

![](./images/1716975448239.png)
comb 6 的数据流图：

>关键路径 两条：一条acc0，一条acc1。

![](./images/1716975467468.png)
>如果将循环展开k次，每次并行计算k个值，性能会不会继续提升？
>接近吞吐量界限。


![](./images/1716975560911.png)
combine7 的代码：**重新结合变换（名词）**:括号顺序不一样了。

![](./images/1716975614031.png)
性能变化：

![](./images/1716975720804.png)

仅仅通过括号的改变就突破了延迟界限的限制。


为什么换括号就能提升？
**combine7汇编代码：**


![](./images/1716975858242.png)
>vmovsd 从内存中加载向量元素data[i] 到寄存器xmm0
>第一条：vmulsd ——》 load从内存中加载向量元素 data[i+1] ，然后mul操作对二者乘法。
>第二条：结果乘以累计值acc
>
>虽然一样，但是只有一个乘法操作，形成了循环寄存器间的**数据相关链。**（第一个load 和 mul）

![](./images/1716975873692.png)
## 5.6 理解内存性能

![](./images/1716976234804.png)
>从这个表能看出来，继续增加路数反而下降性能。

通过二者的汇编代码找出原因：

![](./images/1716976338673.png)
>在10X10 中，累积变量acc0 在寄存器%xmm0 中
>可以发现，20X20 累积变量 保存在栈（内存）上(%rsp)，而不是寄存器中。(带括号的就是内存)
>程序必须从内存中读取 data\[i\] 和 累积变量 ，二者相乘的杰哥保存回 内存。

> 现代CPU 有 16个寄存器保存浮点数，循环超过了这个数量就会调用内存了。


>CPE 达到吞吐量界限时，无论怎么样也不会突破吞吐量界限了。

### 加载性能

这个代码是：计算链表的长度

![](./images/1716976642102.png)
在这个循环中，变量 ls 的值 依赖于 ls-> next 的值，判断 ls 是否指向尾部 **（尾部 = null）**

函数list_len 的 CPE = 4.0

while 循环的汇编代码：

> movq 加载 内存数据： 其中 **(%rdi) 这个加载操作的内存地址需要从寄存器rdi中获取**（重点）
> 寄存器%rdi 的每个值 都要依赖于加载操作的结果。
> 而加载操作又以%rdi 的值 作为它的地址。
> 因此，前一次迭代完成，下一次才会开始。

：其中，这个测试机器的文档给出了 L1 cache 的访问时间是 4 时钟周期。

### 存储操作

>寄存器的值写到内存。不会影响任何寄存器的值。
>不过，当**加载操作**要从**存储操作**写的那个内存位置读取数据时。
>这两个操作之间可能会互相影响。

#### 代码示例：

>图中，提供了代码，还有提供了两个示例：
>示例A ： CPE = 1.3
>示例B ： CPE = 7.3
>由于示例B两个参数在同一个位置，使得 内存读的结果依赖最近的内存写的操作 ：**写/读相关**(名词)

![](./images/1716977092563.png)
循环的汇编代码：

>movq ——> 计算存储操作的地址 s_addr 和 数据加载到内存的操作 s_data
>下一条movq 要从 %rdi 取数据(load)

![](./images/1716977298729.png)
>地址不同，就可以独立执行了。

## 总结 
程序性能优化的基本策略：

- 高级设计 High-level design
	- 针对具体的问题 选择适当的 算法 和数据结构
- 基本编码原则 Basic codint principles
	-  消除连续的函数调用 以及 消除不必要的内存引用
-   低级优化 Low-level optimizations
	-   根据硬件的设计，利用 **循环展开** 等技术来提高**指令集并行**。

避免错误： 引入新的变量 以及 改变 循环边界时，容易犯错。
# 第 六 章 存储器层次结构

如果数据存储在 cache（高速缓存） 中： 获取数据需要 4~75 时钟周期
如果数据存储在 内存 中： 需要 几百个 时钟周期
如果数据存储在 磁盘（disk） 上， 需要 大约 几千万个 时钟周期


## 6.1 存储技术

### 随便访问存储器 Random Access Memory RAM

>其中有：
>Static RAM (静态 RAM，**SRAM**)
>Dynamic RAM(动态 RAM，**DRAM**)

SRAM 将 每个bit位 的信息存储在一个 **双稳态** （名词）的存储单元内，每个单元 = 6个晶体管

### SRAM

双稳态结构（名词）：用钟摆来形容。

最左，最右是最稳定的，而中间是最不稳定的。（无法恢复到垂直状态）

![](./images/1716983953513.png)

双稳态：只要有电，就能一直保持所存储的数据。

### DRAM

>原理：电容充电
>一个 bit ——> 一个电容 和 一个晶体管


>与SRAM不同，DRAM 的存储单元对 干扰十分敏感。
>当电容电压被扰乱，就没办法回去了。
>而且还有问题：
>很多原因导致漏电，使得DRAM 会在 10 ~ 100毫秒内失去电荷
>因此内存系统需要不断的读出数据，重写来刷新内存的每一位（才能保持数据）

cache 采用的就是SRAM
内存 采用的是DRAM

![](./images/1716984078938.png)
16 超单元的个数， 8 每个超单元可以存 8 bit 数据。

![](./images/1716984262227.png)
>整个DRAM芯片 通过 **地址引脚** 和 **数据引脚** 与 **内存控制器** 相连（重点）
>内存控制器 主要 管理内存

>内存控制器的比喻：
>1.数据 = 书
>2.内存 = 图书馆
>3.内存控制 = 图书管理员


![](./images/1716984407192.png)
假设我们要从 DRAM 芯片 读出图中所示的超单元（2，1）

>首先，内存控制器 发送 (RAS)行地址2 到DRAM芯片
>DRAM 会把第二行的全部内容复制到**内部的行缓冲区**中。
>然后，内存控制器 再发送 （CAS）列地址1 到DRAM芯片。
>DRAM 操作 对应从这个行缓冲区 复制 **对应的数据位**。并发送到内存控制器。


![](./images/1716984463507.png)

>Q：为什么要分两次发送地址，这样不是增加了访问时间吗？
>A：DRAM的设计人员将 存储单元 设计成了 二维的阵列，非 线性数组。这样设计的好处就是降低芯片上地址引脚的数量。


### DRAM芯片封装成的内存模块

8个DRAM芯片， 编号0~7。

每个超单元 可存储 = 8bit
因此一个 8 byte = 需要 8 个超单元。
但 这8个超单元 不在同一个DRAM芯片上，而是平均分布在8个DRAM中。
（DRAM 0 存储最低 8 位 >>>>> DRAM 7 存储最高 8 位）

当CPU 向 内存控制器 发起读取数据的请求时，内存控制器将地址转换成 超单元的地址（i,j)，然后发送到内存模块。
内存模块再将行地址i 和 列地址 j 广播到每个DRAM。
每个DRAM都会输出它对应超单元的数据。
最终内存模块 将 所有超单元的数据合并成一个 64bit 的数据返回给内存控制器。
(存在每个DRAM的超单元地址其实是**一样的！**)

![](./images/1716985393177.png)
### DDR3,DDR4,LPDDR4
DDR = DDR SDRAM （Double Data-Rate Synchronous DRAM) 双倍速率同步动态随机存储器
同步DRAM的速度 > 异步DRAM的速度。

3，4代表几代。

速度的提升主要依靠扩大预取缓冲区的位数。
DDR4 ——> 16bit
DDR3 ——> 8bit
LP ——> Low Power

## 6.2 机械磁盘

>磁盘，机械磁盘，固态硬盘。

机械磁盘，或者叫旋转磁盘。

![](./images/1716987028466.png)
一个sector = 512 byte

![](./images/1716987051554.png)


![](./images/1716987152238.png)

读写头半径移动，就可以读取任意磁道上的数据。（寻道）
读写头 距离磁盘表面的高度 大约 是 0.1微米。所以任何微小的灰尘和震动都会出问题。

### 对于GB，TB的不同。

![](./images/1716987627471.png)

### 磁盘的读写速度

对扇区的访问时间 = **寻道时间** + **旋转时间** + **传送时间** (名词)

- 寻道时间 （磁道）
	- 数据不在当前 传动臂 **所在磁道**，就要进行移动。这个移动的时间便是。
	- 取决于 读/写头 当前位置 和 目标位置的距离
	- 平均 3 ~ 9 ms左右
- 旋转时间 （旋转）
	-  第一个数据位旋转到 读/写头 下才能读取数据
	-  两个因素：
		-  读/写头所在扇区位置 与 目标扇区的距离
		-  假设一盘 7200RPM，那么转一圈大概 8ms
	- 平均旋转时间 4ms
-   传送时间
	-   旋转速度 ，每条磁道的扇区数目。
	-   假设 平均扇区数 400 ，转一圈要 8ms
		-   转过一个扇区大约 0.02ms
 
>主要是 **寻道时间**  和 **旋转时间**

### 操作系统的视角看磁盘

![](./images/1716988435367.png)


## 6.3 固态硬盘 / 局部性

>固态硬盘：由一个或者多个 **闪存芯片** 组成的。
>闪存转换层（flash translation layer,FTL)：与磁盘控制器类似
>闪存芯片基于 Nand Flash 实现。

![](./images/1717047001171.png)
>数据以page位单位读写的，不同规格的闪存芯片，page大小都不一样。（有可能512,1k,2k)
>多了除了读写，还有擦除的操作。
>闪存编程（写入）原理的限制，只能将1 改 0 ，不能将0改成1
>写入前，page要擦除（对于擦除操作是以block为单位）
>擦除操作：所有都变成1.
>擦除后就所有page都能执行 **一次** 写操作。
>经过一定次数，block就磨损，如果一个block发生损坏，就不能再使用了。
>内存翻译层解决方法——平均磨损算法
>将擦除平均到所有的block上来最大化每个块的寿命。
>

![](./images/1717047041578.png)

![](./images/1717047161609.png)


>相比机械硬盘： 固态是半导体存储器构成的
>随机访问时间 快，功耗 更低， 更 抗摔

### 存储器结论：

![](./images/1717047474138.png)
CPU芯片 基于SRAM的高速缓存（cache）
高速缓存之所以可以降低CPU的访存延迟，
这是因为应用程序具有 **局部性** 的特点。

### 局部性Locality
>时间局部性，空间局部性

>如果被引用的内存位置 很可能会在后续不断的被引用，就有良好的**时间局部性**。

>如果一个内存位置被引用了一次，程序很可能在不远的将来引用附近的一个内存位置——良好的**空间局部性**

**例子：**

![](./images/1717047955388.png)
>图中，
>sum ——> 会被多次调用：好的时间局部性； 标量，没有空间局部性。
>v[i] ——> 顺序调用：好的空间局部性；每个元素只调用一次，不好的时间局部性。


例子：二维数组

![](./images/1717048148383.png)
>嵌套循环是按照行优先的顺序来读取数据元素。
>内层for循环先读第一行元素，再读第二行。
>**数组的存储也是按照行优先来存储的**（重点），这样顺序是一样的。
>——>具有良好的空间局部性


进行改动：

![](./images/1717048265993.png)

>改动了i和j的顺序，导致空间局部性差了，因为访问顺序变了。

>高数缓存(cache)看是利用 程序的局部性 来提高CPU访存速度

## 6.4 存储器层次结构

![](./images/1717048412758.png)
>中心思想： 速度更快、容量更小的 存储设备 作为速度更慢、容量更大的 存储设备 的 **缓存**。

### 缓存

>数据总是以块 为单元 在 第K层 和 第K+1层 之间来回复制。

>对于相邻层之间的块大小是固定的，然而不相邻的层次之间，块的大小是不一样的。：寄存器 和 L1 cache 之间 传送的块大小通常是一个字
>L2 cache 和 L1 cache 之间 通常 块大小 几十个字节

#### 缓存命中 Cache Hit / 缓存不命中 Cache Miss

>当程序需要第k+1层的某个 数据对象d 时
>它首先从第k层的数据块中检索是否包含目标数据d的副本。
>
>如果目标数据d刚好缓存在第k层中——> **缓存命中**（名词）
>当不发生命中，第k层的缓存要从第k+1层取出包含目标数据的块——>缓存不命中
>
>如果第k层的缓存已经满了， 包含目标数据的块 就会**覆盖** 现存的一个块 ——>替换，被替换的块叫 **牺牲块**.


#### 基于SRAM的高数缓存

>早期存储结构三层：寄存器文件，内存，磁盘
>由于CPU 与内存之间的性能差距逐渐增大，于是 在 寄存器文件和内存之间插入了 一个小的基于SRAM的高速缓存，L1cache。（访问速度和寄存器差不多，大约 4 时钟周期）
>
>随着CPU 和内存差距继续增大，插入了更大的高速缓存L2 cache（L1 cache 和 内存之间） （访问时间大约 10 时钟周期）


#### Cache的内部结构：

整个cache被划分成一个或者多个Set
每个set包含一个或者多个cache line（高速缓存行）
E ——> cache line 的行数

>每个cache line 有三部分组成：
有效位（valid)(1bit)、标记（tag)、数据块（cache block)

>valid = 1 有效，valid = 0 无效。
标记：用来确定目标数据是否存在于当前的cache line中。
数据块：一小部分**内存数据的副本**，大小用B表示。

>cache 的结构可以用元组（S,E,B,m)来描述。
>cache的容量 = C = S x E x B

![](./images/1717049818376.png)

#### cache如何工作

>当CPU 执行数据加载从内存地址A处读取数据时，
>根据存储器层次原理：
>CPU将地址A发送到cache，cache会看看自己有没有目标数据的副本，如果有就立即发给CPU。
>那cache是如何知道自己有的？

假设目标数据（地址A） 的地址长度 = m位
这个地址被 参数S 和 B 分层了三个字段

首先，可以通过 Set Index 来确定数据存储在哪个set中
知道了是哪个set，就需要确定目标数据放在哪一行
确定具体的行 是 tag 来实现的
此时有效位 必须 = 1.
因此，需要 有效位 和 标记 共同来确定目标数据属于哪一行
根据 Block index（块偏移量） 来确定目标数据在数据块的确切地址。

通过以上三步，cache就能够确定是否命中。

![](./images/1717050631820.png)
>关于为什么cache要用中间的位 作为 Set Index，而不是用高位？

如果一个程序有良好的空间局部性，当需要顺序读取一个数组的多个元素时，此时需要不断进行cache line 的替换。
在任何时刻，cache都只保存着一个块大小的数组内容。（按照SRAM的情况，数组每一个都保存在不同的块中）

中间：高位索引，
右边：中间位索引。

![](./images/1717050955930.png)


## 6.5 直接映射高速缓存

>当每个set 只有 一个cache line ——> **直接映射。**

假设有这样一个系统，它包含一个CPU，一个寄存器文件，一个L1 cache，一个内存。

当CPU 执行从内存中读取数据的指令时，首先 L1 cache 有没有目标数据的副本，如果有，就直接返回给CPU。
这个判断是否命中，和获取的过程分为三步：（重点）

1. 组选择 set Selection
2. 行匹配 line matching
3. 字抽取 word extraction

组选择：
通过Set Index（组索引） 来确定目标数据在哪个set
Set Index =》 无符号数（5位就等于32个set）
Set Index = 00000 = set 0 ， 00001 = set 1。

行比配：命中/ 不命中

首先判断 Vaild （图中红色） = 1? 若不是就没有有效数据。
其次判断 Tag 是否相同，若是相同，那就一定存在这个位置。

![](./images/1717056529530.png)
字抽取：根据**偏移量**（Block offset）
就是从数据块的哪个位置开始抽取数据（打麻将呢）
Block offset 存的是 无符号二进制，100 = 4，因此从4开始获取数据。

![](./images/1717056657743.png)
>如果发送不命中，那么cache需要从 存储器层次结构的 下一层取出被请求的块。

>由于直接映射每个set只包含一行，因此 **替换** 策略十分简单，直接用新取出的行来替换当前的行就可以了。


### 具体例子：

假设，直接映射的Cache ，（S,E,B,m) = (4,1,2,4) (Set量，set中cache line量，Cache block 大小，地址大小)（重点）

![](./images/1717056916307.png)

地址空间：

![](./images/1717056906669.png)
注意：每个内存块包含两个字节（包含两个地址）

![](./images/1717056966997.png)

8个内存块 ，但是只有 4 个set，因此：
出现两个内存块 映射 同一个set中。 
例如：（0，1）的内存块 和 （8，9）的内存块 都映射到 set 0


CPU执行一系列读的时候，cache是如何执行的。
假设：CPU每次读取的数据 = 1字节

图中表格的每一行 = cache line
右边是 内存。

![](./images/1717057255959.png)
第一步：
当CPU读取内存地址 0000 的时候，cache 不命中（Valid == 0）
此时cache就会从内存中取出 包含目标数据的块，放到set 0 中。
然后cache 返回 位于 set 0 中 的目标数据m[0]

![](./images/1717057336729.png)

第二步，CPU 读取 0001,而这次cache 表示：我有！这次cache是命中的。
cache 根据地址m 进行 **组选择，行匹配 和 字抽取** 后
将目标数据m[1]放回给CPU，此时cache不会有任何变化。

第三步：当CPU 读 13（1101）， 而这次cache set2 有效位 = 0，无数据。发生**不命中**。
cache 读取数据，保存，然后把m[13]返回到CPU中。

![](./images/1717057488239.png)
第四步：当CPU读取地址 8 (1000) ，根据 8 的组索引位（00），发现 set 0 的 vaild \=\=1
但是进行Tag 匹配后 发现并不匹配 （8 的 tag = 1000 的 1）
此时，需要块4 来 **替换** 块 0 ，然后再返回 m[8] 的数据。


最后一步：CPU再去读地址 0000， 又会发生不命中。（cache:兄弟我刚丢的牌）

>番外：这种CPU就感觉和 计网 中 的 "存储—转发" 的感觉类似。

这种就是发生交替引用时，还是会出现不命中的情况——> **冲突不命中**（名词）

### 代码示例：冲突不命中

![](./images/1717057773361.png)
x , y 有良好的局部性（空间局部性）
因此我们期望cache有较高的**命中率**，但事实并非如此。

![](./images/1717057882182.png)
从图中可以看到，地址是顺序的(float = 4 byte)

当程序开始运行，循环第一次迭代时引用了元素x[0]。
发生不命中，cache把x[0] ~ x[3] 的块加载到set 0.

![](./images/1717058072401.png)
接下来，立马就引用了 y\[0\]，又一次不命中，这时cache 把包含y\[0\] ~y\[3]的块 加载到 set 0中。
然后就发生了替换。

![](./images/1717058163241.png)
然后，循环进行下一次的迭代。
取x[1]时，又来了。又一次不命中，又一次的替换。

![](./images/1717058202853.png)
>这种一直替换的现象 ——> **抖动** (名词)


解决方法：

数组X的长度由 8 变为 12

![](./images/1717058319262.png)
>如何获得set index？
>简单理解就是 address 右移四位再取最低位就可以得到 set index了

## 6.6 组相联 / 全相联高速缓存

### 组相联

组相联cache 每个 set 允许包含多个 cache line
1 < E < C/B (C = cache 容量 ， B =  cacheBlock 大小)

2路组相联Cache:

![](./images/1717058668087.png)

这个cache 是否能命中，也得看三个大爷的眼色 **（组选择，行匹配，字抽取）**

组选择：
通过组索引位来确定目标数据属于哪一个set。 
过程和直接映射（一条的cache line）是一样的。

![](./images/1717058828539.png)

行匹配：
每个set包含多个cache line，因此需要进行**遍历**，每个valid == 1 以及 tag 是否相等。
如果找到，表示命中。

块偏移：
就根据偏移量，偏移量作为数据的首位置，然后获取数据。

![](./images/1717058923680.png)
同样如果不命中，就cache **必须** 从内存中取出包含目标数据的块。
替换哪一行呢？
如果存在 valid == 0 的位置，感觉不错。
但如果没有呢，我们就需要找 替罪羊（非空行）作为被替换的对象，同时希望CPU不会很快引用它。

#### 替换策略
- 随机替换
	- 随便啦。
- 最不常使用 Least Frequently Used,LFC
	- 过去某个时间段内引用次数最少的那一行（cache：你价值甚少）
- 最近最少使用 Least Recently Used,LRC
	- 最后一次访问时间最久远的那一行（cache：老东西该走了）

>存储层次结构越往下走，一次不命中的开销其实挺大，所以有替换策略还是好的。

### 全相联

>整个cache 只有一个set ，一个set 包含了所有的cache line。 —— 全相联

E = C/B (C = cache容量 B = 数据块大小)

![](./images/1717059332070.png)
set 就只有 set 0 ，这下就不需要 组选择 了~

这样一来，地址只需要划分成标记和块偏移即可：

![](./images/1717059380428.png)
>至于 行匹配 和 字选择， 和组相联cache 是一样的。
>区别也就 cache line 规模大小问题。

![](./images/1717059423566.png)
>由于实现和成本问题，全相联cache 只适合用作容量较小的**缓存**。
>例如： 虚拟内存系统中的TLB

### 写入操作cache

>读是简单一些， 但写入的话相对复杂。

CPU要在内存写入数据时，需要考虑情况： **写命中** 和 **写不命中**。

- 写命中 发生后
	- 写穿透（直写）write-through
		- CPU在写cache的同时写内存（更低一级cache）
		- 好处：内存（更低一级cache）里的数据永远都是新的。cache替换时，直接扔掉旧的数据就可以
	- 写回 write-back
		- CPU只写cache，不写内存（更低一级cache）
			- 好处：省事儿
			- 只有当替换算法要驱逐这个更新的块时，再写回到内存（更低一级cache）里
			- 增加cache的复杂性
				- 为了表明每个数据块是否被修改过，每个cache line 要增加额外的修改位。
- 写不命中 发生后
	-  写分配 write-allocate
		-  目标数据所在的块从内存（更低一级cache）加载到cache中，然后再往cache中写。
	-  写不分配 no-write-allocate
		-  绕开cache，直接写入内存（更低一级cache）里。

通常情况下： **写分配** 和 **写回** 一起用， **写不分配** 和 **写穿透** 一起用。


### Intel Core i7 CPU 的 cache层次结构

>实际上：cache即保存数据，也保存指令。
>只保存指令的 ——> i-cache
>只保存数据的 ——> d-cache
>保存指令和数据的 ——> unified cache （统一高速缓存）

好处：CPU 可以同时读指令和数据，还能确保数据 和 指令访问 形成 **冲突不命中（抖动）**

图中虚线是CPU内部：

![](./images/1717060121597.png)
不同层次cache的特性以及参数：
按照顺序：缓存类型，访问时间，容量大小，相联方式，数据块大小，set量

![](./images/1717060188630.png)
>容量较大的cache 命中率++ 但是 访存时间--
>数据块的大小也会影响 cache 的性能。

较大的块 能利用 程序中可能存在的 空间局部性，命中率++
块大小++ cache的行数 --
虽然对空间局部性好的有利，但是时间局部性好的程序就会 命中率--
发生不命中，较大的块 处罚++

在Intel Core i7处理器中，
L1 cache和L2 cache都是 **8路组相联**的 set = 8 cache line
L3 cache = **16路组相联** set = 16 cache line

不过，相联度（E）++ ，实现的复杂度++ ，访问速度很难提高。

>相联度 E 的选择： 命中时间 / 不命中处罚 之间做折中。

最终，写策略的影响。
L1 , L2 : **写穿透**
越往下层，**写回** 更多。

# 第七章 链接 Linking

>链接可执行于 编译时，加载时，运行时


>Linking 链接 —— 将各种 代码和数据收集 并组合成 一个文件 的过程，最终得到的文件可以被加载到 内存执行。
>链接是由链接器自动完成。

通常我们做一个项目时，不可能只做一个然后把所有东西都放进去。而是按照情况分成多模块进行。而如果要修改，只需要重新编译其中的模块，然后进行修改即可，其他模块不用重新编译。

![](./images/1717073225511.png)
由于程序规模比较小，链接通常都是链接器默默处理的。

学习的原因：
- 构造大型程序
	- 缺少库文件，或者库文件版本不兼容导致 Link 错误
	- 理解 **链接器是如何使用 库文件 来解析引用的**
- 避免一些危险的编程错误
- 理解语言的作用域是如何实现的
	- 例如：全局变量 和 局部变量 之间的区别是什么？
	- static 属性的变量或者函数，实际的意义是什么？
- 理解其他重要的系统概念
	- 程序的加载和运行、虚拟内存、内存映射等等
- 更好的利用共享库
	- 共享库和动态链接 越来越重要
## 7.1 编译器驱动程序

看看示例：
图中是由两个源文件组成， main.c 和 sum.c

![](./images/1717073714275.png)
在Linux 中的shell 中输入图中的命令：获得可执行程序prog
-Og ——> 代码优化等级（本次选项 == 要符合原始C代码的结构）
为了性能，通常会用 -O1 和 -O2
-o prog ——> 可执行文件的名字为prog （其中 o = output）
默认生成 = a.out

![](./images/1717073933832.png)
编译器系统的工作流程如图：

![](./images/1717073961951.png)



把整个编译过程分解，采用手动链接的方式来生成可执行程序。

![](./images/1717074186214.png)
在预处理阶段：(Stage 1)


![](./images/1717074214231.png)
cpp 和 gcc 都可以：其中：
-E —— 选项是用来限制gcc只进行预处理，不做编译、汇编以及链接的操作

main.i —— ASCII码的中间文件

在编译阶段：(Stage2)

![](./images/1717074282667.png)
cpp 和 gcc 都可以，其中：
-S选项表示只对文件进行编译，不做汇编和链接的处理

main.s ——汇编文件，可以用编译器打开。

在汇编阶段：（stage3）

![](./images/1717074352126.png)

main.o —— 可重定位目标文件
sum.o 

最后，使用链接器（ld）来构造可执行文件。：(stage4)

crt = c runtime

需要以下文件：

![](./images/1717074449195.png)
链接就是把这些文件 打包成一个 可执行文件，具体命令：

![](./images/1717074488845.png)
其中： ld(链接器) -static(静态链接)

可执行文件prog能否正确运行：

![](./images/1717074600273.png)

通过shell 调用操作系统中的加载器（loader）函数来实现的：
加载器将 可执行文件prog 中代码 和 数据复制到内存中，
然后将 CPU 的控制权 转移到 prog 的程序开头
随后程序prog开始执行。
## 7.2 可重定位目标文件

图中代码定义了两个全局变量 count 和 value。
函数func only printf
main 函数中定义了两个**局部静态变量** a 和 b

![](./images/1717074968475.png)
使用gcc  翻译这个源文件 ——> 可重定位目标文件

wc（word count）-c 看看main.o的大小( -c =多少字节)

![](./images/1717075146226.png)
### 可重定位目标文件的结构

> ELF header，不同的sections 和 描述这些section信息的表

![](./images/1717075186492.png)
readelf -h —— 读elf，然后只读header。

![](./images/1717075298484.png)
>魔数（Magic） 确认文件类型。
操作系统 在 加载可执行文件 的时候会确认魔数（Magic）是否正确。
>第7个 01 是elf版本号
最后没有定义，用0填充。

![](./images/1717075436266.png)
这个表示：这个文件为 可重定位文件REL
还有另外两种类型： 可执行文件 和 共享文件

![](./images/1717075468543.png)


elf长度:

![](./images/1717075530198.png)
因此就等于这个：
0x40（16进制） = 64（10进制）

![](./images/1717075617988.png)

这个表的起始位置：

![](./images/1717075671039.png)
每个表大小 = 64 byte ， 有13个表。 整个表 = 832 byte。

![](./images/1717075691522.png)


![](./images/1717075729579.png)
描述不同section 属性的表（section header table）
readelf -S （打印整个section的表）

除了第一项，其他每一个对应着一个section。

![](./images/1717076250095.png)
整个elf文件一共包含12个section。
其中：offset = 每个section起始位置 size = 每个section大小

例如：**.text** section 的起始位置 是 0x40 ，大小为 84 个（0x54)字节。

![](./images/1717076428864.png)

**.data section** 存放已初始化的全局变量和静态变量的值。

![](./images/1717076537084.png)
由于是小端法，所有顺序相反。

**.bss section** 未初始化的全局变量和静态变量。（被初始化0 也会）

bss = better save space 的缩写（看成）

.bss section 仅仅只是一个占位符。（区分 初始化的情况 只是为了节省空间）

**.rodata section**存放只读数据。

保存了需要打印的字符串（printf）

![](./images/1717076742984.png)


整体就是这样：

![](./images/1717076779596.png)


![](./images/1717076809913.png)

## 7.3 符号和符号表

>Link过程的本质就是把多个不同的目标文件 “粘合” 到一起
>目标文件之间必须有固定的规则才行。
>**符号**可以看作链接中的**粘合剂** 
>Link过程正是基于**符号**才能正确完成。

>重点看： .symtab(symbol table) 的内容。

![](./images/1717076956618.png)
一共有17个符号，编号0~16。 最后一列给出了符号的名字。

回顾main.c的内容：

![](./images/1717077000558.png)
symbol table 的内容：

![](./images/1717077183281.png)
Ndx ——> section的索引值。(section header table) (1 = text ,3 = data)

value(**十六进制！！！**) ——> 函数相对于 text section起始位置 的偏移量 

size ——> 所占字节数

>其中： prinf 定义不在 main.c 中 ，所以 Ndx = UND（undefine)

其中：count 和 value

Type: Object ——> 符号是个数据对象（变量和数组）

count Ndx = 3 (data section)， value Ndx = COM (COMMON)（一个初始化，一个没有）

>COMMON 未初始化的全局变量
.bss 未初始化的静态变量，初始化为 0 的全局或静态变量。

其中： a.2254 b.2255 (局部静态变量 a和b)

a Ndx = 3 , b Ndx = 4 (其中初始化 a = 1 , b = 0)

a.2254 b.2255 ——> **名称修饰** (名词），主要为了避免静态变量的名字冲突。

其中：没有符号名的：

![](./images/1717077590578.png)其实就是section的名称。

**额外情况**：
局部变量 int i = 1 没有存在于 符号表 中。

![](./images/1717077620910.png)
局部变量在运行时栈中被管理，链接器对此类符号不感兴趣。

### 符号种类

每一个可重定位目标文件都有一个符号表，符号表包含该模块定义和引用的信息。

- 全局符号 Global Symbols
	- 由该模块定义，同时能被其他模块引用的
	- 例如：main.c 中 函数func 和全局变量count 和 value
- 外部符号 Externals Symbols
	- 被其他模块定义，被该模块 引用 的 全局符号
- 局部符号 Local Symbols
	- 重点：static
	- 带static属性的 是不能被其他模块引用
	- static功能： 隐藏模块内部的变量 以及 函数声明 （模块私有）
	- 类似：C++ 和 Java 中的 public 和 private

>用static属性来保护你的变量和函数吧！


## 7.4 符号解析与静态库

代码示例：

![](./images/1717077988453.png)
进行编译和汇编，而不执行链接操作：
编译和汇编是没问题的。

![](./images/1717079433449.png)
符号表：

![](./images/1717079481567.png)
虽然源程序中只是声明了函数foo,汇编器还是为它生成了相应的符号。

不过 在 链接生成 可执行文件时，链接器在其他输入模块中 是找不到这个引用符号（foo）的定义。
此时会输出一条错误信息，中止操作。

![](./images/1717079530945.png)
> 如果 多个 可重定位文件 中定义了同名的全局符号，此时应该如何处理？
> 强符号，弱符号（名词）


### 强符号，弱符号

强符号(Strong symbols)：函数和已初始化的全局变量

弱符号(Weak symbols)：未初始化的全局变量

### 处理多重定义的符号名，有三种情况:

#### 1. 多个同名的 强符号 同时出现

![](./images/1717079758107.png)
这种情况下，链接器 将生成一条 错误的信息
这是因为 main 声明了两次

![](./images/1717079779555.png)
以上的情况也会生成一条 错误的信息。
x 声明了两次，两个强符号。

> 链接器**不允许**有 **多个同名的强符号** 一起出现。

#### 2. 一个强符号 和 多个同名弱符号 一起出现

![](./images/1717079888986.png)bar3.c 的 x 是弱符号
foo3.c 的 x 是强符号

此时链接器 可以生成可执行文件，并不会提示错误。

在运行时，函数f会将 x 的值 从 15213 改成 15212 ，很意外（main，what can i say）

#### 3. 都是弱符号

![](./images/1717080028057.png)
>强强则错，强弱则强，弱弱则错 （重点）

#### 更多例子：

![](./images/1717080080981.png)
一个 double x 一个 int x。

如果 对 double x 进行 x = -0.0 的赋值，就会发生图中的情况： 覆盖x 和y 的位置。


![](./images/1717080125719.png)
>这个是非常小的错误，但是很严重。
>为了避免这个错误，可以在编译时 添加 -fno-common 的编译选项
>告诉链接器，遇到多重定义的全局符号时，触发一个错误。
>或者 -Werror 选择，会把所有的警告变为错误。


### 链接器 如何使用 静态库

> printf 就是 C语言提供的一个库函数。

以ISO C99为例，它定义了标准的I/O、字符串操作和整数数学函数
例如：函数atoi, printf, scanf, strcpy, rand 等等

![](./images/1717080445157.png)
archive 文件 是一组 可重定位目标文件 的集合

![](./images/1717080506571.png)
静态库libc.a 中一共包含 1690个目标文件。



### 静态库Static Library 是如何构造的

函数addvec 功能：实现向量元素的累加
函数multvec 功能： 实现向量元素的累积

![](./images/1717080562264.png)
> linux > gcc -c addvec.c mulvec.c
> linux > ar rcs libvector.a addvec.o mulvec.o

![](./images/1717080778002.png)
静态库 libvector.a

演示静态库的用法：

![](./images/1717080818512.png)
其中：vector.h ——> 定义了 libvector.a 中的函数原型

然后这样操作。（在链接的时候加入 静态库libvector.a)

![](./images/1717080888436.png)

![](./images/1717080992094.png)

## 7.5 静态库的解析过程

链接器是如何使用静态库来解析引用的

链接器从左到右 的顺序来扫描可重定位文件和静态库文件。

![](./images/1717081274104.png)
维护了三个集合：

集合E ——
发现 可重定位目标文件 就会放到这个集合中
Link即将完成时，这个集合的文件 最终会被合并起来 形成 可执行文件

集合U ——
引用了，尚未定义的符号放在这个集合里。

集合D ——
存放输入文件中已定义的符号

例如针对于 上图的命令，链接器会判断main.o是一个目标文件，然后就会放到集合E中。同时修改集合U和D来反映f中的符号定义和引用。

main.o 的符号表：

![](./images/1717148575355.png)
已经定义的全局符号： x,y,z main 

![](./images/1717149094647.png)
处理完毕，然后就是处理下一个文件： libvector.a
链接器会尝试在这个静态库文件中寻找 集合U中 未解析的符号
libvector.a 存在两个成员， addvect.o 和 mulvec.o

此时，链接器发现：addvect.o 中存在 **未定义的符号 addvec的定义。**（这个会不会是重点）
那么就会addvect.o放入集合E中 ，集合U中的 addvec 删除。
如果addvect.o中定义了其他符号，也要添加到集合中。本例子：addcnt

![](./images/1717149326116.png)
接下来还要处理：mulvec.o
对静态库文件中的所有成员目标文件都要**依次进行**上述处理过程。直到 **集合U** 和 **集合D** 不再发生变化。

此时，任何不包含集合E中的成员目标文件 都被简单的丢弃。
对于这个例子：mulvec.o 丢弃。

最后扫描 libc.a
其中成员，printf.o加入集合E中。
此时printf.o 有 printf的定义，因此 U去掉。

![](./images/1717149500794.png)
此时就发生了： 集合U是空的，链接器会合并集合E中的文件来生成 可执行文件

如果链接器完成对命令行上所有的输入文件的扫描后，集合U中是非空的，那就说明程序中使用了未定义的符号，就会输出错误。

这种算法会导致一些令人困扰的链接错误，命令行上目标文件和库文件的输入顺序非常重要。

上述示例中 libvector.a 于 main.o 的输入顺序进行调换，就会直接输入失败。


![](./images/1717150577254.png)
关于库的一般使用准则就是将它们放在命令行的结尾。

如果各个库是相互独立的，那么就可以任意排序了。
如果库不是独立，必须排序。
（先声明再定义）

![](https://markdown.xiaoshujiang.com/img/spinner.gif "[[[1717150791046]]]" )

## 7.6 重定位



## 7.7 可执行目标文件
## 7.8 动态链接共享库