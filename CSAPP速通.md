---
title: CSAPP速通
category: /小书匠/日记/2024-05
grammar_cjkRuby: true
---
内容来源：[【CSAPP-深入理解计算机系统】](https://www.bilibili.com/video/BV1cD4y1D7uR/?spm_id_from=333.337.search-card.all.click&vd_source=d1002d9c1ba92da4ba3fca4fdca6d750)作者：九曲阑干

# 第一章 计算机系统漫游
一个Hello Program的生命周期：
![](./images/1716303432503.png)

The Hello Program—— hello.c
```c
#include<stdio.h>
int main()
{
	printf("hello,world\n");
}
```

>linux> gcc -o hello hell.c

通过以上的命令，便能生成一个可执行程序——hello.

>编译过程分为四个阶段：**预处理，编译，汇编，连接**

![](./images/1716303711950.png)

预处理器——会通过#开头的代码，来修改原始程序，将内容直接插入到源程序中。——hello.i（文本文件）

编译——词法分析，语法分析，语义分析——（进行翻译）——hello.s

汇编——翻译成机器指令的文件——hello.o(可重定位目标文件)(二进制文件)

链接——hello中调用了printf的函数，printf在printf.o文件中（提前编译号的目标文件），把两个进行合并。——可执行目标文件hello



了解这些知识是为了:
- 优化程序性能（第三章，第五章）
	- 一个函数调用的开销有多大？
		- while比for循环高效？
		- switch语句是不是要比一连串if-else高效的多？
- 理解链接时出现的错误（第七章）
	- 很多问题往往在链接时出现问题。
		- 函数库的调用
		- 静态变量/全局变量的区别
		- 静态库和动态库的区别？
- 避免安全漏洞（第三章）
	-   缓冲区溢出是常见的问题。
		-   理解数据和控制信息在程序栈上是如何存储
		-   书写方式

**运行一个 hello程序 by Shell**

![](./images/1716358526708.png)
## 计算机的硬件组成
![](./images/1716359102190.png)
(第四章讲述CPU)
中央处理单元(Central Processing Unit,CPU)

程序计数器 Program Count(PC)

32-bit:
1 word = 4 Byte

64-bit:
1 word = 8 Byte

系统上电，直到系统结束，CPU就不断在执行PC指向的指令。然后更新PC，指向下一条要执行的指令（两个指令不一定是相邻的）

寄存器 Register File 
CPU内部的存储设备：临时存放数据的空间

算术逻辑单元 Arithmatic/logic Unit (ALU)
用来进行算术

主存/内存 Main Memory （第六章）
存放程序指令以及数据。
物理上，随机动态存储器芯片组成。
逻辑上，看成一个从零开始的大数组。 每个字节都有相对应的地址。

总线 bus
内存和处理器之间通过总线来进行数据传递。
通常总线被设计为传送固定长度的字节块，也就是Word。

I/O 输入输出设备 （第六章、第十章）
每个 I/O 设备都通过一个控制器或者适配器与 I/O 总线相连。

**Hello程序执行的过程：**
1) 输入hello
![](./images/1716359177699.png)
2) 点击回车键，完成指令输入
![](./images/1716359205982.png)
3) 执行Main()函数的代码：
![](./images/1716359259300.png)


>存储关系：
>大容量的存储设备的存取速度要比小容量的慢
>运行速度更快的设备的价格相对于低速设备要更贵

系统设计人员在寄存器文件和内存之间引入了高速缓存
![](./images/1716359616141.png)

**存储层次**
![](./images/1716359650059.png)

>真正操控硬件的是**操作系统**
>所有的应用程序对硬件的操作必须通过操作系统来完成。
>目的有二：
>1.防止硬件被失控的应用程序滥用
>2.系统提供统一的机制来控制这些复杂的底层硬件

**抽象的概念：**
![](./images/1716359858853.png)


## 进程
借助hello程序运行的场景来解释 **进程**

![](./images/1716360225959.png)
通过shell进程加载hello进程，shell进程系统调用。
系统调用会将控制权从shell进程传递到操作系统，操作系统保存shell进程的上下文，然后创建一个新的hello进程及其上下文，将控制权转交给hello进程。
hello进程结束，系统就会恢复shell进程的上下文，并将控制权交给shell进程，shell进程等待下个命令行的输入。

Context（上下文）：操作系统会跟随进程运行中所需要的所有状态信息。（PC和寄存器的值，内存的内容等等）（第八章）

一个进程由多个线程组成，共享代码和数据。
![](./images/1716360756324.png)


## 虚拟内存
>它为每个进程提供了一个假象，就是每个进程都在独自占用整个内存空间。
>每个进程看到的内存都是一样的，便是 **虚拟地址空间**

虚拟地址空间：
![](./images/1716360887224.png)




第一个区域用来 **存放程序的代码** 和 **数据**
该区域的内容是从可执行目标文件中加载而来的。
C语言中，全局变量便是放在这。

第二区域 堆（malloc）
Memory Allocate
堆可以运行时动态的扩展和收缩

第三区域，共享库的存放区域
C语言标准库和数学库这种共享库的代码和数据

第四区域，用户栈
函数调用本质就是压栈：每次当程序进行函数调用的时候，栈就会增长，函数执行完毕返回时，栈就会收缩。
需要注意的是：栈的增长方向是从高地址到低地址。

最顶部区域，内核保留的区域
对应用程序是不可见的。

> Linux系统的哲学思想是：一切皆为文件（Everything is File）
> I/O设备，键盘，磁盘，显示器，网络都是文件。

![](./images/1716361297474.png)

>从一个系统来看，网络也可以视为一个IO设备

![](./images/1716363529552.png)

![](./images/1716364009969.png)
如何用ssh，通过网络在远程主机上运行hello程序。

![](./images/1716364100100.png)

## 阿姆达尔定律 Amdahl's Law
![](./images/1716364165613.png)
定量的看一下系统的加速比。
>定律的主要思想是，当我们对系统的某一部分进行加速时，被加速部分的重要性和加速程度是影响整体系统性能的关键因素。

假设一个应用程序的执行所需要的全部时间用Told表示。
红色部分为不可加速，另外一部分是可加速的。
其中可以加速部分速度 = a \* Told
所以不可加速部分为： Told - a \* Told = (1-a) Told

可加速的性能比例为k
可加速所花费的时间就是 (a\*Told)/k
最后可以得到加速比S

![](./images/1716364429335.png)
![](./images/1716364493722.png)
>因此，如果我们需要把系统的性能提高到2倍甚至更多，我们需要优化大部分组件。

**如何获得更高的计算能力？Concurrency（并发） and Parallelism(并行)**
1. 线程级并发
2. 指令级并行
3. 单指令，多数据并行


## 线程级并发

多核处理器的组织结构：

![](./images/1716364618796.png)

超线程（hyperthreading）/同时多线程

CPU内部，PC和寄存器存在多个备份，浮点运算部分只有一份。

![](./images/1716364759471.png)
超线程处理器可以在单周期的基础上决定执行哪一个线程。

## 指令集并行
![](./images/1716365126598.png)

近几年的处理器可以保持每个周期2-4条指令的执行速率。

## 单指令，多数据并行
单指令，多数据(Single Instruction Multiple Data,SIMD)
SIMD指令多是为了提高处理视频，以及声音这类数据的执行速度。

![](./images/1716365280909.png)


## 计算机系统的抽象 **

![](./images/1716365314162.png)

# 第二章 信息的表示和处理

Summary
1. Information Stroage（信息存储）
2. Integer Respresentations（整数表示）
3. Integer Arithmetic（整数运算）
4. Floating Point（浮点数）

## 2.1 信息存储
>通常情况下，程序将内存视为一个非常大的数组，数组的元素由**一个个字节**组成。每个字节都有唯一的数字表示，也就是**地址**。
>所有地址的集合——虚拟地址空间（virtual address space）

![](./images/1716365502638.png)
### 字节 Byte

>1 Byte = 8 bit

![](./images/1716365821132.png)
### 16进制数 Hexadecimal Notation
>十六进制好处：节省显示位置，方便与2进制转换。

十六进制表示：

![](./images/1716365943408.png)
无论是大小写，还是混合都正确。

二，十，十六进制的转换。

![](./images/1716366006624.png)
十六进制的转换比较直接，从图中能看出来。

>CSAPP原书介绍了一个小技巧：（好像没必要记住）
>记住 十六进制的 A,C,F
>那么B，D的数值可以由AC加一得到，E的数值可以由F减一得到。



#### 十六进制与二进制转换

>从最后一个，每四位分成一组，若最前一组出现没有四位的情况，那就补0

![](./images/1716366222778.png)
>记住这个： 2^(n)  -> n = i + 4j
>其中 
>i = 0 ，1，2，3
>hex = 1，2，4，8... 2^(i) (十进制)

![](./images/1716366324902.png)
#### 十进制与十六进制转换

>一直除 16，把余数拿来当作位数即可。

![](./images/1716366454548.png)
>对16进制，对应位置乘以 16^(i) 即可。

![](./images/1716366510992.png)

### 字 Word

**字长**

![](./images/1716366581005.png)

>大多数64-bit的机器做了向后兼容，因此32-bit可以在64-bit的机器上运用。
>主要的区别是：程序是如何编译的。

![](./images/1716366640443.png)
表格：C 的各个数据所占字节数的大小。

![](./images/1716366706479.png)

### 变量所在地址 *

>重点：**大端法(Big endian)**，**小端法(Little endian)**
>新的处理器，支持双端法，但android和IOS只支持小端法。

![](./images/1716366766061.png)

CSAPP原书在四个系统中尝试字节打印程序：

![](./images/1716366867524.png)

打印字节程序

![](./images/1716366894178.png)
其中：byte_pointer是强制切换为字节的序列。

![](./images/1716366963685.png)
![](./images/1716366978554.png)

因为不同操作系统使用不同的存储分配规则，指针的值是完全不同的。且32位用4Byte的地址，64位用8Byte的地址。

![](./images/1716366989620.png)
虽然整型和浮点数都是12345进行编码，但是却有完全不同的字节模式：

![](./images/1716367075119.png)

若换成二进制，并进行适当的移位，就发现有13个位的匹配：

![](./images/1716367116758.png)

> C语言的字符串被编码为以NULL字符结尾的字符数组。

![](./images/1716367275615.png)

### 布尔运算 *

>重点如图所示。与，非，或，异或。

![](./images/1716367360310.png)
C语言的特性：按位级运算支持布尔运算。

![](./images/1716367403472.png)
> 位运算的常见场景便是**掩码运算**

例如：对于一个数组，如何去获取最低有效数值？可以通过 & 0xFF

![](./images/1716367473819.png)

#### 逻辑运算：
(只有 True 和 False)

![](./images/1716367516722.png)

![](./images/1716367543829.png)
#### 移位运算：

>右移 分 逻辑右移 和 算术右移

![](./images/1716367636427.png)

![](./images/1716367693111.png)
再看看例子：

![](./images/1716367715182.png)
>实际上，几乎所有的编译器以及机器的组合都是对**有符号数**使用**算术右移**，**无符号数**就是 **逻辑右移**


## 2.2 整数的表示

表格(64位机器上的取值范围）：

![](./images/1716367803857.png)
>long类型的大小：取值范围是与机器字长相关的。

![](./images/1716367873978.png)

### 无符号数编码

>假设一个整数的数据类型有w位，用向量x来表示。
>把向量x看成一个二进制表示的数，每个元素=一个二进制位，每个位取值为0/1;
>B2U = Binary to unsigned

![](./images/1716368039061.png)

CSAPP原书的图形表示法：

![](./images/1716368096574.png)

### 有符号数编码 
Two's Complement Encodings （补码）

>主要注意的是，最高位的权重是 **负数**

![](./images/1716368200193.png)
补码图形化：

![](./images/1716368248155.png)

### 可表示的整数范围

无符号数：

![](./images/1716368309910.png)

有符号数：
最大数：

![](./images/1716368332757.png)

最小值：

![](./images/1716368365971.png)

特别注意： 

![](./images/1716368391592.png)

例子：

![](./images/1716368445312.png)


### 有符号数 / 无符号数的转换

通过强制转换，就会出现问题：

![](./images/1716368514699.png)
>位模式不变，解释这些位的方式改变了。

**有符号数与无符号数之差**
> B2U = 无符号数
> B2T = 有符号数 
> T2U= 有符号数到无符号数的函数映射

![](./images/1716368709923.png)
>有符号数到无符号数的规则：
>当有符号数为正数，那么就是 相同的数
>当有符号数为负数，那么就是 数值 + (最大的位+1)

>无符号数到有符号数的规则：
>当无符号数的最高位=0，那么就是 相同的数
>当无符号数的最高位=1，那么就是 数值 - (最大的位+1)


C语言会隐式的将有符号数强制转换为无符号数来执行运算。

![](./images/1716369015000.png)

>将一个较大的数据类型 转换 较小的类型 是不可能的。
>但较小的数据类型 转换 较大的类型 是可以的。


无符号数的转换：**零扩展**

![](./images/1716369145178.png)
#有符号数的转换： 符号位扩展

![](./images/1716369179768.png)
原书内容：

>数学归纳法

![](./images/1716369250197.png)

![](./images/1716369302109.png)
![](./images/1716369337681.png)


>较大数值 -> 较小数值
>高16位被丢弃，只留下低16位的数据. 

>总之，无符号数以及有符号数的转换会出现一些难以发现的错误（非直观）。了解这类知识，就避免这种问题。


## 2.3 整数运算

### 无符号数加法：

![](./images/1716369578870.png)
>产生这个结果的原因是 以及超过char的数值。(溢出)

引入无符号数的加法的标志：

![](./images/1716369638693.png)
两个无符号数加法的情况：

![](./images/1716369654251.png)


原因：

![](./images/1716369700215.png)
>由于加完1就溢出了，为了避免位数增加，因此变成这样，且不会报错。

**判断溢出：**

![](./images/1716369778229.png)
原理：

![](./images/1716369854738.png)

### 有符号数加法：

引入符号：

![](./images/1716369875620.png)
情况：

![](./images/1716369917225.png)
例子：

![](./images/1716369939807.png)

原理：

![](./images/1716369967829.png)

**检测是否发生溢出：**
![](./images/1716370056299.png)


### 加法逆元（Additive Inverse）

图中：x' 便是 加法逆元。

![](./images/1716370199286.png)

**无符号数的逆元：**

![](./images/1716370534274.png)
**有符号数的逆元**

![](./images/1716370564413.png)

### 乘除运算

**无符号数**

![](./images/1716386761592.png)
C语言中，定义了无符号数乘法所产生的结果是w位
因此结果会截取低w位的成果。——取模

![](./images/1716386837319.png)
**补码**

>与无符号数多了一个操作，就是把无符号数**补码**——转成有符号数

![](./images/1716386901798.png)
例子：

![](./images/1716386959401.png)
>虽然有符号数和无符号数在计算出来的位级表示可存在不同，但是截断后是**相同的**。

通过数学的方法来表示。 x，y有符号数，x' , y' 为 无符号数。

![](./images/1716387059862.png)
有符号数和无符号数的关系如下：

![](./images/1716387084333.png)
取模的推导过程：

![](./images/1716387096352.png)
很多C语言的编译器试图用**移位**、加法以及减法来代替整数乘法操作。

![](./images/1716387180158.png)
移位操作通过数学公式表达：

![](./images/1716387225093.png)
例子：

![](./images/1716387310257.png)

### 除法（右移）

>对于无符号数采用的是**逻辑右移**，而有符号数采用的是**算术右移（补1/0）**

![](./images/1716387410612.png)
会遇到除不尽的情况：

3.14向零舍入的结果是3，-3.14向零舍入的结果是-3
(1)正数，向下舍入
(2)负数，向上舍入

![](./images/1716387551637.png)
**无符号数除以2的幂的情况**

![](./images/1716387617719.png)

> x >> k：进行右移K位

![](./images/1716387703072.png)
> x << k: x左移K位 = x1 × 2^(k)

![](./images/1716387765773.png)
>x1 左移 k位 与 x2 相加之和 与 x 相等。

![](./images/1716387802411.png)
>由于 x2 的长度为 k 位， 因此 x2 的取值范围大于等于 0 ，小于2 的k 次方
>x 除以 2 的k次方，取整的结果 = x1


**补码**

![](./images/1716388137432.png)
>特别注意：当需要舍入时，移位导致 -771.25 向下舍入为 -772
>我们期望得到的结果是-771。
>因此需要加入偏置，修正这种不合适的舍入。



![](./images/1716388288065.png)
>当右移四位时，偏置量 = 15（1 << 4 -1)
>当右移八位时，偏置量 = 255 (1 << 8 - 1)
>注意红圈的位置。

![](./images/1716388532318.png)
> (1) 先加入偏置量，再进行**算术右移**
> (2) 直接进行**算术右移**

## 2.3 浮点数 Floating Point

考虑含有小数值的二进制数

十进制表示小数：

![](./images/1716389280566.png)
二进制表示小数：

![](./images/1716389319350.png)

IEEE对浮点数的表示：

![](./images/1716389512740.png)

>以上红色的数字代表长度。
>exp与阶码的值是相关的
>frac与尾数M是相关的

浮点数的数值分为三类：
1. 规格化的值
2. 非规格化的值
3. 特殊值

![](./images/1716389645042.png)
### 规格化的值

![](./images/1716389755291.png)
![](./images/1716390044906.png)

>单精度浮点数：
>阶码的最小值是 -126，最大值是127
>小数字段：M = 1+f
>1 是 因为 我们可以调整E的取值，使得尾数M的取值范围大于等于1，小于2，既然第一位总是1，就没必要显示的表示出来。

### 非规格化的值

![](./images/1716390120377.png)
>与规格化的解释方法不同。

### 特殊值

![](./images/1716390183327.png)
>NaN 的意思是 NOT A Number.
>当阶码字段全为1，且小数字段不为0时，可以表示NaN。

**例子：8为浮点数的表示**

![](./images/1716390324819.png)

非规格化：

![](./images/1716390268317.png)

规格化、特殊值：

![](./images/1716390343016.png)

在之前进行过整型数和单精度浮点数的对比：

![](./images/1716428655044.png)
通过移位，发现二者有一段数位是相同的。

![](./images/1716428664557.png)
通过 转换 就能发现为什么会有数位相同的情况。

### 整型 转换 浮点数

整型 12345 如下，因为高位都是0，所以忽略。

![](./images/1716428777148.png)
根据规格化的表示规则，如下表示：可以发现阶码E的值=13

![](./images/1716428835769.png)
由于单精度小数字段长度为23，末端需要补0：

![](./images/1716428872383.png)
这样就获得了浮点数的小数字段。

阶码E的值=13 ，由于单精度的浮点数bias = 127 （固定值），并可以通过以下公式进行计算：

![](./images/1716428989672.png)
这样浮点数的表示就出现了。

![](./images/1716429010696.png)
由于表示方法原因，限制了浮点数的范围。

希望可以找到“最接近的值 x' 代替x”

![](./images/1716429200208.png)
IEEE定义了四种舍入方式：
1. 向偶数舍入(Round-to-even)
2. 向零舍入(Round-toward-zero)
3. 向下舍入(Round-down)
4. 向上舍入(Round-up)

**向下舍入，向上舍入，向零舍入：**

![](./images/1716430041945.png)

**向偶数舍入（向最近的值舍入）**

>当遇到两个可能结果的中间数值时（1.5，2.5），才需要进行这个舍入判断。
>一句话： **四舍六入五偶**

![](./images/1716430100015.png)
>为什么要用？
>因为如果总是用向上/向下舍入，会导致结果的平均值对于真实值略高/略低。
>向偶数舍入就避免这种偏差，让向上/向下舍入都有50%的概率。

例子：**四舍六入五偶**

![](./images/1716430381427.png)

二进制也能进行舍入：

![](./images/1716430423069.png)

## 浮点数加减乘除：
>浮点数加减法不具备**结合性**(会通过舍入丢失)
>乘法不具备结合性（溢出和舍入导致丢失）
>乘法在加法上不具备**分配性**。

![](./images/1716430587437.png)
## int , float , double

1. int ——> float
	- 数值不会发生溢出，但是可能会被舍入
		- 单精度浮点数的小数字段为**23位**，可能会出现无法保留精度的情况。
2. int/float ——> float
	- Double类型有更大的范围，可以保留精确数值。
3. double ——> float
	- float类型数值范围更小，可能会发生溢出。
	- 精度也较小，转换后还可能被舍入
4. float/double ——> int
	- 值会向零舍入。
	- 发生溢出。

# 第三章  程序的机器级表示 （上难度了）

>详细提及：C语言，汇编代码，机器代码之间的关系

## 3.1 机器级表示

C代码例子：

![](./images/1716432587240.png)

```
linux > gcc -Og -o prog main.c mstore.c
```

>其中 （第七章详细讲解）
>gcc = GCC编译器，是linux系统上默认的编译器。
>-Og = 编译选项，告诉编译器生成符合原始C代码整体结构的机器代码。
>（为了获得更高性能，会使用 -O1 -O2，但是使用高级别的会产生变形)
>-o prog = 生成可执行文件的文件名

### C代码 转换 汇编代码-S(.s)

其中用 mstore.c 看看 C代码和汇编代码之间的关系。

![](./images/1716432828256.png)
>利用linux那一行的指令，便能生成出mstore.s的汇编代码。
>其中 -S 告诉编译器GCC产生的文件为汇编文件。

大致文件内容：

![](./images/1716432934096.png)

>白色的以“.”为开头的文字： 指导汇编器和链接器工作的伪指令。（在这可忽略）
>剩下的汇编代码与源文件中的C代码是相关的。

重点：
- pushq %rbx
	- 将寄存器rbx的值压入程序栈进行保存。
	- 理解这一步操作，先理解寄存器的背景故事。
- movq %rdx, %rbx
	- 将寄存器rdx的内容复制寄存器rbx。
	- ![](./images/1716433727532.png)
	- mov q ，q是数据大小。（看后面部分的数据类型）
	- 数据传送指令有四个变种：
		- movb
			- Move byte
		- movw
			- Move word
		- movl
			- Move double word
		- movq
			- Move quarter
- call mult2
	- 函数调用。
	- 该函数的返回值会保存到寄存器rax中（本代码rax保存了x和y的乘积结果）
- movq
	-  将寄存器rax的值送到内存(rbx)中
- popq %rbx
	- 恢复寄存器rbx的内容。
- ret 
	-  函数返回。

**寄存器背景故事**

>在Intel x86-64的处理器中包含了16个通用目的寄存器。
>这些寄存器用来存放**整数数据**和**指针**
>都是%r开头

![](./images/1716433189384.png)
>还需要了解两个概念：
>1.调用者保存寄存器
>2.被调用着保存寄存器

图中，func_A 调用了 func_B，因此func_A 是调用者 ，func_B 是被调用者。

![](./images/1716433280092.png)
>由于调用了函数B，寄存器rbx在函数b中被修改了（代码内容）
>逻辑上rbx的内容在调用函数b的**前后**应该保持一致。


解决方法：**先保存，后调用，再恢复。**
**调用者(Caller)保存**

![](./images/1716433446453.png)

**被调用者(Callee)保存：**

![](./images/1716433484065.png)

具体用哪个策略，每个寄存器都不同：具体为：

![](./images/1716433522262.png)
**数据类型的大小：**

![](./images/1716433766761.png)

### C代码 转换成 机器代码-c(.o)

![](./images/1716434090787.png)
文件为二进制格式的，无法直接查看。
因此借助反汇编程序 objdump 
汇编器将汇编代码 翻译成 二进制的机器代码
反汇编器就是机器代码 翻译成 汇编代码

![](./images/1716434178164.png)
通过反汇编给出的代码：

![](./images/1716434190211.png)
>有区别，其中就和q有关。（q表示大小指示符）

## 3.2寄存器与数据传送指令

最早8086 CPU中，包含8个16位的通用寄存器。

![](./images/1716434301340.png)

CPU 扩展 32位 寄存器也扩展

![](./images/1716434329515.png)
再到现在64位CPU，寄存器已经到64位。

![](./images/1716434361207.png)
寄存器有不同的用处：

![](./images/1716434374059.png)


大多数的指令包含两部分—— **操作码** 和 **操作数**

![](./images/1716434450443.png)
**操作数**可以分为三类：
- 立即数(Immediate)
	- 在AT&T格式的汇编中，$符号开头，后面跟着整数（需要满足标准C语言定义）。
- 寄存器(Register)
	- %rdi,%rax...etc.
- 内存引用(Memory Reference)
	- (%rdi) 

### 内存引用 Memory

>要从内存中获得数据，需要**目的数据起始地址addr**以及**数据长度b**。Mb[addr]表示内存引用。


最常用的内存引用包含四个部分：
1. 立即数
2. 基址寄存器
3. 变址寄存器
4. 比例因子

其中的Imm（rb,ri,s) 是有效地址。

![](./images/1716434725258.png)
>比例因子的取值 与 源代码中 定义的 **数组类型** 是相关的。
>例如：
>char 比例因子 = 1
>int 比例因子 = 4
>double 比例因子 = 8

**内存引用的其他形式：**

![](./images/1716434920002.png)
![](./images/1716434993092.png)

### MOV 操作数 

![](./images/1716435049462.png)
>x86-64处理器有一条限制，mov指令的源操作数和目的操作数不能都是**内存的地址**。（因为内存太慢了，所以不能这样做）

如果要 Memory ——> Memory，就只能这样做了。

![](./images/1716435144633.png)
>mov指令的 后缀 与 寄存器的大小 一定得是**匹配**的。
>例如：
>&eax 32位  movl 对应
>&al 8位 movb 对应

![](./images/1716435186626.png)


**特殊情况**

>立即数只能是 **32位** 补码表示。
>扩展后带到64位寄存器中。

![](./images/1716435292053.png)
>带来一个问题，当**立即数** 为 64位怎么办？

引入movabsq，该指令的源操作数可以是任意的64位立即数。目的操作数只能是**寄存器**。

![](./images/1716435385248.png)
**例子：**

首先进行了movabsq的指令，寄存器保存数值如图所示。（注意：大端法）

![](./images/1716435489991.png)
接下进行movb，低八位发生了变化。

![](./images/1716435569053.png)
再加上：

![](./images/1716435611614.png)

再来：

![](./images/1716435625721.png)
>当movl 的 目的操作数是寄存器时，会把该寄存器的高4字节**设置为0**
>这是x86-64的规定。

当源操作数的数位**小于**目的操作数时：
>需要对目的操作数剩余的字节进行**零扩展**或者**符号位扩展**。

零扩展：

![](./images/1716435752512.png)
符号位扩展：

![](./images/1716435848535.png)

>cltq 源操作数总是 %eax， 目的操作数总是 %rax

总结：

![](./images/1716470384112.png)

## 3.3 栈与数据传送指令

>先从计算机系统的视角，看一下程序执行时数据传送的情况。
>最初，可执行文件是保存在硬盘上。
>通过shell程序，将可执行程序从硬盘加载到内存。
>此时，程序指令以及数据都保存在内存中。
>实际上，在一些程序的执行过程中，需要CPU和内存之间进行频繁的数据存取。（所以为什么内存要靠近CPU）

假设：

![](./images/1716471573223.png)

那么就得先：假设是64位处理器、%rax 为 8 Byte。

MOV Memory, Register

变量A为 long变量，因此也是 8 Byte，此时%rax就得存满变量A的数据。

如果变量A是int类型，那么就只需要4个字节来存储变量。(%eax)(低32位)

如果变量A是short类型，那么只需要2个字节，寄存器的低16位(%ax)

![](./images/1716471825404.png)
>虽然用的是不同符号，但是实际上是针对 **同一寄存器** 的 不同数位进行操作。

处理器完成加法运算和，会在通过**一条数据传送指令**将计算结果保存到内存。

>数据传输指令很常用，所以需要了解。

### 数据传送代码示例

![](./images/1716471995169.png)
其中exchange函数：

>x 放到 %rax 中

![](./images/1716473430513.png)
 >C语言所谓的指针其实就是地址。

### 程序栈

>还有两个数据传送指令需要借助**程序栈**。
>通过 push 压入栈 通过 pop 删除数据。

程序栈本质上是一个区域。图中User Stack便是。

![](./images/1716473546361.png)
栈顶在顶部，栈底在底部。

![](./images/1716473561607.png)
以下展示 pushq 的操作。

![](./images/1716473672382.png)

>pushq %rax =将%rax的数据放入栈中，等效以下两步：
>**subq $8，%rsp** 
>//这一步代表了 %rsp位置减8，从图中可知为什么要减8
>movq %rax,(%rsp)

>popq %rbx = 将栈顶保存的数据复制到寄存器rbx中，等效以下两条指令。
>movq (%rsp), %rbx
>addq $8,%rsp

>注意：popq 是通过**移动指针位置**进行删除的，并非真的删除数据。（这个是很常用的情况）
>就如同删除时数据是会保留，只有在被替代的时候才会消失。

## 3-4 算术和逻辑运算指令

### LEAQ
>功能：加载有效地址，q代表长度是4个字。
>因为64位处理器，因此不存在leab，leaw

![](./images/1716473979495.png)

![](./images/1716474035069.png)

这条指令的含义是把有效地址复制到寄存器rax中。

![](./images/1716474172037.png)
>有效地址的计算方式与之前讲到的内存地址的计算方式是一致的。

![](./images/1716474196558.png)
>这个代码并非为去内存地址(5x+7)处读取数据。
>而是将有效地址（5x+7）这个值直接写入到目的寄存器rax。

**leaq指令可以用来表示加法和有限的乘法运算**

以下scale函数代码编译后获得右侧的机器代码：

![](./images/1716474318851.png)
>其中：**x in %rdi， y in %rsi ， z in %rdx** （都是属于常规）

![](./images/1716474491264.png)

为什么不能用以下的代码？ 因为比例因子只有 1，2，4，8 。要操作就得拆分。

![](./images/1716474568826.png)

### 一元操作 Unary Operations

> 这一组指令只有一个操作数，因此操作数既是**源**，也是**目的**。

![](./images/1716474661808.png)
### 二元操作 Binary Operations

>这一组操作数包含两个：
>第一：源操作数：立即数，寄存器，内存地址
>第二：源操作数 /目的操作数：寄存器，内存地址，**不能是立即数**

![](./images/1716474735725.png)
例子：

一开始，内存以及寄存器中所保存的数据如图所示。

![](./images/1716474847496.png)
>(%rax) => 0x100地址的内存
>以下为：0x100的数据和%rcx 相加， 再存到0x100内存内。 （0x都是十六进制）

![](./images/1716474922636.png)

具体效果：

![](./images/1716475038553.png)
以下为：0x108的数据减去%rdx的数据，并再存到0x108内存中。

![](./images/1716475063261.png)

具体效果：

![](./images/1716475117190.png)
以下为：一元操作，自 +1;

![](./images/1716475150161.png)

具体效果：

![](./images/1716475181726.png)

最后一个：二元操作： SUB S,D   D <—— D - S

![](./images/1716475652708.png)
>要记住，可以多做书中习题。

### 移位运算

>**算术右移**和**逻辑右移**和C语言讲述的移位操作是一致的。

![](./images/1716476026492.png)
### 移位量k Shirt Amount

>可以是立即数，或者是放在寄存器cl中的数。（只允许%cl）
>移位量的编码范围 = 2^8 - 1 （255）

> 对于 **w位** 的操作数进行移位操作。移位量是由 寄存器cl 的 **低m位** 来决定。


![](./images/1716476202827.png)

对于指令salb ，对低3位来决定。(btye = 8 = 2^3)

![](./images/1716476239318.png)
salw，低4位来决定。(word = 16 = 2^4)

![](./images/1716476312233.png)
以此类推，双字对应的是低5位，四字对应的是低6位。


>如果数据只有8位，最多只能移动8为，如果移位9，就取9%8 = 1 ，移1位。



例子：

![](./images/1716476354656.png)
重点看这一指令：

![](./images/1716476373366.png)
第一步：

![](./images/1716476385525.png)

第二步：

![](./images/1716476401275.png)
>为什么编译器不直接使用乘法指令进行运算？ 主要是执行需要更长的时间。


### 特殊的算术指令

![](./images/1716476481894.png)
## 3-5. 指令与条件码

>在C语言中，存在条件语句，循环语句（if, while)
>根据数据测试的结果来决定操作执行的顺序。

减法指令 subq ，需要用到算术逻辑单元 ALU


![](./images/1716536426928.png)
>其中条件码寄存器（Condition Code Register）会被该运算结果去设置此寄存器。

### 条件码寄存器

>是CPU来维护的，长度是**单个比特位**。
>它描述了**最近执行操作的属性**

条件码寄存器：

![](./images/1716536588665.png)

例如：ALU执行两条连续的算术指令，t1时刻执行addq ，t2时刻执行subq
>T1 时刻 条件码寄存器 保存的是 指令1的执行结果的属性
>T2 时刻 条件码寄存器 会被 指令2 所覆盖。

![](./images/1716536643697.png)
#### 常用的条件码寄存器

**CF——Carry Flag（进位标志）**

>当CPU最近执行的一条指令最高位产生了进位时，CF = 1。
>可以用来检查无符号数操作的溢出。

![](./images/1716536793753.png)

**ZF —— Zero Flag （零标志）**

>当最近操作的结果 = 0 时， ZF = 1;

![](./images/1716536847771.png)
**SF —— Sign Flag （符号标志）**

>当最近操作的结果 < 0 时， SF = 1；

**OF —— Overflow Flag （溢出标志）**

>最近的操作导致 正溢出 / 负溢出 时 ， OF =1；

#### 条件码寄存器的值

>条件码寄存器的值是由ALU 在执行**算术和运算指令时写入的**。以下都会改变条件码寄存器的值。

![](./images/1716536993280.png)
>不同指令有不同相应的规则：
>XOR ——> CF = 0,OF = 0
>INC(加一) DEC（减一） ——> OF,ZF

**CMP指令 AND TEST指令**

![](./images/1716537148753.png)
>CMP 指令 = 根据 两个操作数的差 来 设置 **条件码寄存器。**
>和SUB 指令 很像，但CMP只设置条件码寄存器。

> TEST 指令 = 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置**符号标志位**、**零标志位**和**奇偶标志位**。
> 和AND操作很像，也是只设置条件码寄存器。


**例子（条件代码）：**

![](./images/1716537511589.png)

>注意：图中的comq  写错了，应该是 cmpq

第一步：cmpq 指令，操作 =  a - b
根据a - b 结果设置**ZF**， 当 a = b 时， ZF = 1；

第二步：sete指令 =  根据零标志（ZF） 的值 对 寄存器 al 进行赋值。

if ZF = 1 , %al = 1;
if ZF = 0 , %al = 0;

第三步 movzbl 对 %al 进行零扩展。

**复杂的例子：**

>其中，sete 变成了 setl
>指令setl 的含义 = 如果 a < b ，将%al = 1； （后缀 l = less 的缩写）

![](./images/1716537723695.png)
判断小于的情况会复杂一些，如图所示：**SF ^ OF (符号标志 异或 零标志)**
异或：两者相同  = 0 ，两者不相同 = 1；

![](./images/1716537820888.png)
根据多个例子：

![](./images/1716539196434.png)
其他的判断情况：

![](./images/1716539214103.png)

无符号数的比较情况：

![](./images/1716539230434.png)
>并不需要去记住，但了解是怎么做的！

## 3.6 跳转指令与循环

>absdiff_se  ： 计算两数之差的绝对值。

![](./images/1716540476854.png)
cmpq ——> 实现条件语句 x < y 。根据结果，设置 SF(符号) 和 OF（溢出）
jl ——> 根据 SF ^ OF 的结果判断，是顺序还是跳转到.L4处执行。


### 跳转指令

跳转指令会根据条件寄存器的某种组合来决定是否进行跳转。与上一节 set 指令意思一样。

![](./images/1716540527789.png)
>if-else 在现代CPU上处理速度可能有点低，针对这种情况，有一种替代的策略：
>使用 数据的条件转移 来代替 控制的条件转移。

另一种实现方式：

![](./images/1716540656937.png)
写法看上去差别不大，但是右侧的汇编效率就很快了。以下为对应的汇编指令：

![](./images/1716540822781.png)
重点是 CMOV ：根据**条件码的某种组合**来进行**有条件的传送数据**。当满足规定条件时，将 %rax = %rdx

![](./images/1716540862521.png)
本次代码便是只有 x >= y ，才会执行这一条指令。

![](./images/1716540924589.png)

**更多条件传送指令：**

![](./images/1716540968716.png)
>Q:为什么条件指令 比 跳转指令 的 代码效率高？（第四章会有详细讲解）
>A:这是因为现代CPU通过流水线来获得高性能。
>当遇到跳转指令时，会根据 分**支预测器** 来猜测**每条**跳转指令是否执行。此时发生错误预测，就会浪费大量时间。
>当遇到条件传送，CPU无需预测便可执行。

### 循环结构 do-while, while, for

![](./images/1716541143538.png)
汇编语言中没有给出专门的语句用于循环，循环语句是通过 **条件测试** 与 **跳转** 的结合实现的。

#### do-while

![](./images/1716541205893.png)
其中：cmpq指令 ——> 检测 (%rdi - 1) 调整：ZF 

#### while

> 能看到最大的差别就是 while() 的位置不同，do while 是**先执行后检测**， while是**先检测后执行**。

![](./images/1716543459458.png)

#### For

![](./images/1716543524079.png)


#### 循环实现n的阶乘：

![](./images/1716543555375.png)

重点是这个：For 循环 和 while 循环的汇编代码：

>除了跳转指令不同，其他皆为相同。

![](./images/1716543582177.png)

#### Switch

![](./images/1716543615765.png)

对应的汇编指令：

> 如果 n 大于 6 ，程序跳转到 default 对应的 L8 程序段。

![](./images/1716543637593.png)

对应 case0~ case6 的情况，可以通过跳转表 来访问不同分支
C代码将跳转表声明为一个长度为**7的数组**。（leaq .L4(%rip))
每个元素都是一个指向代码位置的指针。
case 4 ， case 6 相同，因此使用相同的标号
对于缺失的case 1 和 case 5 ，使用默认情况的标号

![](./images/1716543738905.png)
>与if-else 相比， 使用跳转表的有点是执行switch 语句的时间与case的数量无关的（因为只需要跳转一次）

## 3.7 过程（函数调用）

>在大型软件的构建过程中，需要对复杂功能进行切分
>过程（Procedures）提供了一种封装代码的方式

![](./images/1716544097577.png)
以**C语言中的函数调用**为例，讲述过程的机制。

假设：函数P 调用 函数Q ， 函数Q 执行完返回 函数P
这一系列操作就包括图中的机制：

![](./images/1716544174226.png)
- Passing control 传递控制
- Pasing data 传递数据
- Allocating and deallocating memory 分配和释放内存

### 栈的函数调用

在先前章节中提到：栈为 函数调用 提供了 后进先出 的内存管理机制。

![](./images/1716544279987.png)
当函数Q正在执行时，函数P以及相关调用链上的函数都会被暂时挂起。

### 栈帧

>当函数执行所需要的 存储空间 超出 寄存器 能够存放的大小时：就会借助栈上的存储空间，把这部分存储空间称为 = **函数的栈帧**

对于函数P调用函数Q的例子，包括：较早的帧，调用函数P的帧，正在执行函数Q的帧：

![](./images/1716544520626.png)
当函数P调用函数Q时，会把返回地址压入栈中： return address
该地址指明了当函数Q执行结束返回时，**要从函数P的哪个位置继续执行。**
返回地址的压栈操作 = 指令call 来实现。

以main函数调用multstore函数为例，解释 指令call 和 指令ret 的执行情况。

![](./images/1716544636997.png)
节选了相关的反汇编代码：

![](./images/1716544691336.png)

![](./images/1716544989430.png)

>callq 对应 multstore函数的调用
>指令call ： 
>1.将函数multstore的第一条指令的地址存入到程序指令%rip中，实现函数调用。
>2.将返回地址压入栈中。（地址就是函数multstore执行完的**下一个指令的地址**）

![](./images/1716544908552.png)

>当multstore执行完毕，指令ret从栈中将返回的地址弹出，写入到指令寄存器 %rip 中

![](./images/1716544930027.png)
>按照自己的语言总结：假设 一个 main函数 一个 Change函数
>main函数调用  Change时： change的函数首地址存放在 %rip 中，其次生成一个返回地址（利用指令ret），该地址为调用的下一个代码地址。
>在执行完毕后，就会到指令ret ，就会把栈中的返回地址弹出，弹到 %rip 中，这样就回去了。

### 参数传递

>如果一个函数的参数数量 > 6 ，超出的部分就要通过**栈来传递**。

![](./images/1716545399436.png)
>**参数1~参数6 相对应的寄存器（这个是固定，得记一记）**
>%rdi , %rsi , %rdx , %rcx ,%r8 ,%r9
>(di,si,dx,cx,8,9)
>寄存器也有特殊顺序规定：

![](./images/1716545409370.png)
![](./images/1716545654011.png)


>栈指针是 %rsp 里面存的地址

![](./images/1716545517240.png)
>注意：
>第一：通过栈来传递参数时，所有数据的大小都是向8的倍数对齐（无论如何）
>第二：返回地址占用了栈顶的位置（栈顶是最底位置），所有两个参数是+8,+16...


### 局部变量

>函数caller 定义了两个局部变量 arg1 , arg2

![](./images/1716545708354.png)
>函数caller 对应的 汇编代码

![](./images/1716547655007.png)

本次汇编代码如下：

- subq
	- 在栈上分配16个字节的空间(图1-1)
- movq 
	- 一个534 存储在 (%rsp)
	- 一个 1057 存储在 8(%rsp) （图1-2）
- leaq 
	- 功能：加载有效地址，q代表长度是4个字。
	- 将 8(%rsp) （地址） 写入 %rsi 
- movq
	- %rdi (第一个寄存器) = %rsp (内存)（这个位置的数值是534)
- call swap
	- 调用swap函数，把两个数值对调。
 - movq 
	 - %rdx(第三个寄存器) = (%rsp) (内存)（第一个位置）
- subq
	- %rdx = %rdx - 8(%rsp) (内存，第二个位置，数值 = 534)(已经swap了)
...
- addq
	- 通过对栈顶指针 + 16,释放栈帧。
![图1-1](./images/1716547728850.png)
![图1-2](./images/1716547879374.png)


另一个例子：

x1 = 8字节， x2 = 4字节 x3 = 2字节 x4 = 1字节

![](./images/1716548478755.png)
>注意：**传递的参数**需要8个字节**对齐**，而**局部变量**是**不需要对齐的**

>总结：
>当函数运气需要局部存储空间时，栈提供了内存分配与回收的机制。


>在程序执行的过程中，寄存器是被所有函数共享的一种资源。
>避免数据覆盖的问题：所以有通用惯例，如下：

除了寄存器rsp之外，其他如下定义。

![](./images/1716548654284.png)
例子：

![](./images/1716548751817.png)

递归调用的例子：

![](./images/1716548767388.png)

![](./images/1716548818532.png)

## 3-8 数组的分配和访问

基本概念：

char的地址和int的地址概念：
>addr(A[i]) = xa + i (原因char = 1 byte)
>int = 4 byte

![](./images/1716555796764.png)

在C语言中，允许对指针进行运算

例子：

>对指针进行运算时，会根据该指针的引用的数据类型 进行**相应的伸缩**

![](./images/1716560134506.png)
再来一个例子：

对于数组的每一个元素都有两个属性：**1.存储的内容** **2.存储地址**

![](./images/1716566106562.png)
> E[2] = 访问内容
> *（E + 2) = 也是访问内容（理解为 该地址处取数据）（引用）

>C语言的指针其实就是**地址的抽象表述**

### 嵌套数组（二维数组）

![](./images/1716566482678.png)
>行优先排列成一行。

**计算数组元素的地址：**

![](./images/1716566530505.png)
Xd = 起始地址
L = 数据类型T的大小
C = 每个小单元的大小，常数。
i，j = 元素位置（非地址），常数。

例子：

![](./images/1716566649797.png)

**利用汇编代码：**

![](./images/1716566689472.png)
### 定长多维数组的优化

>这个代码是用来计算矩阵A的 第i行 与 矩阵B 的 第k列 的 内积

![](./images/1716566757786.png)
**汇编代码**访问数组元素部分：

>编译器进行了优化，所以会有点晦涩难懂。

![](./images/1716566873549.png)

>首四行是用来计算 3个数组元素的地址：
>1. 数组A第i行的 首个元素的地址
>2. 数组b第k列 的 第一个元素 
>3. 数组b第k列 的 最后一个元素


>然后分别放到不同的寄存器中。引入三个指针，方便阅读。\*Aptr , \*Bptr , \*Bend

![](./images/1716567057686.png)
>接下来就是循环部分的实现：

![](./images/1716567069450.png)
movl = 读取 \*Aptr 的数据
imull = \*Aptr 的元素 与 \*bptr 的元素 相乘
addl = 将乘积结果进行累加，保存到%eax
addq = 对Aptr 移动 4 byte （因为int 是 4 byte）
addq = 对Bptr 移动 64 byte (因为数组B一行元素有16个，每个元素占4个字节，因此**相邻列元素**的地址相差6字节)
cmpq = 判断 Bptr 和 Bend 是不是指向 同一个地址。如果二者不相等，就跳转到L7继续执行。

>其中 addq 是很巧妙的一个设计。

### 变长数组

>C89的标准中，程序员在使用 **变长数组**时 需要使用 malloc 这类函数，为数组动态分配存储空间。
>ISO C99标准中，引入了 **变长数组** 的概念。

图中便是变长数组，它可以作为局部变量，也可以作为函数的参数。

![](./images/1716567504897.png)
>变长数组元素的地址计算与定长数组类似，不同的是多了n。
>需要使用乘法指令来计算 n 乘以 i

![](./images/1716567577147.png)

![](./images/1716567659400.png)


对比二者的方法，就能看到了。

![](./images/1716567915545.png)
## 3.9 结构体与联合体

![](./images/1716568081364.png)
>图中的汇编代码是 将 字段i 的值复制到 字段j 。

![](./images/1716568160085.png)
这个就是读取地址：

![](./images/1716568176087.png)

>重点总结：
>无论是单个变量 还是 数组元素：都是通过 **起始地址** 加 **偏移量** 来访问。

### 地址对齐

>若直观的看，认为只有9字节的空间。但其实是12字节。
>其实是因为系统对于数据存储的合法地址做出了一些限制：
>例如 变量j 是 int 类型，所以它的**起始地址** **必须是 4的倍数**。（重点：是起始地址）

![](./images/1716568291781.png)
地址对齐的原则表格：（重点）

![](./images/1716568376002.png)

另外：虽然可以通过这样来进行9个字节的分配，但是！是无法满足所有数组元素的对齐要求，所以编译器自动的还是会补3个字节（末端）。

![](./images/1716568470763.png)
展示一个结构体的数据对齐

![](./images/1716568666751.png)

>每个白色的框都是为了进行对齐而出现，都是为了**后一个数据的对齐**。


### 联合体

>联合体中的所有字段共享同一存储区域。
>联合体的大小 取决于 它 最大字段的大小

图中，变量v 和 数组 i 都是占 8字节，所以就是8byte。

![](./images/1716568822062.png)
>联合体的一种应用情况就是，我们事先知道两个不同字段的使用是互斥的，那么就可以声明为一个联合体。

二叉树：
内部结点：不含数据，但有指向两个孩子节点的指针
叶子结点：都有两个double类型的数据值

我们事先知道 二叉树的任意一个节点不是 内部节点 就是 叶子节点

我们可以用联合体来定义节点：这样每个节点就只需要16byte的存储空间了。（结构体定义方式 32byte）

![](./images/1716569072967.png)
一个问题，没办法确定一个节点是 叶子 还是内部。
解决方法：引入一个枚举类型，创建一个结构体（包含一个标签，一个联合体）

![](./images/1716569144717.png)

联合体还可以用来访问不同数据类型的**位模式**

当我们使用简答的强制类型转换：强制把 double d 转换为 unsigned long （此时位数差距很大）


![](./images/1716569235381.png)
>将这两个类型的变量 声明 为 一个联合体，
>这样可以以一种类型来存储，以另外一种类型来访问。
>这样就会存在相同的位表示了。

![](./images/1716569269723.png)

## 3-10 缓冲区溢出

>栈帧，会保存程序执行所需要的重要信息：返回地址，保存的寄存器的值等。
>在C语言中，不会做任何的边界检查，如果越界写操作，就会破坏信息。

![](./images/1716601150317.png)

>gets : 标准输入读入一行字符串，在回车或者某错误停止。
>gets 函数 无法确定 是否有 足够大的空间 来保存整个字符串。

>实际分配了24byte的空间。

![](./images/1716601342523.png)
如以下情况，只要输入字符串不超过 23 时，不会发生严重后果。超过以后，返回地址以及更多状态信息就会被破坏。
历史上，缓冲区溢出就是病毒的首要攻击地方。

![](./images/1716601400388.png)

>现代计算机有多个对抗的手段（机制）。

![](./images/1716601470009.png)
### 栈随机化

>之前，程序的栈很容易被预测。因此知道了，就会可以攻击。
>栈随机化的思想：在程序每次运气时都有变化。

如图所示，64 Linux 的随机范围：

![](./images/1716601606175.png)
标准行为：地址空间布局随机化 （Address-Space Layout Randomization，ASLR）

### 栈破坏检测

>**汇编代码**中栈保护者的机制检测缓冲区越界。
>就是缓冲区与栈保存的状态值 之间 存储一个 特殊值 ： 金丝雀值(煤矿工人判断有毒气体含量)
>金丝雀值是**随机产生的**

![](./images/1716601821473.png)
看看例子如何避免栈溢出攻击：

![](./images/1716601837390.png)
movq %fs:40（内存地址，只读段） %rax 
movq %rax 8(%rsp)

图中两行代码内存中读取一个数组，该数组放到栈上（金丝雀值）

函数范围之前，通过xor来判断金丝雀值是否被更改，

### 限制可执行代码区域

![](./images/1716602029022.png)
内存保护引入了不可执行位：将可读和可执行 访问模式分开了。
这样就可以标记为可读，可写，但不可执行。

# 第四章 处理器体系结构

### 指令系统结构

Instruction Set Architecture 指令系统结构

程序员根据指令系统设计软件；处理器设计人员根据指令系统实现硬件。

X86太复杂，所以参考这个，自定义了一个Y86-64

### Y86-64 指令集体系结构(重点)

>程序员：汇编代码写程序的人 / 机产生机器级代码的编译器
>可见状态：每条指令都会去读取或者修改处理器的某些部分
>例如：内存，寄存器，条件码，程序计数器，程序状态等。

![](./images/1716602562696.png)
> %rsp 栈指针。
> 程序计数器PC = 保存当前执行指令的**地址！**
> 状态码 = 程序状态

X86-64 的 movq 指令 简化，分成四种不同的指令：

>直接通过movq前缀就知道源操作数和目的操作数：
>r = register
>i = immediate
>m = memory

![](./images/1716602831366.png)
**编码：(重点)**

> 第一个字节：表明指令类型。其中：
> （高）4bit = 指令代码 Instrction code
> （低）4bit = 指令功能 instrction function
> 第二个字节：当有寄存器类型的操作数时，这个会附上。：寄存器指示符字节。
> 

![](./images/1716602970821.png)
>寄存器的编号：
>其中：**用F就是此处没有寄存器操作数。**

![](./images/1716603121364.png)

四条整数操作指令，只能对寄存器数据操作（X86能对内存数据操作）：

>除了功能部分，其他都相同。

![](./images/1716603261204.png)

跳转指令一共有 7 条：
>也是根据**条件码的某种组合**来判断是否进行跳转

![](./images/1716603297176.png)

条件传送指令 6 条：

>与数据传送指令 rrmovq 有相同的指令格式。
>只有条件码满足条件时，才会更新目的寄存器的值。

![](./images/1716603345104.png)


halt 系统暂停运行
nop 空指令
call 函数调用
ret 返回
push 入栈
pop 出栈

![](./images/1716603440281.png)

>以上就是Y86的规则。

我们可以将 Y86-64 的汇编代码翻译成 **二进制** 表示：

![](./images/1716603617356.png)
根据规则：

![](./images/1716603630386.png)
首先，第一字节的 4 ，0 直接写入。
其次：第二字节的 rA ，rB 对应 %rsp , %rdx ，查表可得。 4 与 2.
最后：偏移量有 8byte，需要补齐才能放入。同时X86用的是**小端法**，最小的放最前。

![](./images/1716603722508.png)
最终得：

![](./images/1716603641331.png)
### 状态码

1.AOK 没问题
2.HLT 执行了暂停 
3.ADR 程序在试图 从 非法地址读取数据 / 非法地址写入数据
4.INS 遇到非法指令

![](./images/1716603838327.png)

### 4.2 数字电路与处理器设计

> 寄存器的集合称为**寄存器文件（一切皆为文件）** 或者称 **寄存器堆**

>在CPU内部，寄存器文件和算术逻辑单元（ALU）是**串联**的
>寄存器的输出端口，与ALU的输入端口相联。

![](./images/1716604991371.png)
以寄存器文件为例，解析它的具体实现，阐述CPU设计与数字电路之间的关系。


### 寄存器文件

>有一个读端口（d_out) 和 一个 写端口(d_in) ，数据位宽 64 位
>读写操作共用地址线(addr)，定义了15个程序寄存器，所以4位即可。
>时钟信号(clock)，复位信号(reset)，写使能信号(we_)

![](./images/1716605076758.png)
>可以使用硬件描述语言（HDL） 对寄存器文件进行 **行为级建模**
>通常的硬件描述语言： Verilog ， VHDL

图中：Verilog 程序就是对 寄存器文件的描述。

![](./images/1716605336076.png)
采用 电子设计自动化（EDA） 工具对这段程序进行 逻辑综合。

![](./images/1716605413015.png)

#### 寄存器文件的内部结构

当执行读取操作，使用地址线来存储寄存器的编号。
**多路选择器**根据地址信号筛选出寄存器的值。
最终数值通过输出信号输出。

>红色线：时钟信号，白色线：复位信号（后续观看暂时省略掉）

![](./images/1716605541477.png)

>执行写操作需要确定三个参数：1.目的寄存器ID，2.写入的数据，3.是否能够写入
>说白： 能不能写，往哪儿写，写什么！

>能不能写：看**we信号**（write enable）
>写什么： 看**data信号**
>这个例子中地址信号线是 读操作 和 写操作 共用的。
>往哪儿写：**地址解析后的信号** 和 **we信号**

图中便是比较详细的寄存器描述。

![](./images/1716605770290.png)
>还是存在一些疑问：
>1.多路选择器是怎么实现的？
>2.虚线框里的寄存器又是如何存储数据的（我感觉在CCCS中看过，和与或非门有关（就在第6集（寄存器与内存）中）

番外内容：(锁存！)

![](./images/1716606118416.png)

![](./images/1716606169224.png)
允许写入线，让门锁打开，就可以写入数据。关闭后，就可以保存数据了。(Memory!)

![](./images/1716606211415.png)

### 逻辑门


>逻辑门是数字电路的基本计算单元。
>与，或，非门。
>输出 = 输入值按位进行相应的布尔运算。
>逻辑门 由 晶体管级电路实现的。


![](./images/1716606427251.png)
>在现代计算机中，晶体管通常是指基于CMOS（Complementary Metal-Oxide Semiconductor，互补金属氧化物半导体)工艺的。
>两种晶体管，一种N沟道MOS晶体管，简称N管
>另一种叫 P沟道 MOS 晶体管，简称P管。


![](./images/1716606621557.png)
P管 N管 串联起来实现 非门。
二者 漏极 连接 作为输出。
栅极 连接 作为输入。
P 管的源极 接 电源。
N 管的源极 接 地。

![](./images/1716606650761.png)

![](./images/1716606756647.png)


![](./images/1716606766255.png)
在CMOS工艺中，与门 和 或门 不如 **与非门** 和 **或非门** 高效。

![](./images/1716606808021.png)
### 多路选择器/多路复用器 Multiplexor

>最后一个逻辑门画错了，应该是OR的逻辑门。

![](./images/1716606831040.png)

通过情况下，寄存器文件内的存储部件是由**D触发器**实现的。

![](./images/1716607015338.png)
D触发器的门级实现：

![](./images/1716607035992.png)

目前，电路的逻辑设计通常采用硬件描述语言来实现，然后采用电子设计自动化（EDA）工具进行综合和后端设计。

### D触发器的Verilog实现。


>dfilpflop表示模块的名称，D,C,G = 输入， Q = 输出。
>always = 当时钟C 上升的时候，if G = 1 ，就把 输出Q = 输入D的值 ，否则不变。

![](./images/1716607238937.png)
Verilog 是**并行执行**， C程序是 **串行执行**的。

Verilog 语言需要知道这个。

![](./images/1716607301419.png)
Verilog 做设计只用三种语句：

![](./images/1716607346602.png)
## 4-3 Y86-64 的顺序实现

Y86-64的规则：

 ![](./images/1716651048429.png)

例子：

本代码：计算数组的元素之和。

![](./images/1716651169431.png)
除了数据传送指令，其他的指令于X86指令差异不大。

Y86汇编器，图中汇编代码翻译称二进制指令。

![](./images/1716651281694.png)
>实现所有Y86指令所需要的计算 = 6个基本阶段
>：**取值，译码，执行，访存，写回，更新PC** （重点）

![](./images/1716651367934.png)

### 取值阶段 Fetch

>所有指令都是需要的。
>还会根据指令代码来判断指令是否含有寄存器指示符。是否含有常数，从而计算出当前指令的指令长度。

### 译码阶段 Decode

>从寄存器种读取数据。
>寄存器文件有两个读端口，可以支持同时进行两个读操作。

![](./images/1716651717241.png)

### 执行阶段 Execute

> 算术逻辑单元ALU 主要执行三类操作。
> 1.执行算术逻辑运算
> 2.计算内存引用的有效地址
> 3.针对push 和 pop 指令。

![](./images/1716651773852.png)

### 访存阶段 Memory

>对内存的读写操作
>既可以从内存读出数据，也可以数据写入内存。

![](./images/1716651872764.png)

### 写回阶段 Write Back

> 此阶段于译码阶段类似，都是对寄存器文件的操作。
> 不同：译码阶段是 **读**寄存器文件，写回阶段 是**写**寄存器文件

### 更新PC  Update

>将PC设置成下一条指令的地址。


### 例子1：减法指令
通过例子来看看操作：

本次例子为减法指令。

![](./images/1716652648452.png)
>取值阶段，valP = PC + 2 （2是因为长度为2）
>译码阶段，根据寄存器指示符，读取寄存器的值
>执行阶段，执行具体运算，set CC（条件码寄存器）
>访存阶段，不需要读取内存
>写回阶段，把数据写回寄存器文件夹中。
>更新PC，PC移到下一个指令。

![](./images/1716652977609.png)
### 例子2：数据传送指令irmovq

>i = 立即数 r = register 寄存器
>操作：将一个立即数 传送给 寄存器

![](./images/1716653184743.png)
>注意：执行阶段 使用ALU 对 常数进行加0

![](./images/1716653324445.png)
### 例子3.指令pushq

![](./images/1716653533396.png)

![](./images/1716653717155.png)

### 例子4：跳转指令je

![](./images/1716653746672.png)

>执行阶段： cond的硬件单元会根据**条件码 CC**和**指令功能 ifun**来判断是否执行跳转。
>这个模块产生一个信号Cnd 。 cnd = 1 跳转； cnd = 0 ， 不执行跳转；

![](./images/1716653898872.png)
## 4-4 Y86-64处理器硬件结构

### 取值阶段

>以程序计数器（PC）的值作为起始地址。
>每次从指令内存中读取10个字节。：在取之前无法判断当前指令的长度。取10个可以保证获取一条完整的Y86-64指令。

![](./images/1716654678313.png)
然后分层两部分：

![](./images/1716654701758.png)
>Instr vaild = 判断这条指令是否是一条合法的指令
Need regids = 是否包含寄存器指示符
Need valC = 是否包含常数字节
通常看第一个就已经可以判断 指令长度了。
下一条指令的地址：通过当前PC值 + 当前指令的长度计算出来。


![](./images/1716733473658.png)
>Align单元：
>可以产生 寄存器字段rA,rB 和 常数字段valC
>当need_regid = 1 ，该指令包含寄存器指示符字节。
>那么第一字节将被分层两部分，每一部分占 4 bit，分别转入 rA，rB
>当 need_regid = 0 ， 没有 寄存器指示符。
>此时 rA，rB = 0xF。
>当只含有1个寄存器操作数，另外一个字段 = 0xF

![](./images/1716733808099.png)
>如果含有常数，align单元还产生 常数字段valC
>当 need_regids == 1 ，2~9字节 = valC
>当 need_regids == 0 ， 1~8 字节 = valC


![](./images/1716733875204.png)

### 译码阶段

>寄存器文件：两个读端口(srcA,srcB)，读出输出（valA,valB)
>下面的srcA，srcB -> 产生寄存器的ID值
>iCode 是 指令方式（有些代码需要读取%rsp（栈顶指针)（右边的指令，只含有目的寄存器）

![](./images/1716734254267.png)

### 执行阶段

>算术逻辑单元，ALU
>条件码CC = ZF（零），SF（符号），OF（溢出）
>根据ifun（指令功能） 来 判断 进行何种计算。

![](./images/1716734546796.png)
### 访存阶段

>从内存中读数据，或者写入数据。
>读控制块，写控制块
>产生内存地址，输入数据的控制块。
>注意：最后，会根据信号来计算状态码stat

![](./images/1716734587182.png)
### 写回阶段

>将数据写入寄存器文件。
>写端口：M，E ，对应地址输入 dstE dstM
>写入操作要根据 执行阶段的 cnd信号：不满足条件，目的寄存器设置0xF 来禁止写入寄存器文件。

![](./images/1716734629348.png)
### 更新PC

>四种情况：
>1.call Dest ——> 新PC = call指令的常数字段
  2.ret ——> 在访存阶段会从内存（栈）中读出返回地址，新PC值 = 返回地址。
  3.jxx Dest（跳转） ——> cnd信号 = 1（满足跳转条件） 新PC = 常数字段
  4.Other Instructions ——> 新PC = 当前PC的值 + 当前指令长度

![](./images/1716734801827.png)

![](./images/1716735210116.png)


>指令执行速度太慢了，需要流水线。

## 4.5 流水线的通用原理（重点）

未流水化的硬件设计

三条程序顺序摆放，就可以得到流水线。

![](./images/1716802433932.png)

>电路的延迟 = 皮秒ps = 1 X (10)^(-12) （秒）
>延迟 = 一条指令从开始到结束的时间

### 吞吐量

>GIPS 每秒千兆条指令

![](./images/1716802510068.png)
>电路设计中，需要注意的是寄存器 
>其中：时钟信号 直接将它的 输入 和 输出 连接到电路中，
>寄存器输出就是寄存器的状态值。
>但输入时，会受到时钟信号的影响，当时钟 低电平，不会立即 发生变化，只有在 高电平 时 才会发生变化。

![](./images/1716802878396.png)
### 流水化

时钟周期设置 120ps，那么这个代码就需要 3个完整的时钟周期。
图中：comb.Logic 组合逻辑单元

![](./images/1716802928731.png)


![](./images/1716803139596.png)

### 流水线计算的时序和操作

>指令在流水线各个阶段的**转移**是由 时钟信号 来控制的
>每隔120ps，信号从0上升1，流水线开始下一个阶段的计算

指令1用青色表示，指令2用金色表示，指令3用蓝色表示

![](./images/1716803504753.png)

![](./images/1716803552518.png)

![](./images/1716803568086.png)

![](./images/1716803577176.png)

>用我的理解和话语来讲：闯关游戏。
>每个Comb.Logic都是一个关卡，而reg是中场休息关，然后这些之间的位置就是门。图中所画的就是门。当时钟信号 = 1时，这些门就会开，这样就可以到reg里，当时钟信号 = 0 ，这些门会关闭。
>抽象的说：只有门开了寄存器才会记录。才会移位。


上述只是理想化的情况，在现实中，个个延迟都不等。

![](./images/1716803846398.png)

![](./images/1716803881374.png)

>过多流水线也会导致系统性能的下降

![](./images/1716803919725.png)
### 数据依赖 / 数据相关

![](./images/1716804009804.png)

### 控制依赖

>跳转指令。

![](./images/1716804035007.png)
在顺序结构中，这些相关是通过反馈来解决的。
不过，反馈路径是很危险的。

![](./images/1716804113850.png)

## 4.6 流水线硬件结构


### 顺序结构：
>取指阶段：
>iCode = 指令代码 4 bit
>ifun = 指令功能 4 bit
>valC （常数字段）= 8 字节
>PC Inc = PC增加器
>valP = PC 加上当前指令的长度。
>
>译码阶段：
>Reg File 寄存器文件 ——> A,B 两个读端口
>
>执行阶段
>ALU 根据 ifun 来进行运算
>valE = 计算结果
>CC = 条件码
>Cnd = 信号（用于影响跳转）
>ALU除了算数，还要计算访存的有效地址，以及针对栈指针的运算（+8,-8的操作）
>因此：ALU的输出端口会与数据内存的地址逻辑单元相连。
>
>访存阶段
>valP ——> Data  错了，应该是 valC ——> Data 
>写入内存，读取内存。
>写入的数据 可以由 寄存器文件 提供， 也可以是 指令中的常数字段（valC）
>
>写回阶段
>寄存器文件有两个写入端口M，E
>valE ——> E, Memory ——>
>
>更新PC
>根据 当前执行的指令 以及执行的状态来进行 判断。
>iCode，Cnd（跳转），valC



![](./images/1716804657941.png)
### 电路重定时

改进：**电路重定时** 改变了系统的状态表示：更新PC在开始的时候执行。

![](./images/1716804752202.png)


### 顺序结构 ——> 流水结构


顺序结构：
![](./images/1716804801313.png)

流水结构：
![](./images/1716804790783.png)
#### 五级流水线的硬件结构

> 第一个寄存器F：
> predPC PC预测值


![](./images/1716804938054.png)

## 4.7 数据冒险

### 代码示例流水线情况：

> F:Fetch(取指) D:Decode(译码) E:Execute(执行) M:Memory(访存) W:Write Back(写回)

时间从左到右变大，在 第 5 个 时钟周期时，整个流水线中同时在执行5条指令。通常都会用这个流水图来表示流水的状态。

![](./images/1716815996511.png)
### 数据冒险/冲突

在这个示例中：指令irmovq 和 指令 addq 之间存在 数据相关。
addq需要前两个指令结束后的数据结果。
但是按照流水线，第一指令还没在访存阶段，还没写回，第二指令在执行阶段。
因此addq 就变成了 0 + 0 的情况了。

如果这种 数据相关 导致了 流水线产生错误的结果 ——> 数据冒险/冲突


![](./images/1716816614917.png)
**避免冒险：**

>法一：
>先暂停addq指令，等指令1和指令2执行完，再执行addq。
>思考：需要判断什么时候执行暂停，如何实现暂停，还有暂停多久。
>方法：指令在译码阶段读取寄存器时，通过读取寄存器的ID值分别与**执行阶段（E）**，**访存阶段（M）** 以及 **写回阶段（W）** 所执行指令 的 目的寄存器进行对比。如果存在相等，数据存在相关。
>此时就插入气泡bubble。

![](./images/1716817158988.png)
法2：直接把运算结果传给addq指令（**数据转发，旁路**）

irmovq在 访存是没有执行任何东西的。

![](./images/1716817215062.png)
多加了两个**逻辑块**。

![](./images/1716817289265.png)
还有一类数据冒险不能单纯的使用转发来解决。

>这个mrmovq 需要读取内存空间
>这个时候就需要结合 暂停 和 转发 一起了。

![](./images/1716817489285.png)

>重点总结：解决冒险的方法：暂停（Bubble)、转发(旁路）。

## 4.8 控制冒险

### 控制冒险发生

在流水线设计中，我们期望每个时钟周期都能完成一条指令的执行。
流水线在每个时钟周期都要取到一条指令。
因此每次取指操作后，必须马上确定下一条指令的地址。

情况一：
当取出的指令是**返回指令ret**。
下一条指令要在栈中读出，
必须 **访存操作（M）** 结束后才能确定下一条指令的地址。

情况二：
取到的指令是**分支条件指令**。
跳转操作的判断，这一部分需要经过**执行阶段（E）**，才能确定是否进行跳转。

![](./images/1716817895753.png)
### 示例代码：返回地址ret指令
白色字为地址。
第一个 irmovq 初始化栈指针
call 函数调用

![](./images/1716817969524.png)
根据指令的执行顺序：

通过暂停来避免（Bubble）

![](./images/1716818112399.png)
### 示例代码：跳转指令 jXX指令

避免控制冒险（Avoiding Control Hazards）

>假定一个策略：**分支预测（Branch Prediction）**

![](./images/1716818267568.png)
示例代码：

![](./images/1716818254037.png)
if 当遇到分支，总是执行：

>情况：首先让irmovq $2 和 irmovq $3 跟着流水线进去了。
>结果当jne到 执行阶段（E）发现是不用跳转的。
>就对刚刚两个指令当前阶段进行插入气泡，把他两个剔除（并非暂停）。

![](./images/1716818455839.png)
### 暂停和插入气泡如何实现

>流水线寄存器，是通过 **时钟的上升沿** 来改变输出的值。
>设置暂停信号和插入气泡信号，就可以实现了。
>当暂停值 = 1，寄存器保持以前的状态（一直）。
>气泡信号，寄存器状态 = 某个固定的复位配置 等效于 nop 状态。

![](./images/1716818820803.png)

假如：寄存器E中插入气泡，那么就：
在寄存器E中的iCode 字段 = INOP
dstE = dstM = srcA = srcB = RNONE
这样就达到与指令NOP一样的效果。

![](./images/1716818945399.png)

>重点：
>返回指令ret ——> **访存阶段（M）** 后，用的是**暂停**
>跳转指令jxx ——> **执行阶段（E）** 后，用的是**分支预测**。
>控制冒险的处理方法：流水线插入**气泡来解决**。

## 4.9 Y86-64的流水实现

### 取值阶段

>最复杂的地方：如何预测下一条指令的地址（Next PC Prediction）
>指令地址无非就两种情况： 1.顺序执行，2.跳转执行
>顺序执行：valP = 当前指令的地址 + 当前指令的长度
>跳转执行：跳转：直接将 **常数字段（valC）** 作为下一条指令的地址。
>实际分支预测的效果很复杂。
>ret难以预测，不会尝试对返回地址做预测。因此放到顺序执行方面。
>PC预测逻辑单元会根据指令类型（icode），来预测下一条地址是 valP / valC


![](./images/1716821166016.png)
#### 纠错部件(PC Select PC选择逻辑单元)


>改正的方法：读取信号
>W = 寄存器W（写回），M = 寄存器M（访存）
>ret指令：
>W_icode （指令类型）：如果是判断出ret指令，则 PC = W_valM
>W_valM (访存结果) 
>
>跳转指令：
>M_icode
>M_Cnd(跳转信号)
>M_valA(下一条指令的地址)

![](./images/1716821641711.png)


### 译码阶段(重点)

>数据转发的机制
>主要根据寄存器ID 从 寄存器文件 中读取数据
>寄存器ID = rA ， rB ，经过srcA 和 srcB 逻辑单元输入到 寄存器文件
>最终译码的结果 = valA ，valB
>提高流水线效率，引入 **数据转发** ： Sel + Fwd A , Fwd B
>判断的依据：当前需要读取寄存器的ID值 = 转发目的寄存器的ID值 ？
>其中：e_detE , e_valE , M_dstE , M_valE , M_dstM , M_valM, W_dstM,W_valM,W_dstE,W_valE
>E = 执行 / 寄存器E，M = 访存 / 寄存器M，W = 写回 / 寄存器W 。
>其中白色是寄存器ID值，红色是转发数据
>如果不满足上述所有的转发条件：
>选择从寄存器文件的 **A端口** 读出的数据作为输出。
>Sel + Fwd A 逻辑单元扮演了两个角色： 多了valP的输入（比起 Fwd B），实现了valP valA 信号的合并功能。
>valP表示 顺序执行时，下一条指令的地址，valA 寄存器文件中读到的数据。
>只有在 函数调用指令 和 跳转指令 在后面阶段才需要用到valP
>这两类指令 并不需要 从寄存器的A端口读取数据。
>所以可以根据 指令代码 icode 来判断当前指令 是否属于这两类。


![](./images/1716822291275.png)

## 4.10 流水线的控制逻辑

处理流水线的冒险以及异常情况，我们需要在设计中添加 控制逻辑单元（Pipeline Control Logic）。

### 加载/ 使用 冒险

>顺序出现，二者出现 数据相关
>mrmovq 和 pop 都有机会。

![](./images/1716877182872.png)
>mrmovq 在执行阶段，而 addq 在译码阶段的时候：
>mrmovq 进行完访存阶段，然后把数据转发给addq中。
>具体解决方法： 保持流水线寄存器F，D的状态不变，E插入一个bubble。

![](./images/1716880388848.png)


### 分支预测发生错误

> 跳转指令达到 **执行阶段**时 可以检测到 **预测错误**
> 下一个时钟周期 需要取消两条已经取到的指令。
> 具体的解决方法： 向流水线寄存器D和E 中插入气泡。

![](./images/1716880496663.png)
### 返回指令的处理

> 指令ret 需要经过 译码，执行，访存阶段之后才能读到下一条指令的地址。
>具体实现方法：插入三个bubble，浪费掉三次的时间周期。

![](./images/1716880571788.png)

>控制逻辑操作 = 出现特殊情况时 ： 通过 **暂停** 和 **插入气泡（清零）**

### 组合特殊情况

#### 返回 + 跳转

> 假设 ZF = 1 ，不发生跳转，则应执行irmovq。
> 而流水线代码在跳转时 保持 “一定跳转” 的情况。
> 所以就会发生图中的情况，ret 已经到了decode阶段。
> 此时就需要把F stall ， D和 E 插入一个Bubble，把ret 清零，
> 然后jne 所做出来的M寄存器会有 下一个PC的地址，给到Fetch阶段即可。

![](./images/1716880864227.png)
#### 加载 / 使用冒险 + 返回指令

> 其中：加载 目的寄存器是 %rsp
> 返回 默认使用的也是 %rsp

>图中对两种指令的情况都做了控制，显然是不合理的。
>对这种组合需要进行特殊的处理。

![](./images/1716881209561.png)
### CPI（一条指令的时钟周期数） —— Cycles Per Insturction

Cb/Ci  = 惩罚项 （一条指令平均要插入多少 bubble）
lp = load penalty (加载/使用冒险暂停时插入气泡平均数)
mp = mispredicted branch penalty （分支预测错误取消指令时 插入气泡的 平均数）
re: return penalty (返回指令 造成暂停的 插入气泡的 平均数)

![](./images/1716881481322.png)

![](./images/1716881544950.png)
# 第 五 章 优化程序性能

1. 选择合适的算法和数据结构
2. 编译器的能力和局限性
3. 探索并行化

![](./images/1716881713767.png)

## 5.1 优化程序性能（一）

> add1 需要执行 6 次 内存引用: 两次读xp指向的内存位置，两次读yp的内存位置，两次写xp的内存位置
> add2 3次，1次 读xp指向的内存位置，1次 读 yp ，一次写xp

![](./images/1716882120257.png)
>但存在问题：所以不能轻易的用
>If xp 和 yp 指向同一个内存位置，就会出现以下情况：

![](./images/1716882214712.png)
>妨碍优化的因素：内存别名引用，函数调用

### 内存别名引用

> 内存别名引用 ——> 两个指针指向同一个内存位置

图中上方的是不同指向，下方是相同指向。

![](./images/1716883874556.png)
### 函数调用

> 虽然func2 效率更高，但是根据 f() 的情况，
> func1 调用了四次，而func2 只调用了一次。
> 其中注意： counter++ 是最后才进行+1，所以func2 = 0

![](./images/1716884200721.png)
>所以需要程序员花费更多的精力来编写高质量的代码。

### 如何表示程序的性能

> 对于一个向量a 包含 n个元素， n 是一个变量
> 计算出向量a的前缀和(the prefix sum)，保持到向量p中。


**前缀和：**


![](./images/1716884472419.png)
**实现计算前缀和：**

![](./images/1716884520680.png)
**更加高效的实现方法**：psum2 一次迭代可以计算出两个元素的值。

![](./images/1716884558313.png)
> 这种技术叫做 ： **循环展开**

**对比 psum1 和 psum2的性能：**

横坐标：元素的个数
纵坐标：时钟周期数

6 和 9  = 线性因子。 

![](./images/1716884693800.png)
>CPE ——> **每个元素**执行所需要的周期数。
>psum 1 的 CPE = 9.0 （线性因子）
>psum 2 的 CPE = 6.0 （线性因子）

## 5.2 优化程序性能（二）
如何优化程序的性能

### 向量的抽象数据类型

>两个内存块： 头部 Header 和 数组 Data

头部声明为结构体（如图左边表示）
len = 向量的长度
data_t 向量元素的数据类型

![](./images/1716884886390.png)
### 代码示例1（对向量的所有元素进行求和/求积）：

![](./images/1716885043157.png)
>vac_length 向量的长度
>get_vac_element 获取向量第 i 个元素的值，结果保存到变量 val 中。


其中，评估是通过CPE来进行，所以数值越小越好。

![](./images/1716885313640.png)
#### 如何优化代码：

>每次for ，都得调用 vec_length(v)。但实际上在运行时，该长度不会产生变化。

![](./images/1716885373324.png)
>因此再执行循环前，先调用，把数据给局部变量 length 就可以了。
>之后就不会继续调用了。
>这个方法就是：**代码移动**

![](./images/1716885403233.png)
修改后：

![](./images/1716885489240.png)




## 5.3 理解现代处理器
## 5.4 数据流图
##  5.5 循环展开
## 5.6 理解内存性能