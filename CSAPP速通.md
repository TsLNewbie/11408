---
title: CSAPP速通
category: /小书匠/日记/2024-05
grammar_cjkRuby: true
---
内容来源：[【CSAPP-深入理解计算机系统】](https://www.bilibili.com/video/BV1cD4y1D7uR/?spm_id_from=333.337.search-card.all.click&vd_source=d1002d9c1ba92da4ba3fca4fdca6d750)作者：九曲阑干

# 第一章 计算机系统漫游
一个Hello Program的生命周期：
![](./images/1716303432503.png)

The Hello Program—— hello.c
```c
#include<stdio.h>
int main()
{
	printf("hello,world\n");
}
```

>linux> gcc -o hello hell.c

通过以上的命令，便能生成一个可执行程序——hello.

>编译过程分为四个阶段：**预处理，编译，汇编，连接**

![](./images/1716303711950.png)

预处理器——会通过#开头的代码，来修改原始程序，将内容直接插入到源程序中。——hello.i（文本文件）

编译——词法分析，语法分析，语义分析——（进行翻译）——hello.s

汇编——翻译成机器指令的文件——hello.o(可重定位目标文件)(二进制文件)

链接——hello中调用了printf的函数，printf在printf.o文件中（提前编译号的目标文件），把两个进行合并。——可执行目标文件hello



了解这些知识是为了:
- 优化程序性能（第三章，第五章）
	- 一个函数调用的开销有多大？
		- while比for循环高效？
		- switch语句是不是要比一连串if-else高效的多？
- 理解链接时出现的错误（第七章）
	- 很多问题往往在链接时出现问题。
		- 函数库的调用
		- 静态变量/全局变量的区别
		- 静态库和动态库的区别？
- 避免安全漏洞（第三章）
	-   缓冲区溢出是常见的问题。
		-   理解数据和控制信息在程序栈上是如何存储
		-   书写方式

**运行一个 hello程序 by Shell**

![](./images/1716358526708.png)
## 计算机的硬件组成
![](./images/1716359102190.png)
(第四章讲述CPU)
中央处理单元(Central Processing Unit,CPU)

程序计数器 Program Count(PC)

32-bit:
1 word = 4 Byte

64-bit:
1 word = 8 Byte

系统上电，直到系统结束，CPU就不断在执行PC指向的指令。然后更新PC，指向下一条要执行的指令（两个指令不一定是相邻的）

寄存器 Register File 
CPU内部的存储设备：临时存放数据的空间

算术逻辑单元 Arithmatic/logic Unit (ALU)
用来进行算术

主存/内存 Main Memory （第六章）
存放程序指令以及数据。
物理上，随机动态存储器芯片组成。
逻辑上，看成一个从零开始的大数组。 每个字节都有相对应的地址。

总线 bus
内存和处理器之间通过总线来进行数据传递。
通常总线被设计为传送固定长度的字节块，也就是Word。

I/O 输入输出设备 （第六章、第十章）
每个 I/O 设备都通过一个控制器或者适配器与 I/O 总线相连。

**Hello程序执行的过程：**
1) 输入hello
![](./images/1716359177699.png)
2) 点击回车键，完成指令输入
![](./images/1716359205982.png)
3) 执行Main()函数的代码：
![](./images/1716359259300.png)


>存储关系：
>大容量的存储设备的存取速度要比小容量的慢
>运行速度更快的设备的价格相对于低速设备要更贵

系统设计人员在寄存器文件和内存之间引入了高速缓存
![](./images/1716359616141.png)

**存储层次**
![](./images/1716359650059.png)

>真正操控硬件的是**操作系统**
>所有的应用程序对硬件的操作必须通过操作系统来完成。
>目的有二：
>1.防止硬件被失控的应用程序滥用
>2.系统提供统一的机制来控制这些复杂的底层硬件

**抽象的概念：**
![](./images/1716359858853.png)


## 进程
借助hello程序运行的场景来解释 **进程**

![](./images/1716360225959.png)
通过shell进程加载hello进程，shell进程系统调用。
系统调用会将控制权从shell进程传递到操作系统，操作系统保存shell进程的上下文，然后创建一个新的hello进程及其上下文，将控制权转交给hello进程。
hello进程结束，系统就会恢复shell进程的上下文，并将控制权交给shell进程，shell进程等待下个命令行的输入。

Context（上下文）：操作系统会跟随进程运行中所需要的所有状态信息。（PC和寄存器的值，内存的内容等等）（第八章）

一个进程由多个线程组成，共享代码和数据。
![](./images/1716360756324.png)


## 虚拟内存
>它为每个进程提供了一个假象，就是每个进程都在独自占用整个内存空间。
>每个进程看到的内存都是一样的，便是 **虚拟地址空间**

虚拟地址空间：
![](./images/1716360887224.png)




第一个区域用来 **存放程序的代码** 和 **数据**
该区域的内容是从可执行目标文件中加载而来的。
C语言中，全局变量便是放在这。

第二区域 堆（malloc）
Memory Allocate
堆可以运行时动态的扩展和收缩

第三区域，共享库的存放区域
C语言标准库和数学库这种共享库的代码和数据

第四区域，用户栈
函数调用本质就是压栈：每次当程序进行函数调用的时候，栈就会增长，函数执行完毕返回时，栈就会收缩。
需要注意的是：栈的增长方向是从高地址到低地址。

最顶部区域，内核保留的区域
对应用程序是不可见的。

> Linux系统的哲学思想是：一切皆为文件（Everything is File）
> I/O设备，键盘，磁盘，显示器，网络都是文件。

![](./images/1716361297474.png)

>从一个系统来看，网络也可以视为一个IO设备

![](./images/1716363529552.png)

![](./images/1716364009969.png)
如何用ssh，通过网络在远程主机上运行hello程序。

![](./images/1716364100100.png)

## 阿姆达尔定律 Amdahl's Law
![](./images/1716364165613.png)
定量的看一下系统的加速比。
>定律的主要思想是，当我们对系统的某一部分进行加速时，被加速部分的重要性和加速程度是影响整体系统性能的关键因素。

假设一个应用程序的执行所需要的全部时间用Told表示。
红色部分为不可加速，另外一部分是可加速的。
其中可以加速部分速度 = a \* Told
所以不可加速部分为： Told - a \* Told = (1-a) Told

可加速的性能比例为k
可加速所花费的时间就是 (a\*Told)/k
最后可以得到加速比S

![](./images/1716364429335.png)
![](./images/1716364493722.png)
>因此，如果我们需要把系统的性能提高到2倍甚至更多，我们需要优化大部分组件。

**如何获得更高的计算能力？Concurrency（并发） and Parallelism(并行)**
1. 线程级并发
2. 指令级并行
3. 单指令，多数据并行


## 线程级并发

多核处理器的组织结构：

![](./images/1716364618796.png)

超线程（hyperthreading）/同时多线程

CPU内部，PC和寄存器存在多个备份，浮点运算部分只有一份。

![](./images/1716364759471.png)
超线程处理器可以在单周期的基础上决定执行哪一个线程。

## 指令集并行
![](./images/1716365126598.png)

近几年的处理器可以保持每个周期2-4条指令的执行速率。

## 单指令，多数据并行
单指令，多数据(Single Instruction Multiple Data,SIMD)
SIMD指令多是为了提高处理视频，以及声音这类数据的执行速度。

![](./images/1716365280909.png)


## 计算机系统的抽象 **

![](./images/1716365314162.png)

# 第二章 信息的表示和处理

Summary
1. Information Stroage（信息存储）
2. Integer Respresentations（整数表示）
3. Integer Arithmetic（整数运算）
4. Floating Point（浮点数）

## 2.1 信息存储
>通常情况下，程序将内存视为一个非常大的数组，数组的元素由**一个个字节**组成。每个字节都有唯一的数字表示，也就是**地址**。
>所有地址的集合——虚拟地址空间（virtual address space）

![](./images/1716365502638.png)
### 字节 Byte

>1 Byte = 8 bit

![](./images/1716365821132.png)
### 16进制数 Hexadecimal Notation
>十六进制好处：节省显示位置，方便与2进制转换。

十六进制表示：

![](./images/1716365943408.png)
无论是大小写，还是混合都正确。

二，十，十六进制的转换。

![](./images/1716366006624.png)
十六进制的转换比较直接，从图中能看出来。

>CSAPP原书介绍了一个小技巧：（好像没必要记住）
>记住 十六进制的 A,C,F
>那么B，D的数值可以由AC加一得到，E的数值可以由F减一得到。



#### 十六进制与二进制转换

>从最后一个，每四位分成一组，若最前一组出现没有四位的情况，那就补0

![](./images/1716366222778.png)
>记住这个： 2^(n)  -> n = i + 4j
>其中 
>i = 0 ，1，2，3
>hex = 1，2，4，8... 2^(i) (十进制)

![](./images/1716366324902.png)
#### 十进制与十六进制转换

>一直除 16，把余数拿来当作位数即可。

![](./images/1716366454548.png)
>对16进制，对应位置乘以 16^(i) 即可。

![](./images/1716366510992.png)

### 字 Word

**字长**

![](./images/1716366581005.png)

>大多数64-bit的机器做了向后兼容，因此32-bit可以在64-bit的机器上运用。
>主要的区别是：程序是如何编译的。

![](./images/1716366640443.png)
表格：C 的各个数据所占字节数的大小。

![](./images/1716366706479.png)

### 变量所在地址 *

>重点：**大端法(Big endian)**，**小端法(Little endian)**
>新的处理器，支持双端法，但android和IOS只支持小端法。

![](./images/1716366766061.png)

CSAPP原书在四个系统中尝试字节打印程序：

![](./images/1716366867524.png)

打印字节程序

![](./images/1716366894178.png)
其中：byte_pointer是强制切换为字节的序列。

![](./images/1716366963685.png)
![](./images/1716366978554.png)

因为不同操作系统使用不同的存储分配规则，指针的值是完全不同的。且32位用4Byte的地址，64位用8Byte的地址。

![](./images/1716366989620.png)
虽然整型和浮点数都是12345进行编码，但是却有完全不同的字节模式：

![](./images/1716367075119.png)

若换成二进制，并进行适当的移位，就发现有13个位的匹配：

![](./images/1716367116758.png)

> C语言的字符串被编码为以NULL字符结尾的字符数组。

![](./images/1716367275615.png)

### 布尔运算 *

>重点如图所示。与，非，或，异或。

![](./images/1716367360310.png)
C语言的特性：按位级运算支持布尔运算。

![](./images/1716367403472.png)
> 位运算的常见场景便是**掩码运算**

例如：对于一个数组，如何去获取最低有效数值？可以通过 & 0xFF

![](./images/1716367473819.png)

#### 逻辑运算：
(只有 True 和 False)

![](./images/1716367516722.png)

![](./images/1716367543829.png)
#### 移位运算：

>右移 分 逻辑右移 和 算术右移

![](./images/1716367636427.png)

![](./images/1716367693111.png)
再看看例子：

![](./images/1716367715182.png)
>实际上，几乎所有的编译器以及机器的组合都是对**有符号数**使用**算术右移**，**无符号数**就是 **逻辑右移**


## 2.2 整数的表示

表格(64位机器上的取值范围）：

![](./images/1716367803857.png)
>long类型的大小：取值范围是与机器字长相关的。

![](./images/1716367873978.png)

### 无符号数编码

>假设一个整数的数据类型有w位，用向量x来表示。
>把向量x看成一个二进制表示的数，每个元素=一个二进制位，每个位取值为0/1;
>B2U = Binary to unsigned

![](./images/1716368039061.png)

CSAPP原书的图形表示法：

![](./images/1716368096574.png)

### 有符号数编码 
Two's Complement Encodings （补码）

>主要注意的是，最高位的权重是 **负数**

![](./images/1716368200193.png)
补码图形化：

![](./images/1716368248155.png)

### 可表示的整数范围

无符号数：

![](./images/1716368309910.png)

有符号数：
最大数：

![](./images/1716368332757.png)

最小值：

![](./images/1716368365971.png)

特别注意： 

![](./images/1716368391592.png)

例子：

![](./images/1716368445312.png)


### 有符号数 / 无符号数的转换

通过强制转换，就会出现问题：

![](./images/1716368514699.png)
>位模式不变，解释这些位的方式改变了。

**有符号数与无符号数之差**
> B2U = 无符号数
> B2T = 有符号数 
> T2U= 有符号数到无符号数的函数映射

![](./images/1716368709923.png)
>有符号数到无符号数的规则：
>当有符号数为正数，那么就是 相同的数
>当有符号数为负数，那么就是 数值 + (最大的位+1)

>无符号数到有符号数的规则：
>当无符号数的最高位=0，那么就是 相同的数
>当无符号数的最高位=1，那么就是 数值 - (最大的位+1)


C语言会隐式的将有符号数强制转换为无符号数来执行运算。

![](./images/1716369015000.png)

>将一个较大的数据类型 转换 较小的类型 是不可能的。
>但较小的数据类型 转换 较大的类型 是可以的。


无符号数的转换：**零扩展**

![](./images/1716369145178.png)
#有符号数的转换： 符号位扩展

![](./images/1716369179768.png)
原书内容：

>数学归纳法

![](./images/1716369250197.png)

![](./images/1716369302109.png)
![](./images/1716369337681.png)


>较大数值 -> 较小数值
>高16位被丢弃，只留下低16位的数据. 

>总之，无符号数以及有符号数的转换会出现一些难以发现的错误（非直观）。了解这类知识，就避免这种问题。


## 2.3 整数运算

### 无符号数加法：

![](./images/1716369578870.png)
>产生这个结果的原因是 以及超过char的数值。(溢出)

引入无符号数的加法的标志：

![](./images/1716369638693.png)
两个无符号数加法的情况：

![](./images/1716369654251.png)


原因：

![](./images/1716369700215.png)
>由于加完1就溢出了，为了避免位数增加，因此变成这样，且不会报错。

**判断溢出：**

![](./images/1716369778229.png)
原理：

![](./images/1716369854738.png)

### 有符号数加法：

引入符号：

![](./images/1716369875620.png)
情况：

![](./images/1716369917225.png)
例子：

![](./images/1716369939807.png)

原理：

![](./images/1716369967829.png)

**检测是否发生溢出：**
![](./images/1716370056299.png)


### 加法逆元（Additive Inverse）

图中：x' 便是 加法逆元。

![](./images/1716370199286.png)

**无符号数的逆元：**

![](./images/1716370534274.png)
**有符号数的逆元**

![](./images/1716370564413.png)

### 乘除运算

**无符号数**

![](./images/1716386761592.png)
C语言中，定义了无符号数乘法所产生的结果是w位
因此结果会截取低w位的成果。——取模

![](./images/1716386837319.png)
**补码**

>与无符号数多了一个操作，就是把无符号数**补码**——转成有符号数

![](./images/1716386901798.png)
例子：

![](./images/1716386959401.png)
>虽然有符号数和无符号数在计算出来的位级表示可存在不同，但是截断后是**相同的**。

通过数学的方法来表示。 x，y有符号数，x' , y' 为 无符号数。

![](./images/1716387059862.png)
有符号数和无符号数的关系如下：

![](./images/1716387084333.png)
取模的推导过程：

![](./images/1716387096352.png)
很多C语言的编译器试图用**移位**、加法以及减法来代替整数乘法操作。

![](./images/1716387180158.png)
移位操作通过数学公式表达：

![](./images/1716387225093.png)
例子：

![](./images/1716387310257.png)

### 除法（右移）

>对于无符号数采用的是**逻辑右移**，而有符号数采用的是**算术右移（补1/0）**

![](./images/1716387410612.png)
会遇到除不尽的情况：

3.14向零舍入的结果是3，-3.14向零舍入的结果是-3
(1)正数，向下舍入
(2)负数，向上舍入

![](./images/1716387551637.png)
**无符号数除以2的幂的情况**

![](./images/1716387617719.png)

> x >> k：进行右移K位

![](./images/1716387703072.png)
> x << k: x左移K位 = x1 × 2^(k)

![](./images/1716387765773.png)
>x1 左移 k位 与 x2 相加之和 与 x 相等。

![](./images/1716387802411.png)
>由于 x2 的长度为 k 位， 因此 x2 的取值范围大于等于 0 ，小于2 的k 次方
>x 除以 2 的k次方，取整的结果 = x1


**补码**

![](./images/1716388137432.png)
>特别注意：当需要舍入时，移位导致 -771.25 向下舍入为 -772
>我们期望得到的结果是-771。
>因此需要加入偏置，修正这种不合适的舍入。



![](./images/1716388288065.png)
>当右移四位时，偏置量 = 15（1 << 4 -1)
>当右移八位时，偏置量 = 255 (1 << 8 - 1)
>注意红圈的位置。

![](./images/1716388532318.png)
> (1) 先加入偏置量，再进行**算术右移**
> (2) 直接进行**算术右移**

## 2.3 浮点数 Floating Point

考虑含有小数值的二进制数

十进制表示小数：

![](./images/1716389280566.png)
二进制表示小数：

![](./images/1716389319350.png)

IEEE对浮点数的表示：

![](./images/1716389512740.png)

>以上红色的数字代表长度。
>exp与阶码的值是相关的
>frac与尾数M是相关的

浮点数的数值分为三类：
1. 规格化的值
2. 非规格化的值
3. 特殊值

![](./images/1716389645042.png)
### 规格化的值

![](./images/1716389755291.png)
![](./images/1716390044906.png)

>单精度浮点数：
>阶码的最小值是 -126，最大值是127
>小数字段：M = 1+f
>1 是 因为 我们可以调整E的取值，使得尾数M的取值范围大于等于1，小于2，既然第一位总是1，就没必要显示的表示出来。

### 非规格化的值

![](./images/1716390120377.png)
>与规格化的解释方法不同。

### 特殊值

![](./images/1716390183327.png)
>NaN 的意思是 NOT A Number.
>当阶码字段全为1，且小数字段不为0时，可以表示NaN。

**例子：8为浮点数的表示**

![](./images/1716390324819.png)

非规格化：

![](./images/1716390268317.png)

规格化、特殊值：

![](./images/1716390343016.png)

在之前进行过整型数和单精度浮点数的对比：

![](./images/1716428655044.png)
通过移位，发现二者有一段数位是相同的。

![](./images/1716428664557.png)
通过 转换 就能发现为什么会有数位相同的情况。

### 整型 转换 浮点数

整型 12345 如下，因为高位都是0，所以忽略。

![](./images/1716428777148.png)
根据规格化的表示规则，如下表示：可以发现阶码E的值=13

![](./images/1716428835769.png)
由于单精度小数字段长度为23，末端需要补0：

![](./images/1716428872383.png)
这样就获得了浮点数的小数字段。

阶码E的值=13 ，由于单精度的浮点数bias = 127 （固定值），并可以通过以下公式进行计算：

![](./images/1716428989672.png)
这样浮点数的表示就出现了。

![](./images/1716429010696.png)
由于表示方法原因，限制了浮点数的范围。

希望可以找到“最接近的值 x' 代替x”

![](./images/1716429200208.png)
IEEE定义了四种舍入方式：
1. 向偶数舍入(Round-to-even)
2. 向零舍入(Round-toward-zero)
3. 向下舍入(Round-down)
4. 向上舍入(Round-up)

**向下舍入，向上舍入，向零舍入：**

![](./images/1716430041945.png)

**向偶数舍入（向最近的值舍入）**

>当遇到两个可能结果的中间数值时（1.5，2.5），才需要进行这个舍入判断。
>一句话： **四舍六入五偶**

![](./images/1716430100015.png)
>为什么要用？
>因为如果总是用向上/向下舍入，会导致结果的平均值对于真实值略高/略低。
>向偶数舍入就避免这种偏差，让向上/向下舍入都有50%的概率。

例子：**四舍六入五偶**

![](./images/1716430381427.png)

