---
title: C# 基础内容(速通）
category: /小书匠/日记/2024-03
grammar_cjkRuby: true
---
参考视频：[新印象 Unity 2020游戏开发基础与实战](https://www.shuyishe.com/bookDetails?id=UB77c7a31cc7468) 其中的视频教学内容。
参考内容：[C# 菜鸟教程](https://www.runoob.com/csharp/csharp-operators.html)

C# 是微软公司发布的一种由C和C\+\+衍生出来的**面向对象**的编程语言，运行于 .NET Framework 和 .NET Core(完全开源，跨平台) 之上的高级程序设计语言。
C#编程 比 C++ 简单很多 ==(真的吗？) #9E9E9E==

C# 其中很重要的功能就是垃圾回收，可以让应用不使用某些内存的时候，自动释放。

![](./images/1709539958276.png)

# C# 基本格式 ：
C# 代码由一条条语句构成，每个语句都以分号结束 ==（这和C++ ，C 就一样了） #9E9E9E==

C# 编译器不会考虑代码中的回车，空格 或 Tab字符。

C# 是区分大小写的，在编写语句的时候要保证大小写不要出错，否则无法识别。

代码实例：

```C# 
	Console.WriteLine("I love Unity"); Console.WriteLine("Great Unity");
	Console.WriteLine(	"Wo ai Unity");
```

C# 注释有两种， // 和 /* \*/

# 类型与进制
## 进制
进制就是 进位计数制，是人为定义的一种带进位机制的计数方法。

计算机内部使用二进制（为什么用二进制，这在计算机CCCS有提到）

常用进制： 二进制，八进制，十进制，十六进制。


十进制：1x10^n
例子：
520 = 5x10^2 2x10^1 0x10^0

当然其他进制都可以。

二进制 = 1x2^n

八进制 = 1x8^n

十六进制 = 1x16^n

## 计算机单位转换
计算机有以下单位：bit,Byte,KB,MB,GB,TB,PB....
8位二进制最大为 11111111 = 255

1 Byte(字节) = 8 bit(位)

1KB = 1024 Byte

1MB = 1024 KB
....
1PB = 1024 TB
....

## 数据类型:
<a class="xsj_anchor" name="xsj_1709541070261"></a>
![](./images/1709458882487.png)

# 常量与变量
## 常量
**常量**：程序运行期间，不能被改变的量
整型常量：2, 3, 4

浮点型常量：1.2f, 2.3f

字符型常量：'a', 'b', 'A'

字符串常量："123"，"a", "1.2", " "

任何东西都可以是**常量**
```c
const int a = 10; //const常量定义
```
# 变量
**变量**：程序运行期间，可以被改变的量。

本质：变量是一个存储空间，被改变的是存储的内容

注意：变量一定要先定义再使用

举个例子：商店储物柜，图书馆里的书架子。

代码：
```c#
int a;
double b;
float c;
bool d;
```

## 命名规范（程序员的规矩）
1.只能由字母、数字、下划线或@组成，并且不能以数字开头，
	@只能用在开头_hello_.World34
2.不可以与系统关键字同名
3.不能使用重复的变量名(C#大小写敏感)
4.要使用驼峰命名方法int helloWorld hello_world
5.见名知意（规范）

# 数组
## 一维数组
```c#
// 一组年龄
int[] ages;  //和C++好像不同？ C++的话就是 int i[];
// 一组分数 
float[] scores;
// 一组名字
string[] names;
```

## 初始化
在定义数组后，必须对其进行**初始化**才能够使用。

数据类型[] 数组名 = **new** 数据类型\[数组长度\]

```c#
int[] intArray = new int[6]; //数组元素为默认值

//以下两个是一样的意思。
int[] intArray = new int[3]{1,2,3}; 
int[] intArray = new int[]{1,2,3}; //会根据{}的值提供空间

int[] intArray = new[]{1,2,3};

//数据类型[] 数组名 = {元素1, 元素2, ..., 元素n};
int[] myArr = {1,2,3,4,5}; //一般用这个，省事
```

其中 new 很重要！

## 数组元素的访问

元素访问： 数组名\[下标\]

```c#
int[] a = {2,7,4,3,6};

a[0] = 3;
int b = a[0];

```

数组下标：数组元素在数组中的序号。

数组下标**从0开始计数**。

数组长度：a.Length表示数组的长度(这样最大的下标就是 \[a.Length-1\])

## 值类型 引用类型

值类型： int,bool... 枚举、 结构体

引用类型： 字符串，数组
```
int a = 3; int b = a;
int[] a = {2}; int[] b = a;
```
**栈**：自动分配空间、空间连续、速度块。（所有的值类型存储到栈里）
**堆**：程序员申请、空间不连续、速度慢。


![](./images/1709533363912.png)图中，栈中：
值类型：
第一个3 对应 int a = 3; 
第二个3 对应 int b = a; (计算机背地里意思是 把a的值复制，开一个新的栈放入)

引用类型：
第三个Ox435AB343 对应 int[] a = {2}; （其实这个Ox435AB343是地址，引用的是堆中的一个地址，这地址里存放中一个2）
第四个Ox435AB343 对应 int[] b = a; (b的指针指向了a同样指向的一个堆里的地址。)

这里有个讲究，虽然第三和第四个分开了，但指向了同一个地址，其实指向的内容是同一个东西。若这个堆里的东西修改了，这两个内容都会产生变化。

数组 属于 一种引用类型，因此如果将 数组b 赋给 数组a，那么 数组b 在操作数组元素时，实质上操作的还是 数组a。

## 两项 注意：
1. 系统不会检测数组元素的下标是否越界，编程时，必须
保证数组**下标不能越界**。
2. 数组是一个整体，不能直接参加运算(=除外)，只能对单个元素进行处理，通常用到数组的地方都会用到**循环**。

## 二维数组
有两个下标的数组就是二维数组 
```C#
int[ , ] Arr = new int[2, 5] { { 1, 2, 3, 5, 6 }, { 1, 2, 3, 4, 5 } };
//其中，int[2,5] 2为第一维的长度，5为第二维的长度
//把2，5省略了都是可以的。

```

二维数组本质上是以 **数组作为数组元素** 的数组，即"数组的数组"

![](./images/1709534157032.png)

访问：
![](./images/1709534254688.png)

# 运算符 (一)

**赋值运算符：**=
用于给变量幅值，将右边的值赋给左边的变量。

e.g: age =24;

赋值运算符优先级较低（后计算）

**算术运算符：** + - * / % ++ --

e.g: a=a + b -c;

++ 和 --

如果 ++ 在变量的前面 ，先进行+1 ，再参与运算; a = ++5;

如果 ++ 在变量的后面 ，先进行运算 ，再+1; a = 5++;

**复合运算符：**
是对算术运算符的**缩写形式**，使得对变量的改变更为简洁。

e.g：a += b; 等价于 a=a+b;
a = a/b ; a/=b;
a = a%b ; a%=b;

## 输出函数
```C#
System.Console.WriteLine("Hello World！");
```
此方法为 Console 类 的输出方法之一。（C\+\+中类与对象，其中函数调用）
如果程序开始处包含 "using" 指令 ，则可省略 System 类直接调用他们。
>C\+\+中有：using namespace std，
C#是 using system，
Python也有类似指令：from openpyxl import \*


## 输入函数
```C#
int n = Console.Read();

string str = Console.ReadLine();
```

> 番外：
> 在C++中的 return 0; 的作用
> 在C# 中用 Console.ReadKey(); 取代.

# 类型转换
## 隐式转换
描述：是一种安全类型的转换，不会导致数据丢失，因此不需要任何特殊的语法。**由小到大时**（关于范围的），系统**自动**的进行隐式转换。

[回顾常用的数据类型](xsjapp://doc/5cdab02f-4f05-42fc-a056-7041b54ccd81#xsj_1709541070261)
>其中byte范围是 0 ~ 255
>int 范围是 -2147483648 ~ 2147483647 (2^31 ~ 2^ 31-1)

int a = 5;
byte b = 6;
a = b; ? 无风险
b = a; ? 有风险（byte范围太小了）

> 当你 a = b时，其实计算机内部运行了以下的操作
> 先把 b 的类型变成 int
> 然后b赋值a
> b的类型变回 byte

## 强制转换（显式转换）

描述：显式转换需要强制转换运算符。**由大变小**需要用强制转换，这样需要 **付出缺
失精度的代价。**

方式1：
```c#
Double d = 3.4;
int a = (int)d; //这个部分就是把d强制变成int且就会变成3.

int d = 3;
byte a = (byte)d; //强制变成byte，但可能会出现一些问题。
```

方式2：
```c#
Convert.Tolnt32(d);
```

## 装箱与拆箱
装箱与拆箱就是**值类型**与**引用类型**的转换，是值类型和用类型之间的桥梁。
只有值类型才存在装箱和折箱。
装箱是隐式的，拆箱是显式的，因为你需要告诉C#你要给拆出来的值赋予什么类型。
```c#
int i = 3; //值类型（在栈）
object o = i; //装箱 
int b = (int) o ; //拆箱
```
![](./images/1709541935623.png)
# 运算符(二)

**关系运算符:**
**作用**：描述前后表达式之间的**大小关系**，关系运算符的结果一定是一个**bool类型**

![表格](./attachments/1709542129483.table.html)
**逻辑运算符**：
**作用**：描述前后表达式之间的**逻辑关系**，逻辑运算符的结果一定是一个**bool类型**

![](./images/1709542593768.png)
```c#
bool e = a>b && c>d
```

**位运算符**：
位运算符作用于位，并逐位执行操作。

![](./images/1709542678415.png)

**三目运算符：**
**语法描述：** true/false?结果a:结果b
**结果：** 如果前面是运算结果为true,则结果为结果a,否则结果为结果b
**举例：** 
```c#
c = a>b?a:b //c取a,b之间最大的值
```
**即：** 如果a>b,则结果为a,否则结果为b

# 分支结构
**顺序结构：** 代码从上往下，从左往右，依次执行
**分支结构(if,switch)：** 当我们的程序执行到某个位置的时候，进行条件判断，根据判断的结果来执行不同的操作；
**循环结构(while)：** 在满足某个条件的时候反复执行一个语句序列（循环）。

![](./images/1709542982040.png)
## if 分支结构(判断)

```c#
if(条件表达式1){ // 条件表达式：true or false
	语句1;
}

if(条件表达式2){ 
	语句1;
}
else{
	语句2;
}

if(条件表达式3){ 
	语句1;
}
else if (条件表达式4){
	语句2;
}

```
这个和C\+\+，C基本一模一样。

举个例子:
```c#
using System;
namespace Test
{
	class Program
	{
		static void Main(string[] args)
		{
			//输入字符串
			string str = System.Console.ReadLine();
			//字符串转为整数
			int num = Convert.Tolnt32(str);
			if(num > 10)
			{
				Console.WriteLine(num * 2);
			}
			Console.ReadKey();
		}
	}
}
```

## switch分支结构
switch 匹配分支。
break 跳出 switch。（跳出一个）
case都没匹配到，就执行default
没有default就结束。
多个case可以运行一个语句块。
```c#
switch(表达式a)
{
	case 值1:{语句;break;}
	case 值2:{语句;break;}
	...
	case 值n:{语句;break;}
	default:{语句;break;}
}
```

# 循环
日常生活中的循环：
1.在操场跑5圈
2.抄写文章10遍
3.帮忙捶背20下
4.背英文单词
5.每天必做的睡觉、起床、吃饭等

游戏中的循环：
1.打怪50只
2.采花10朵
3.房间中出现10个敌人
4.判断任务列表中有没有完成的任务

循环
![](./images/1709559441740.png)
C# 提供了几种循环结构：
![](./images/1709559467416.png)
## While 循环：
```C#
while(condition)
{
   statement(s);
}
```
在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。condition 可以是任意的表达式，当为任意非零值时都为真。当条件为真时执行循环。
**流程图**
![](./images/1709559497709.png)
其中：
break：跳出**当前循环**，不会执行剩下的循环
continue：结束**本次循环**，进入下次循环




## for/foreach 循环
```c#
for ( init; condition; increment )
{
   statement(s);
}
```

 1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
(比如说 int i=0)
 2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
(比如说 i>j)
 3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
 (比如说 i++ )
 4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。
**流程图：**
![](./images/1709559738472.png)

**foreach**
使用 foreach 可以迭代数组或者一个集合对象。

用来遍历集合类型，例如数组、列表、字典等。它是一个简化版的 for 循环，使得代码更加简洁易读。
```c#
foreach (var item in collection)
{
    // 循环
}

//举个例子

foreach (int tmp in array)
{
	Console.WriteLine(tmp);
}
```
collection 是要遍历的集合，item 是当前遍历到的元素。



## do...while循环
>不像 for 和 while 循环，它们是在循环**头部测试循环条件**。do...while 循环是在循环的**尾部**检查它的条件。
do...while 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。

也就是**先do完后判断**，而for和while先判断你有没有问题，后执行。

```c#
do
{
   statement(s);

}while( condition );
```

**流程图：**
![](./images/1709559898797.png)
## 嵌套循环

循环 和 判断一样，可以嵌套。因此具体效果是：
```c#
for ( init; condition; increment )
{
   for ( init; condition; increment )
   {
      statement(s);
   }
   statement(s);
}

while(condition)
{
   while(condition)
   {
      statement(s);
   }
   statement(s);
}

do
{
   statement(s);
   do
   {
      statement(s);
   }while( condition );

}while( condition );
```

# 10.冒泡排序（七大排序之一）
额外参考： [数据结构-- 七大排序算法](https://blog.csdn.net/qq_55660421/article/details/122704501)
>每次冒泡排序操作都会将相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足，就交换这两个相邻元素的次序，一次冒泡至少让一个元素移动到它应该排列的位置，重复N次，就完成了冒泡排序。


![](./images/1709561000869.png)
具体实现：
```C++
/*
     *冒泡排序法
     */
    public void bubbleSort(int[] arr, int n){
        if(n<=1){
            return;
        }
        for(int i=0;i < n;i++){
            boolean flag = false;
            for (int j = 0; j < n-i-1; j++) {
                if (arr[i - 1] > arr[i]) {
                    swap(arr, i - 1, i);
                    flag = true;
                }
            }
            if(!flag) break;//没有数据交换，数组已经有序，退出排序
        }
    }
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```

# 11.函数/方法

一个函数是把一些相关的语句组织在一起，用来执行一个任务的语句块。
每一个C#程序至少有一个带有Main函数的类。
方法中可以包含参数，参数包括**普通传参**、**引用传参**、**输出传参**。

```c#
using System;
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 10;
			int b = 5;
			// a,b分别自增，然后相加，输出和
			int num = add(a,b);
			console.WriteLine(num);
			console.ReadKey();		
		}
		
		static int add(int a,int b) //这个函数其实可以是一个int类型的数据
		{
			a++;
			b++;
			int num = a+b;
			return num; //函数用的是int，因此返回一个int。
		}
	
	}



}
``` 

## 递归：
在任何一个方法中，我们都可以调用其他方法，但是也可以调用自身方法，当调用自身方法的时候，就把它叫做**递归方法**
**注意：** 递归方法一定要有出口，不然会造成死循环。
(就是一定要做个判断，可以结束这个函数的，不然就死循环了，程序就boom了。)

